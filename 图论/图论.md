# 图论

## 最短路 + 负环

### Dijkstra 单源最短路

[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

要求无负环，复杂度 $(n + m)\log n$

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int INF = 1e18;
int n, m, s;
vector<vector<PII>> g;

void dijkstra(int s, vector<int> &dis) {
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    dis.assign(n + 1, INF);
    dis[s] = 0;
    heap.push({0, s});
    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dis[u]) {
            continue;
        }
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                heap.push({dis[v], v});
            }
        }
    }
}

void SolveTest() {
    cin >> n >> m >> s;
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
    }
    vector<int> dis(n + 1);
    dijkstra(s, dis);
    for (int i = 1; i <= n; i++) {
        cout << dis[i] << " \n"[i == n];
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



 dijkstra 的精髓在于：松弛操作。在松弛的时候可以进行

- 最短路计数
- 记录具体的最短路径（即 `vector<int> from(n + 1)`）。

[P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  求起点到每个点的最短路的数量。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int MOD = 100003;

int n, m, s = 1;
vector<vector<int>> g;
vector<int> dis, dp;

void dijkstra() {
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    dis.assign(n + 1, 1e15);
    dp.assign(n + 1, 0);
    dis[s] = 0;
    dp[s] = 1;
    heap.push({0, s});
    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dis[u]) {
            continue;
        }
        for (int v : g[u]) {
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                dp[v] = dp[u] % MOD;
                heap.push({dis[v], v});
            } else if (dis[v] == dis[u] + 1) {
                dp[v] += dp[u];
                dp[v] %= MOD;
            }
        }
    }
}

void SolveTest() {
    cin >> n >> m;
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dijkstra();
    for (int i = 1; i <= n; i++) {
        cout << dp[i] << endl;
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



补充一道例题。[P1875 佳佳的魔法药水](https://www.luogu.com.cn/problem/P1875) 这道题有助于加深对 dijkstra 思想的理解。



### Dijkstra 次短路

[P2865 [USACO06NOV]Roadblocks G](https://www.luogu.com.cn/problem/P2865) 给无向图，求 $(1,n)$ 间的次短路。

```CPP
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int N = 5e5 + 7, INF = 1e9;
int n, m;
vector<vector<PII>> g(N);

int dijkstra() {
    vector<array<int, 2>> dis(N, {INF, INF});
    dis[1] = {0, INF};
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});

    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dis[u][1]) {
            continue;
        }
        for (auto [v, w] : g[u]) {
            if (dis[v][1] > d + w) {
                dis[v][1] = d + w;
                heap.push({dis[v][1], v});
            }
            if (dis[v][0] > dis[v][1]) {
                swap(dis[v][0], dis[v][1]);
            }
        }
    }
    return dis[n][1];
}

void SolveTest() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    cout << dijkstra() << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### Bellman-Ford 单源经过 $k$ 个点最短路

[2022CCPC女生赛 H. 提瓦特之旅](https://codeforces.com/gym/104081/problem/H) 给一张有无向图带边权，若干次询问。每次询问给出点 $x$ 和一个序列 $w$，查询点 $1$ 到 $x$ 的最短路， $w_i$ 表示经过 $i$ 个点所需要的额外花费。

设 $dis[k][i]$：经过不超过 $k$ 个点到达 $i$ 的最短路。

则 $dis[k][i] = \min (dis[k][i], dis[k - 1][j] + g[j][i] )$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int INF = 1e18;

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n + 1, vector<int>(n + 1, INF));
    auto dis = g;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u][v] = min(g[u][v], w);
        g[v][u] = min(g[v][u], w);
    }

    // dis[k][i] 表示：从 1 到 i 经过 k 个点（不包含 1）的最短路
    for (int i = 1; i <= n; i++) {
        dis[1][i] = g[1][i];
    }
    for (int k = 2; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dis[k][i] = min(dis[k][i], dis[k - 1][j] + g[j][i]);
            }
        }
    }

    int q;
    cin >> q;
    for (int T = 1; T <= q; T++) {
        int t;
        cin >> t;
        vector<int> w(n);
        for (int i = 1; i < n; i++) {
            cin >> w[i];
            w[i] += w[i - 1];
        }
        int ans = INF;
        for (int i = 1; i < n; i++) {
            ans = min(ans, dis[i][t] + w[i]);
        }
        cout << ans << endl;
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```





### SPFA 单源最短路 + 判负环

[P3385 负环模板题](https://www.luogu.com.cn/problem/P3385)

判断能否从点 s 进入负环。如果要判断全图负环的话，可以从一个超级源点向所有点连一条边权为 $0$ 的边，或者在一开始把所有点加入队列。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e18;
int n, m, s = 1;
vector<vector<PII>> g;

bool spfa(int s, vector<int> &dis) {
    dis.assign(n + 1, INF);
    vector<int> inq(n + 1, 0), cnt(n + 1, 0);
    queue<int> q;
    dis[s] = 0;
    q.push(s);
    inq[s] = 1;

    while (q.size()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
                if (cnt[v] > n) {
                    return false; // 会从s进入负环
                }
            }
        }
    }
    return true; //不会从 s 进入负环
}

void SolveTest() {
    cin >> n >> m;
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        if (w >= 0) {
            g[v].push_back({u, w});
        }
    }

    vector<int> dis(n + 1, INF);
    cout << (spfa(s, dis) ? "NO" : "YES") << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### Johnson 全源最短路

[P5905 【模板】Johnson 全源最短路](https://www.luogu.com.cn/problem/P5905)

有向图，边权可能为负。求任意两点最短路

其实就是从 $n$ 个点分别跑一次 dijkstra，关键点是预处理给每个边权重新赋值。复杂度 $O(nm\log m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int INF = 1e9;
int n, m;
vector<vector<PII>> g;
vector<vector<int>> dis;

bool spfa(int s, vector<int> &dist) {
    vector<int> inq(n + 1, 0), cnt(n + 1, 0);
    queue<int> q;
    dist.assign(n + 1, INF);
    dist[s] = 0;
    q.push(s);
    inq[s] = 1;

    while (q.size()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
                if (cnt[v] > n) {
                    return false; // 会从s进入负环
                }
            }
        }
    }
    return true; //不会从 s 进入负环
}

void dijkstra(int s, vector<int> &dist) {
    dist.assign(n + 1, INF);
    dist[s] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, s});
    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dist[u]) {
            continue;
        }
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                heap.push({dist[v], v});
            }
        }
    }
}

void SolveTest() {
    cin >> n >> m;
    n++; // 新增一个虚拟节点
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
    }
    for (int i = 1; i < n; i++) {
        g[n].push_back({i, 0});
    }
    dis.assign(n + 1, vector<int>(n + 1));

    if (!spfa(n, dis[n])) {
        puts("-1");
        return;
    }
    // 重置边权
    for (int u = 1; u < n; u++) {
        for (auto &[v, w] : g[u]) {
            w += dis[n][u] - dis[n][v];
        }
    }
    for (int i = 1; i < n; i++) {
        dijkstra(i, dis[i]);
    }
    // 改回边权
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            if (dis[i][j] != INF) { // 特判两点是否可达
                dis[i][j] -= dis[n][i] - dis[n][j];
            }
        }
    }
    // 这里的 dis[i][j] 已经是任意两点距离了
    n--;
    for (int i = 1; i <= n; i++) {
        int ans = 0;
        for (int j = 1; j <= n; j++) {
            ans += 1ll * j * dis[i][j];
        }
        cout << ans << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}

```



### 01分数规划

[P2868 [USACO07DEC]Sightseeing Cows G](https://www.luogu.com.cn/problem/P2868) 给一张有点权 $f$ 有边权 $g$ 的有向图。对于图中一个环 $C$，定义它的价值为**环上点权和与环上边权和之比**。求图中所有环的最大价值。

做法是二分答案 $mid$，将每条边的边权修改为 $mid\times f[v] - g$。如果图中存在负环，那么说明这个 $mid$ 是可以取到的。用 SPFA 判断负环。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int INF = 1e9;
int n, m;
vector<double> f;
vector<vector<pair<int, double>>> g;

bool check(double x) {
    vector<int> inq(n + 1, 0), cnt(n + 1, 0);
    vector<double> dis(n + 1, INF);
    queue<int> q;

    for (int i = 1; i <= n; i++) {
        q.push(i);
        dis[i] = 0;
        inq[i] = 1;
    }

    while (q.size()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (auto [v, w] : g[u]) {
            // printf("f[%lld] = %lf, w = %lf, x = %lf\n", v, f[v], w, x);

            w = x * w - f[v];
            // cout << v << " " << w << endl;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
                if (cnt[v] > n) {
                    return true; // 会从s进入负环
                }
            }
        }
    }
    return false; //不会从 s 进入负环
}


void SolveTest() {
    cin >> n >> m;
    g.assign(n + 1, {});
    f.assign(n + 1, 0);
    for (int i = 1; i <= n; i++) {
        cin >> f[i];
    }
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
    }

    double l = 0, r = 1e9;
    while (r - l > 0.0001) {
        double mid = (l + r) / 2;
        if (check(mid)) {
            l = mid;
        } else {
            r = mid;
        }
    }
    cout << fixed << setprecision(2) << l << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```





### 分层图最短路

[P4568 [JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568) 

分层图模板题。给有边权的无向图，求从 $S$ 到 $T$ 的最短路。其中最多有 $k$ 条边的边权可以视为 $0$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int INF = 1e15;

int n, m, k, S, T;
vector<vector<PII>> g;

// 获取第 k 层的点 u 的编号
int id(int k, int u) {
    return n * (k - 1) + u;
}

int dijkstra() {
    vector<int> dis(n * k + 1, INF);
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    dis[S] = 0;
    heap.push({0, S});
    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dis[u]) {
            continue;
        }
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                heap.push({dis[v], v});
            }
        }
    }
    return dis[id(k, T)];
}

void add(int u, int v, int w) {
    g[u].push_back({v, w});
    g[v].push_back({u, w});
}

void SolveTest() {
    cin >> n >> m >> k >> S >> T;
    k++;
    g.assign(k * n + 1, {});
    S++, T++;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u++, v++;
        for (int j = 1; j <= k; j++) {
            add(id(j, u), id(j, v), w);
            if (j < k) {
                g[id(j, u)].push_back({id(j + 1, v), 0});
                g[id(j, v)].push_back({id(j + 1, u), 0});
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < k; j++) {
            g[id(j, i)].push_back({id(j + 1, i), 0});
        }
    }
    cout << dijkstra() << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 同余最短路

[P3403 跳楼机](https://www.luogu.com.cn/problem/P3403) 给定 $x,y,z,h$，对于 $k\in[1,h]$，求又多少个 $k$ 满足 $ax + by + cz = k$。（$a,b,c \ge 0$，$1\le x,y,z\le 10^5$，$h< 2^{63}$）。





## Floyd 相关算法

Floyd 算法的变形比较多，所以单独开一个模块。

### 全源最短路

[B3647 【模板】Floyd 算法](https://www.luogu.com.cn/problem/B3647)

转移过程：$f[k][i][j]$ 表示途经前 $k$ 个点（不包含起点和重点），从 $i$ 到 $j$ 的最短路。

```cpp
for (k = 1; k <= n; k++) {
  	for (x = 1; x <= n; x++) {
    	for (y = 1; y <= n; y++) {
      		f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);
    	}
  	}
}
```

无向图，求任意两点最短路。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e7;

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n + 1, vector<int>(n + 1, INF));
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u][v] = g[v][u] = w;
    }
    for (int i = 1; i <= n; i++) {
        g[i][i] = 0;
    }
    auto dis = g;
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dis[i][k] != INF && dis[k][j] != INF) {
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << dis[i][j] << " \n"[j == n];
        }
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 全源最短路计数

[P2047 [NOI2007] 社交网络](https://www.luogu.com.cn/problem/P2047) 

给定无向图（$n\le 100$），定义 $C_{s,t}$ 为 $(s,t)$ 间最短路数量，定义 $C_{s,t}(v)$ 为 $(s,t)$ 间经过 $v$ 的最短路数量。现在需要对所有点 $v$ 求出 $\sum_{v\ne s, v\ne t}\dfrac{C_{s,t}(v)}{C_{s,t}}$。

首先可以用 Floyd 算法求出两点间距离以及最短路数量，见代码中的 $dis$ 和 $cnt$。至于 $(s,t)$ 之间经过点 $v$ 的最短路数目，答案就是 $cnt[s][v] \times cnt[v][t]$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e9;

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> dis(n + 1, vector<int>(n + 1, INF));
    vector<vector<int>> cnt(n + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        dis[u][v] = dis[v][u] = w;
        cnt[u][v] = cnt[v][u] = 1;

    }

    // 核心部分，用 floyd 算法求两点间最短路以及最短路的数量
    for (int k = 1; k <= n; k++) {
        for (int i = 1;i <= n; i++) {
            for (int j = 1;j <= n; j++) {
                if (dis[i][k] == INF && dis[k][j] == INF) {
                    continue;
                }
                if (dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    cnt[i][j] = cnt[i][k] * cnt[k][j];
                } else if (dis[i][j] == dis[i][k] + dis[k][j]) {
                    cnt[i][j] += cnt[i][k] * cnt[k][j];
                }
            }
        }
    }
	
    // 计算答案并输出
    for (int u = 1; u <= n; u++) {
        double ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (u == i || u == j || i == j) {
                    continue;
                }
                if (dis[i][u] + dis[u][j] == dis[i][j]) {
                    ans += 1.0 * cnt[i][u] * cnt[u][j] / cnt[i][j];
                }
            }
        }
        cout << fixed << setprecision(3) << ans << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 传递闭包

传递所有点的可达性。

[B3611 【模板】传递闭包](https://www.luogu.com.cn/problem/B3611) 给一个图的邻接矩阵，输出任意两点是否可达。

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 105;

signed main() {
    int n;
    cin >> n;
    vector<bitset<N>> f(n + 1);

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int x;
            cin >> x;
            f[i][j] = x;
        }
    }
    for (int j = 1; j <= n; j++) {
        for (int i = 1; i <= n; i++) {
            if (f[i][j]) {
                f[i] |= f[j];
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << f[i][j] << " \n"[j == n];
        }
    }
    return 0;
}
```



补充例题：[P2419 [USACO08JAN]Cow Contest S](https://www.luogu.com.cn/problem/P2419) $n$ 个元素，给出 $m$ 组两个元素的严格大小关系。判断有多少个数字的排名是确定的。

思路是通过传递闭包，我们可以得到对于每一个元素，有 $x$ 个元素比他大，以及有 $y$ 个元素比他小。若 $x + y = n - 1$ 那么该元素的排名就确定了。



### 全源经过 k 个点的最短路

[P2886 [USACO07NOV]Cow Relays G](https://www.luogu.com.cn/problem/P2886) 无向连通图 $(n \le 200)$，求两点间经过 $k$ 条边的最短路。

假设矩阵 $F_x[i][j]$ 储存从 $i$ 到 $j$ 经过 $x$ 条边的最短路。而原始的邻接矩阵 $g[i][j]$ 即为 $F_1[i][j]$。

那么有 $F_{x + y}[i][j] = \min(F_{x+y}[i][j], F_x[i][k] + F_y[k][j])$。

本题 $k$ 较大，这个过程需要矩阵加速。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e9;
int n = 0, k, m, s, t;

struct matrix {
    int n;
    vector<vector<int>> a;
    matrix(int _n, int val) : n(_n), a(n + 1, vector<int>(n + 1, val)) {
    }
    matrix operator *(const matrix &t) const {
        assert(n == t.n);
        matrix ans(n, INF);
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                for (int k = 1; k <= n; k++) {
                    ans.a[i][j] = min(ans.a[i][j], a[i][k] + t.a[k][j]);
                }
            }
        }
        return ans;
    }
};

matrix qpow(matrix x, int k) {
    matrix res = x;
    k--;
    while (k) {
        if (k & 1) {
            res = res * x;
        }
        x = x * x;
        k /= 2;
    }
    return res;
}

void SolveTest() {
    map<int, int> mp;
    auto get = [&](int x) {
        if (mp[x] == 0) {
            mp[x] = ++n;
        }
        return mp[x];
    };
    cin >> k >> m >> s >> t;
    matrix dis(105, INF);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> w >> u >> v;
        u = get(u), v = get(v);
        dis.a[u][v] = dis.a[v][u] = w;
    }
    s = get(s), t = get(t);
    auto ans = qpow(dis, k);
    cout << ans.a[s][t] << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 最小环

### Floyd 稠密图最小环

[P6175 无向图的最小环问题](https://www.luogu.com.cn/problem/P6175) 给无向图，求最小环。

复杂度 $O(n^3)$

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e18;
int n, m;
vector<vector<int>> g;

void SolveTest() {
    cin >> n >> m;
    g.assign(n + 1, vector<int> (n + 1, INF));
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u][v] = g[v][u] = min(g[u][v], w);
    }
    for (int i = 1; i <= n; i++) {
        g[i][i] = 0;
    }
    auto dis = g;
    int ans = INF;
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i < k; i++) {
            for (int j = 1; j < i; j++) {
                ans = min(ans, dis[i][j] + g[i][k] + g[k][j]);
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
            }
        }
    }
    if (ans == INF) {
        cout << "No solution." << endl;
    } else {
        cout << ans << endl;
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### Dijkstra 稀疏图最小环

[P6175 无向图的最小环问题](https://www.luogu.com.cn/problem/P6175) 给无向图，求最小环。

每次删掉一条边 $e(u,v)$，求在删掉这条边的图上从u到v的最短路距离

复杂度 $O(m(m+n)\log n)$

**本做法只是理论做法，洛谷模板题最后两个点会 T 掉，但思路值得借鉴**。（$1\le n\le 100$，$1\le m\le 5000$）

```cpp
#include <bits/stdc++.h>
using namespace std;
// #define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int N = 2e5 + 7, INF = 1e9;
int n, m;
vector<vector<PII>> g; 

int ans;

int dijkstra(int s, int t) {
    vector<int> dis(n + 1, INF);
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    dis[s] = 0;
    heap.push({0, s});
    while (!heap.empty()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dis[u]) {
            continue;
        }
        if (u == t) {
            break;
        }
        for (auto [v, w] : g[u]) {
            if (u == s && v == t) {
                continue;
            }
            if (dis[u] + w < dis[v]) {
                dis[v] = dis[u] + w;
                heap.push({dis[v], v});
            }
        }
    }
    return dis[t];
}

void SolveTest() {
    cin >> n >> m;
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    ans = INF;
    for (int u = 1; u <= n; u++) {
        for (auto [v, w] : g[u]) {
            ans = min(ans, w + dijkstra(u, v));
        }
    }
    if (ans == INF) {
        cout << "No solution." << endl;
    } else {
        cout << ans << endl;
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 差分约束

### 	SPFA 差分约束

核心是利用松弛操作：

1. $x_a - x_b \le c$：连边 `add(b, a, c)`
2. $x_a - x_b \ge c$：连边 `add(a, b, -c)`
3. $x_a = x_b$：连边 `add(a, b, 0), add(b, a, 0);`

[P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960) 模板题。给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：
$$
\begin{cases} x_{c_1}-x_{c'_1}\leq y_1 \\x_{c_2}-x_{c'_2} \leq y_2 \\ \cdots\\ x_{c_m} - x_{c'_m}\leq y_m\end{cases}
$$
的不等式组，求任意一组满足这个不等式组的解。如果有多组解输出任意一组，无解输出 `NO`。

【代码】

建立一个超级源点 $s$，从超级源点向每个节点连一条边权为 $0$ 的边。从超级源点跑最短路，最后每个点的距离就是所求的未知量的一个解。**如果有负环，说明该不等式组无解。**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e18;
int n, m, S;
vector<vector<PII>> g;

bool spfa(int s, vector<int> &dis) {
    vector<int> inq(n + 1), cnt(n + 1);
    queue<int> q;
    dis.assign(n + 1, INF);
    dis[s] = 0;
    q.push(s);
    inq[s] = 1;
    while (q.size()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
                if (cnt[v] > n + 1) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

void SolveTest() {
    cin >> n >> m;
    S = ++n;
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[v].push_back({u, w});
    }
    for (int i = 1; i <= n; i++) {
        g[S].push_back({i, 0});
    }
    vector<int> dis(n + 1, INF);
    if (spfa(S, dis)) {
        cout << "NO" << endl;
        return;
    }
    --n;
    for (int i = 1; i <= n; i++) {
        cout << dis[i] << " \n"[i == n];
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 最小生成树

[P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

### Prim 最小生成树

比较适合稠密图，复杂度 $O(n^2 +m)$

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int INF = 1e15;
int n, m;
vector<vector<PII>> g;

int prim() {
    vector<int> dis(n + 1, INF), vis(n + 1);
    dis[1] = 0;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int u = -1;
        for (int j = 1; j <= n; j++) {
            if (!vis[j] && (u == -1 || dis[u] > dis[j])) {
                u = j;
            }
        }
        if (u == -1 || dis[u] == 1e15) {
            return -1ll;
        }
        ans += dis[u];
        vis[u] = 1;
        for (auto [v, w] : g[u]) {
            dis[v] = min(dis[v], w);
        }
    }
    return ans;
}

void SolveTest() {
    cin >> n >> m;
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }

    int ans = prim();
    if (ans == -1) {
        cout << "orz" << endl;
    } else {
        cout << ans << endl;
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### Kruscal 最小生成树

适用于稀疏图，复杂度 $O(m\log m)$。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
struct DSU {
    int n;
    vector<int> fa, siz;
    DSU(int _n) : n(_n), fa(n + 1), siz(n + 1, 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    void merge(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) {
            fa[x] = y;
            siz[y] += siz[x];
        }
    }
    int size(int x) {
        return siz[find(x)];
    }
};

int n, m;
vector<tuple<int, int, int>> edge;

int kruscal() {
    sort(edge.begin() + 1, edge.end(), [](auto x, auto y) {
        return get<2>(x) < get<2>(y);
    });

    int ans = 0;
    DSU dsu(n + 1);
    for (int i = 1; i <= m; i++) {
        auto [u, v, w] = edge[i];
        if (dsu.same(u, v)) {
            continue;
        }
        ans += w;
        dsu.merge(u, v);
    }
    if (dsu.size(1) < n) {
        return -1;
    }
    return ans;
}


void SolveTest() {
    cin >> n >> m;
    edge.assign(m + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edge[i] = {u, v, w};
    }
    int ans = kruscal();
    if (ans == -1) {
        cout << "orz\n";
    } else {
        cout << ans << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```





### Watering Hole 模型

自己乱起的名字，源自于这一道题 [P1550 [USACO08OCT]Watering Hole G](https://www.luogu.com.cn/problem/P1550) 。题意是 $n$ 个点，将一个点设为水井的花费是 $W_i$ ，将两个点相连的花费是 $g[i][j]$。现在需要保证任何一个点都能通过若干条路径到达一个水井，求最小花费。

做法是新建一个超级源点，想象为水源。从这个超级源点向所有点连一条边，边权为在该点打通水井的花费。然后跑最小生成树。

更典型的是这一道题 [1245D. Shichikuji and Power Grid](https://codeforces.com/contest/1245/problem/D) 。题意类似，但是需要输出挑选了哪些点和哪些边构成最后的图。只需要在Prim 的时候记录每条个点是最后是被哪一个点松弛的。

```cpp
int ans = 0;
vector<int> dis(n + 1, INF), vis(n + 1), from(n + 1);
dis[n] = 0;

vector<int> ans1;
vector<PII> ans2;
for (int i = 1; i <= n; i++) {
    int u = -1;
    for (int j = 1; j <= n; j++) {
        if (!vis[j] && (u == -1 || dis[u] > dis[j])) {
            u = j;
        }
    }
    if (u != n) { // 本题中 n 是超级源点
        if (from[u] == n) { // 这个点是单独挑选出来的
            ans1.push_back(u);
        } else { // 记录图中的边
            ans2.push_back({from[u], u});
        }
    }
    ans += dis[u];
    vis[u] = 1;
    for (int j = 1; j <= n; j++) {
        if (g[u][j] < dis[j]) {
            dis[j] = g[u][j];
            from[j] = u;
        }
    }
}
```



### 瓶颈生成树与最小瓶颈路

【概念】：瓶颈生成树

无向图 $G$ 的瓶颈生成树满足：它的**最大边的权值在 $G$ 的所有生成树当中最小。**

- 最小生成树 是 瓶颈生成树 的充分不必要条件。

【概念】：最小瓶颈路

无向图 $G$ 中从 $x$ 到 $y$ 的最小瓶颈路满足：这条路径上最大的边权在从 $x$ 到 $y$ 中的所有路径中是最小的。

- 无向图 $G$ 中**从 $x$ 到 $y$ 的最小瓶颈路上的最大边权 $=$ $G$的最小生树上从 $x$ 到 $y$ 的路径的最大边权**


类似的，以 [P1967 [NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967) 为例，题目要求**任意两点间路径最小边权的最大值**。那么就求最大生成树，用树上倍增求树上两点间路径边权最小值。



### 次小生成树与严格次小生成树

次小生成树：枚举每一条不在最小生成树当中的边 $(u,v,w)$。查找最小生成树当中路径 $(u,v)$ 当中**最大边权 $t$**。用 $w$ 替换 $t$ 更新答案。可以用树上倍增求路径最大边权。

严格次小生成树：枚举每一条不在最小生成树当中的边 $(u,v,w)$。查找最小生成树当中路径 $(u,v)$ 当中**严格次大边权 $t$**。用 $w$ 替换 $t$ 更新答案。

树上路径的严格次大边权也可以用树上倍增解决。

[P4180 [BJWC2010] 严格次小生成树](https://www.luogu.com.cn/problem/P4180)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int M = 25, INF = 1e18;
int n, m;

struct DSU {
    int n;
    vector<int> fa, siz;
    DSU(int _n) : n(_n), fa(n + 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return;
        }
        fa[x] = y;
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
};


struct Tree {
    int n;
    vector<vector<PII>> g;
    vector<int> dep, val;
    vector<array<int, M>> fa, max1, max2;
    Tree(int _n) :
        n(_n), g(n + 1), dep(n + 1), val(n + 1),
        fa(n + 1), max1(n + 1), max2(n + 1) {
    }

    void add(int u, int v, int w) {
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }

    void dfs1(int u, int pa) {
        dep[u] = dep[pa] + 1;
        fa[u][0] = pa;
        max1[u][0] = val[u];
        max2[u][0] = -INF;
        for (int i = 1; i < M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            int tmp[4] = {max1[u][i - 1], max1[fa[u][i - 1]][i - 1],
                          max2[u][i - 1], max2[fa[u][i - 1]][i - 1]};
            sort(tmp, tmp + 4);
            max1[u][i] = tmp[3];
            int p = 2;
            while (p >= 0 && tmp[p] == tmp[3]) {
                p--;
            }
            max2[u][i] = (p == -1 ? INF : tmp[p]);
        }

        for (auto [v, w] : g[u]) {
            if (v == pa) {
                continue;
            }
            val[v] = w;
            dfs1(v, u);
        }
    }

    // 查询 (u, v) 路径上严格小于 value 的最大边权
    int query(int u, int v, int value) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }

        auto get = [&](int x, int i)->int {
            return (max1[x][i] == value) ? max2[x][i] : max1[x][i];
        };

        int ans = -INF;
        int t = dep[u] - dep[v];
        for (int i = 0; i < M; i++) {
            if (t & (1 << i)) {
                ans = max(ans, get(u, i));
                u = fa[u][i];
            }
        }
        if (u == v) {
            return ans;
        }
        for (int i = M - 1; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                ans = max({ans, get(u, i), get(v, i)});
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        ans = max({ans, max1[u][0], max1[v][0]});
        return ans;
    }
};

void SolveTest() {
    cin >> n >> m;
    vector<tuple<int, int, int>> edge(m);
    vector<int> used(m);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edge[i - 1] = {u, v, w};
    }

    sort(edge.begin(), edge.end(), [&](auto x, auto y) {
        return get<2>(x) < get<2>(y);
    });

    DSU dsu(n);
    Tree tr(n);

    int ans = 0;
    for (int i = 0; i < m; i++) {
        auto [u, v, w] = edge[i];
        if (dsu.same(u, v)) {
            continue;
        }
        ans += w;
        dsu.merge(u, v);
        used[i] = 1;
        tr.add(u, v, w);
    }

    tr.dfs1(1, 0);
    int res = INF;

    for (int i = 0; i < m; i++) {
        if (used[i]) {
            continue;
        }
        auto [u, v, w] = edge[i];
        int tmp = tr.query(u, v, w); // 查询路径 (u, v) 上严格小于 w 的最大边权
        if (tmp != -INF) {
            res = min(res, ans + w - tmp);
        }
    }
    cout << res << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### Kruscal重构树

性质：原图上 $(u, v)$ 的瓶颈路最大边 $=$ Kruscal 重构树 $LCA(u, v)$ 的点权

[#137. 最小瓶颈路（加强版）](https://loj.ac/p/137) kruscal 重构树模板题。给定 $n$ 个点 $m$ 条边的无向连通图，可能有重边，有正边权 。$m$ 次询问，求从 $u$ 到 $v$ 的路径上边权的最大值最小。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
struct DSU {
    int n;
    vector<int> fa;
    DSU(int _n) : n(_n), fa(n + 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            fa[x] = y;
        }
    }
};

struct ST {
    int n;
    vector<int> Logn;
    vector<array<int, 25>> f;
    void init(vector<int> &a) { //将 a 构建ST表
        n = a.size() - 1;
        Logn.assign(n * 2 + 1, 0);
        Logn[1] = 0, Logn[2] = 1;
        for (int i = 3; i <= 2 * n; i++) {
            Logn[i] = Logn[i / 2] + 1;
        }

        f.assign(n + 1, {});
        for (int i = 1; i <= n; i++) {
            f[i][0] = a[i];
        }
        for (int j = 1; j <= Logn[n]; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                f[i][j] = min (f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int querymin (int x, int y) {
        if (x > y) {
            swap (x, y);
        }
        int s = Logn[y - x + 1];
        return min(f[x][s], f[y - (1 << s) + 1][s]);
    }
};

struct Tree {
    int n, dfncnt = 0;
    vector<int> val, Eu, pos, dep;
    vector<vector<int>> g;
    ST st;
    Tree (int _n): n(_n), val(n + 1), Eu(n * 2 + 1), pos(n * 2 + 1), dep(n * 2 + 1), g(n + 1) {}
    void add(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    void pre() {
        dfs1(n, 0, 1);
        vector<int> tmp = pos;
        for (int i = 1; i <= dfncnt; i++) {
            tmp[i] = pos[Eu[i]];
        }
        st.init(tmp);
    }
    void dfs1(int u, int pa, int depth) {
        Eu[++dfncnt] = u;
        pos[u] = dfncnt;
        dep[dfncnt] = depth; // 将 dfn 映射为深度
        for (int v : g[u]) {
            if (v == pa) {
                continue;
            }
            dfs1(v, u, depth + 1);
            Eu[++dfncnt] = u;
            dep[dfncnt] = depth;
        }
    }
    int lca(int u, int v) {
        return Eu[st.querymin(pos[u], pos[v])];
    }
};

void SolveTest() {
	int n, m;
    cin >> n >> m;
    vector<tuple<int, int, int>> edge(m);
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edge[i] = {u, v, w};
    }
    sort(edge.begin(), edge.end(), [&](auto x, auto y) {
        return get<2>(x) < get<2>(y);
    });

    // 下面是 kruscal 重构树的建树过程
    DSU dsu(4 * n); // 并查集一定要开大，因为需要 n 只是一棵二叉树的叶子个数
    Tree tr(4 * n);
    tr.n = n;
    for (int i = 0; i < m; i++) {
        auto [u, v, w] = edge[i];
        u = dsu.find(u);
        v = dsu.find(v);
        if (u == v) {
            continue;
        }
        int tmp = ++tr.n;
        tr.val[tmp] = w;
        tr.add(u, tmp);
        tr.add(v, tmp);

        dsu.merge(u, tmp); // 这里合并的方向一定不能反，否则是错的
        dsu.merge(v, tmp);
    }

    tr.pre(); // 预处理

    int q, A, B, C, P, res = 0, MOD = 1e9 + 7;
    cin >> q >> A >> B >> C >> P;

    while (q--) {
        auto rnd = [&]() {
            return A = (A * B + C) % P;
        };
        int u = rnd() % n + 1, v = rnd() % n + 1;
        if (u == v) {
            continue;
        }
        int ans = tr.val[tr.lca(u, v)];
        res = (res + ans) % MOD;
    }
    cout << res << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```









## 拓扑排序 / DAG判定

能拓扑排序 $\iff$ 图是 DAG

### Kahn 算法

复杂度 $O(n + m)$

```c++
vector<int> topo;

bool toposort() {
    vector<int> tmp = ind; // ind 是节点的入度
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (tmp[i] == 0) {
            q.push(i);
        }
    }
    while (q.size()) {
        int u = q.front();
        topo.push_back(u);
        q.pop();
        for (int v : g[u]) {
            if (--tmp[v] == 0) {
                q.push(v);
            }
        }
    }
    return topo.size() == n;
};
```

如果需要求字典序最大/最小的拓扑排序，则把队列换为堆。



## 连通性

概念：

有向图
- 强连通：内部的任意点**互相**可达。
- 弱连通：将该图中所有边替换为无向边，将得到一张连通图

无向图
- 割点：如果删除一个点，图中连通块数量增加，则该点为割点。
- 点双连通：没有割点的连通图。
- 桥：对于某条边，如果删除它后图中连通块数量增加，则该边为桥。
- 边双连通：没有桥的连通图。对于一个边双连通分量，任意两点间至少有两条没有公共边的路径。

注意：任何一个桥的两边都不一定是割点，任何一个割点相邻的边也不一定是桥。二者没有任何本质关系。

### 强连通分量 + 缩点技巧

这是一种模型，常见的套路是：tarjan 强连通分量 + 缩点 + 拓扑排序 + DP 

[P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

给有向图，求一条路径，使得经过点权和最大。每个点可重复经过，但是只计算一次权值。输出该最大值。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1);
    vector<vector<int>> g(n + 1);

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
    }

    // 以下使用 tarjan 算法求强连通分量
    vector<int> dfn(n + 1), low(n + 1), instk(n + 1), id(n + 1);
    int dfncnt = 0, scc = 0;
    stack<int> stk;
    function<void(int)> dfs = [&](int u) {
        dfn[u] = low[u] = ++dfncnt;
        stk.push(u);
        instk[u] = 1;
        for (int v : g[u]) {
            if (!dfn[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            } else if (instk[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            ++scc;
            while (1) {
                int v = stk.top();
                stk.pop();
                instk[v] = 0;
                id[v] = scc;
                if (v == u) {
                    break;
                }
            }
        }
    };
    for (int i = 1; i <= n; i++) {
        if (id[i] == 0) {
            dfs(i);
        }
    }

    // 下面进行缩点
    vector<int> vis(n + 1), sum(scc + 1), ind(scc + 1);
    vector<unordered_set<int>> g2(scc + 1);
    function<void(int)> dfs2 = [&](int u) {
        vis[u] = 1;
        sum[id[u]] += a[u];
        for (int v : g[u]) {
            if (id[u] != id[v] && g2[id[u]].find(id[v]) == g2[id[u]].end()) {
                g2[id[u]].insert(id[v]);
                ind[id[v]]++;
            }
            if (!vis[v]) {
                dfs2(v);
            }
        }
    };
    for (int i = 1; i <= n; i++) {
        if (vis[i] == 0) {
            dfs2(i);
        }
    }

    // 下面进行本题的拓扑排序 + dp
    vector<int> dp(scc + 1, 0);
    queue<int> q;
    for (int i = 1; i <= scc; i++) {
        if (ind[i] == 0) {
            q.push(i);
            dp[i] = sum[i];
        }
    }
    while (q.size()) {
        int u = q.front();
        q.pop();
        for (int v : g2[u]) {
            dp[v] = max(dp[v], dp[u] + sum[v]);
            if (--ind[v] == 0) {
                q.push(v);
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= scc; i++) {
        ans = max(ans, dp[i]);
    }
    cout << ans << endl;
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```

典型题目

- [P2835 刻录光盘](https://www.luogu.com.cn/problem/P2835)
- [P1073 [NOIP2009 提高组] 最优贸易](https://www.luogu.com.cn/problem/P1073) 是该思想的典型例题。



### 点双连通分量 + 求割点

对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。

[P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)给无向图，求割点个数，并输出所有割点。

结论：割点的两种情形

- 是 dfs树的根节点，并且有至少两个子树
- 不是 dfs 树的根节点，能回溯到的最小 `dfn` 值大于它自身的 `dfn` 值

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    vector<int> dfn(n + 1), low(n + 1), cnt(n + 1);
    vector<bool> cutpoint(n + 1);
    int dfncnt = 0;
    function<void(int, int)> dfs = [&](int u, int root) {
        dfn[u] = low[u] = ++dfncnt;
        int child = 0;
        for (int v : g[u]) {
            if (!dfn[v]) {
                dfs(v, root);
                low[u] = min(low[u], low[v]);
                if (u == root) {
                    child++;
                } else if (low[v] >= dfn[u]) {
                    cutpoint[u] = 1;
                }
            } else {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (u == root && child >= 2) {
            cutpoint[u] = 1;
        }
    };

    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            dfs(i, i);
        }
    }
    vector<int> ans;
    for (int i = 1; i <= n; i++) {
        if (cutpoint[i]) {
            ans.push_back(i);
        }
    }
    cout << ans.size() << endl;
    for (int x : ans) {
        cout << x << " ";
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 圆方树



### 边双连通分量 + 求桥 + 缩点

求边双连通分量和求强连通分量基本一样。保证每条边（包括反向边）都只走一遍。

特别的，一个无向图进行边双连通分量缩点之后，是一个无向无环图——就是一棵树，称为**桥树**。

[P2860 [USACO06JAN]Redundant Paths G](https://www.luogu.com.cn/problem/P2860)

题意是给定一个无向连通图（$n\le 5000$），至少添加几条边可以满足图中任意两点之间都至少有两条没有公共边的路径。

做法是求边双连通分量并缩点，找缩点之后度数为 $1$ 的点个数除以 $2$。


```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
struct Edge {
    int to, id; // 这里必须要存边的编号
};
int idx = 1; // 必须从 1 开始，这样才能找到反向边

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<Edge>> g(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back({v, ++idx});
        g[v].push_back({u, ++idx});
    }
    vector<int> dfn(n + 1), low(n + 1), id(n + 1), instk(n + 1);
    int dfncnt = 0, dcc = 0;
    stack<int> stk;
    vector<int> isbridge(idx + 2), vis(idx + 2);

    function<void(int)> dfs = [&](int u) {
        dfn[u] = low[u] = ++dfncnt;
        stk.push(u);
        instk[u] = 1;
        for (auto [v, i] : g[u]) {
            if (vis[i]) {
                continue;
            }
            vis[i] = vis[i ^ 1] = 1;
            if (!dfn[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
                if (dfn[u] < low[v]) {
                    isbridge[idx] = isbridge[idx ^ 1] = 1;
                }
            } else if (instk[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            ++dcc;
            while (1) {
                int x = stk.top();
                id[x] = dcc;
                stk.pop();
                instk[x] = 0;
                if (x == u) {
                    break;
                }
            }
        }
    };

    dfs(1); // 本题保证了连通

    vector<int> deg(dcc + 1);
    function<void(int)> dfs2 = [&](int u) {
        for (auto [v, i] : g[u]) {
            if (vis[i] == 1) {
                continue;
            }
            vis[i] = vis[i ^ 1] = 1;
            if (id[u] != id[v]) {
                deg[id[u]]++;
                deg[id[v]]++;
            }
            dfs2(v);
        }
    };

    vis.assign(idx + 1, 0);
    dfs2(1); // 本题保证了连通

    int ans = count_if(deg.begin(), deg.end(), [](int x) {
        return x == 1;
    });
    cout << (ans + 1) / 2;
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 2-SAT

[P4782 【模板】2-SAT 问题](https://www.luogu.com.cn/problem/P4782) 

对于 $n$ 个布尔变量，给出 $m$ 组约束。

每一组约束的形式是 “$x= v_x \or y=v_y$”。 其中 $v$ 的取值是 $0/1$。试将每一个变量赋值，满足所有约束。

另一种常见的表述是 $x\  \& \ y=flase$。这其实等价于 $x=0 \or y=0$。

$Solution:$

将每个点拆开，点 $x$ 表示 $x=1$ ，点 $x+n$ 表示 $x=0$。

对于一组约束，假设 $x=1 \or y=1$ ，连两条边边 $(x+n,y)$，$(x,y+n)$。意思是如果 $x=0$ 则 $y=1$，如果 $y=0$ 则 $x=1$。类似地可以得出其他情形的连边方法。

这里可以通过位运算简化代码，将四种情况一起建图：

```cpp
for (int i = 1; i <= m; i++) {
    int x, vx, y, vy;
    cin >> x >> vx >> y >> vy;
    g[x + n * (vx & 1)].push_back(y + n * (vy ^ 1));
    g[y + n * (vy & 1)].push_back(x + n * (vx ^ 1));
}
```

如果某个变量 $x$ 必须为 $1$，那么就连边 $(x+n,x)$。连边的含义是推导的过程，如果从 $x=1$ 推导出 $x=0$，那么说明 $x$ 只能为 $0$。而如果从 $x$ 走到 $x+n$，又从 $x+n$ 走到 $x$，那么就会造成矛盾。

所以我们进行 Tarjan 缩点。同一个强连通分量里面的变量一定相等。所以对于某个变量 $x$ ，如果点 $x$ 和 $x+n$ 在同一个强连通分量内，那么这个图就是无解的。反之一定有解。因为在 tarjan 缩点的时候，**$id$ 序列已经是所点之后的图的拓扑序的逆序**，所以如果 $id[x] < id[x + n]$ 则让该变量为 $1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n * 2 + 1);
    for (int i = 1; i <= m; i++) {
        int x, vx, y, vy;
        cin >> x >> vx >> y >> vy;
        g[x + n * (vx & 1)].push_back(y + n * (vy ^ 1));
        g[y + n * (vy & 1)].push_back(x + n * (vx ^ 1));
    }

    int dfncnt = 0, scc = 0;
    vector<int> dfn(n * 2 + 1), low(n * 2 + 1), instk(n * 2 + 1), id(n * 2 + 1);
    stack<int> stk;

    function<void(int)> dfs = [&](int u) {
        dfn[u] = low[u] = ++dfncnt;
        stk.push(u);
        instk[u] = 1;
        for (int v : g[u]) {
            if (!dfn[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            } else if (instk[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (low[u] == dfn[u]) {
            ++scc;
            while (1) {
                int v = stk.top();
                stk.pop();
                instk[v] = 0;
                id[v] = scc;
                if (v == u) {
                    break;
                }
            }
        }
    };

    for (int i = 1; i <= n * 2; i++) {
        if (!dfn[i]) {
            dfs(i);
        }
    }

    for (int i = 1; i <= n; i++) {
        if (id[i] == id[i + n]) {
            cout << "IMPOSSIBLE" << endl;
            return;
        }
    }
    cout << "POSSIBLE" << endl;
    for (int i = 1; i <= n; i++) {
        cout << (id[i] < id[i + n]) << " ";
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 欧拉路径和欧拉回路

### 有向图欧拉路径

有向图存在**欧拉路径**的充要条件（二选一）：

- 所有点的出度 $=$ 出度；
- 只有两个点的入度 $\ne$ 出度：一个满足出度比入度多 $1$（起点），另一个满足入度比出度多 $1$（终点）。

存在**欧拉回路**的充要条件

- 所有点的出度等于入度。

[P7771 【模板】欧拉路径](https://www.luogu.com.cn/problem/P7771) 给有向图，求字典序最小的欧拉路径。

需要理解为什么要后序填入答案并倒序输出。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define endl "\n"
/**********************  Core code begins  **********************/

void SolveTest() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> g(n + 1);
    vector<int> ind(n + 1), oud(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        ind[v]++;
        oud[u]++;
    }

    // 由于本题需要求字典序最小的欧拉路径，所以先排序
    for (int i = 1; i <= n; i++) {
        sort(g[i].begin(), g[i].end());
    }

    // 进行判定
    bool flg = 1;           // flg == 1 表示所有节点的入度都等于出度
    int S = 1;              // S 记录欧拉路径的起点
    int tmp[2] = {0, 0};    // tmp[0] 记录出度比入度多 1 的点，cnt[1] 记录入度比出度多 1 的点
    for (int i = 1; i <= n; i++) {
        if (ind[i] == oud[i]) {
            continue;
        }
        flg = 0;
        if (oud[i] - ind[i] == 1) {
            tmp[0]++;
            S = i;
        } else if (ind[i] - oud[i] == 1) {
            tmp[1]++;
        } else {
            cout << "No" << endl;
            return;
        }
    }

    // 搜索欧拉路径并输出
    vector<int> ans, cur(n + 1);
    function<void(int)> dfs = [&](int u) {
        for (int i = cur[u]; i < g[u].size(); i = cur[u]) {
            cur[u]++;
            dfs(g[u][i]);
        }
        ans.push_back(u);
    };
    dfs(S);
    reverse(ans.begin(), ans.end());
    for (int x : ans) {
        cout << x << " ";
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T = 1;
    // cin >> T;
    for (int i = 1; i <= T; i++) {
        SolveTest();
    }
    return 0;
}
```



### 无向图欧拉路径

无向图存在**欧拉路径**的充要条件（二选一）：

- 所有点的度数都是偶数；
- 恰好有两个点度数是奇数，其余全是偶数。

存在**欧拉回路**的充要条件：

- 所有点的度数都是偶数。

[P1341 无序字母对](https://www.luogu.com.cn/problem/P1341) 

【题意】

给 $n$ 个字母对（区分大小写，顺序可以颠倒）。需要构造一个长度为 $n+1$ 的字符串，使得每个字母对都在这个字符串中出现，或报告不可能。

【思路】

建无向图，每个点代表一个字符。每给一个字母对就在无向图中连一条边。最后求字典序最小的欧拉回路径，就是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define endl "\n"
/**********************  Core code begins  **********************/

int get(char x) {	// 将字符映射到数字，方便建图
    if (isupper(x)) {
        return x - 'A' + 1;
    } else {
        return 26 + x - 'a' + 1;
    }
};

char f(int x) {		// 将数字映射到字符，以便输出
    if (x <= 26) {
        return 'A' + x - 1;
    } else {
        return 'a' + x - 27;
    }
};

void SolveTest() {
    int n, N = 52;
    cin >> n;

    vector<vector<int>> g(N + 1);	// 存与点相连的边编号，以便找到反向边
    vector<int> e;					// 存边编号对应的边终点
    vector<int> deg(N + 1);			// 无向图度数

    auto addEdge = [&](int u, int v) {
        g[u].push_back(e.size());
        e.push_back(v);
        deg[u]++;
    };

    for (int i = 1; i <= n; i++) {
        string s;
        cin >> s;
        int u = get(s[0]), v = get(s[1]);
        addEdge(u, v);
        addEdge(v, u);
    }

    vector<int> tmp;				// 存度数为奇数的点
    for (int i = 1; i <= N; i++) {
        if (deg[i] % 2 == 1) {
            tmp.push_back(i);
        }
    }
    if (tmp.size() != 0 && tmp.size() != 2) {
        cout << "No Solution" << endl;
        return;
    }

    // 本题需要字典序最小，所以还是将边按照终点从小到大排序
    for (int i = 1; i <= N; i++) {
        sort(g[i].begin(), g[i].end(), [&](int x, int y) {
            return e[x] < e[y];
        });
    }
    
    vector<int> ans, cur(N + 1), vis(e.size() * 2);
    
    function<void(int)> dfs = [&](int u) {
        if (cur[u] >= g[u].size()) {
            return;
        }
        for (int i = cur[u]; i < g[u].size(); i = cur[u]) {
            int id = g[u][i], v = e[id];
            cur[u]++;
            if (vis[id] || vis[id ^ 1]) {
                continue;
            }
            vis[id] = vis[id ^ 1] = 1;
            dfs(v);
        }
        ans.push_back(u);
    };

    if (tmp.size()) {
        dfs(tmp[0]);
    }
    for (int i = 1; i <= N; i++) {
        dfs(i);
    }
    reverse(ans.begin(), ans.end());
    
    for (int x : ans) {
        cout << f(x);
    }
    cout << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T = 1;
    // cin >> T;
    for (int i = 1; i <= T; i++) {
        SolveTest();
    }
    return 0;
}
```



## 最小树形图

相当于最小生成树的有向图版本

### 朱刘算法

```

```



## 斯坦纳树

[P6192 【模板】最小斯坦纳树](https://www.luogu.com.cn/problem/P6192)

【思路】

设 $dp(i,S)$ 表示以 $i$ 为根的一棵树，包含集合 $S$ 中的所有点的最小代价。

1. 若 $i$ 的度数为 $1$，$dp(i,S)=dp(j,S)+w(i,j)$，枚举所有与i相邻的点 $j$

2. 若 $i$ 的度数大于 $1$ ，$dp(i,S)=dp(i,T)+dp(i,S-T)$，类比按升序枚举 $S$

对于1，暴力枚举S的划分。对于2，参照 Dijkstra 的三角不等式，松弛每一个状态。

复杂度 $O(n\times3^{k} + m\log m\times 2^{k})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=510;
int n,m,k,x,y,z,eg,p[MAXN],hd[MAXN],ver[2*MAXN],vis[MAXN],nx[2*MAXN],edge[2*MAXN],dp[MAXN][4200];
priority_queue < pair<int,int> > q;
void add_edge (int x,int y,int z) {
	ver[++eg]=y;
	nx[eg]=hd[x],edge[eg]=z;
	hd[x]=eg;
	return;
}
void dijkstra (int s) {
	memset(vis,0,sizeof(vis));
	while (!q.empty()) {
		pair <int,int> a=q.top();
		q.pop();
		if (vis[a.second]) {continue;}
		vis[a.second]=1;
		for (int i=hd[a.second];i;i=nx[i]) {
			if (dp[ver[i]][s]>dp[a.second][s]+edge[i]) {
				dp[ver[i]][s]=dp[a.second][s]+edge[i];
				q.push(make_pair(-dp[ver[i]][s],ver[i]));
			}
		}
	}
	return;
}
int main () {
	freopen("st010.in","r",stdin);
	freopen("st010.out","w",stdout);
	memset(dp,0x3f,sizeof(dp));
	scanf("%d%d%d",&n,&m,&k);
	for (int i=1;i<=m;i++) {
		scanf("%d%d%d",&x,&y,&z);
		add_edge(x,y,z),add_edge(y,x,z);
	}
	for (int i=1;i<=k;i++) {
		scanf("%d",&p[i]);
		dp[p[i]][1<<(i-1)]=0;
	}
	for (int s=1;s<(1<<k);s++) {
		for (int i=1;i<=n;i++) {
			for (int subs=s&(s-1);subs;subs=s&(subs-1)) {
				dp[i][s]=min(dp[i][s],dp[i][subs]+dp[i][s^subs]);
			}
			if (dp[i][s]!=0x3f3f3f3f) {q.push(make_pair(-dp[i][s],i));}
		}
		dijkstra(s);
	}
	printf("%d\n",dp[p[1]][(1<<k)-1]);
	return 0;
}
```





## 线段树优化建图

