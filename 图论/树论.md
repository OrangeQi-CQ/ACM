# 树论

## 树的重心

**定义**

- 无根树中，子树大小最大值最小的点，称为这棵树的重心。

- 或者说，对于一个无根树，删去该点之后，剩下的连通块大小的最大值最小。


**性质**

- **$u$ 是重心 $\Longleftrightarrow$ $u$ 的所有子树中，最大的子树的size不超过总结点数量的一半。**
- 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。
- 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
- 在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。



```cpp
int wc = 1; // 寻找的重心，即答案
void dfs(int u, int pa) {
	siz[u] = 1;
    for (int v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs(v, u);
        siz[u] += siz[v];
        maxv[u] = max(siz[v], maxv[u]);
    }
	maxv[u] = max(maxv[u], n - siz[u]);
    if (maxv[u] < maxv[root]) {
		root = u;
    }
}
```



## 树的直径和中心

**定义**

- 树上任意两节点之间最长的简单路径即为树的直径

**性质**

- 所有的直径的中点重合

DFS求直径和中心：找到直径的两个端点，并找到中心

```cpp
int p1, p2, center, len; // 分别是两个端点，中心，直径长度；

void dfs(int u, int pa, int &p) {
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == pa) {
            continue;
        }
        dis[v] = dis[u] + 1;
        fa[v] = u;
        dfs(v, u, p);
        if (dis[v] > dis[p]) {
            p = v;
            fa[v] = u;
        }
    }
}

void work() {
    p1 = 0; // 求直径的一个端点
    dis[1] = 0;
    dfs(1, 0, p1);
    p2 = 0; // 求直径的第二个端点
    dis[p1] = 0;
    dfs(p1, 0, p2);
    len = dis[p2];
    center = p2;
    for (int i = 1; i <= len / 2; i++) {
        center = fa[root];
    }
}
```

树形 DP 求直径

```cpp
void dfs(int u, int fa) {
	for (int i = head[u]; i; i = nxt[i]) {
		int v = to[i], w = edge[i];

		if (v == fa) {
			continue;
		}

		dfs(v, u);
        int t = d1[v] + edge[i];

        if (t > d1[u]) {
            d2[u] = d1[u];
            d1[u] = t;
        } else if (t > d2[u]) {
            d2[u] = t;
        }
	}
}
```





## DFN序列

树的先序遍历序列，$dfn[u]$ 表示 $u$ 在 dfs 过程中第几个访问到。

特点：

- 祖先总在子孙前
- 子树总是连续段：以$u$为根的子树为区间 $[dfn[u],dfn[u]+siz[u]-1]$，左右端点分别记为 $L[u],\ R[u]$，表示以 $u$ 为根的子树所在的 $dfn$ 区间。
- 不能直接复原出树的结构，但借助 $siz[u]$ 可以复原

```c++
int dfntot = 0, L[N], R[N], dfn[N];
void dfs(int u, int pa) {
    dfn[++dfntot] = u;
    L[u] = dfntot;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == pa) {
            continue;
        }
        dfs(v, u);
    }
    R[u] = dfntot;
}
```

应用：

- 判断点 $u$ 是否为 $v$ 的直系祖先：只需判断 $dfn_v$ 是否在区间 $[L_u, R_u]$ 中。

-  维护子树信息
  - DFN 序列上连续的区间 $[L_u, R_u]$ 就是 $u$ 的子树。
  - 用树状数组/线段树维护 DFN 序列可以实现子树的修改和查询。



## 树上倍增

###  k 级祖先

需要树上倍增 dfs 预处理

```cpp
void dfs1(int u, int pa) {
    fa[u][0] = pa;
    dep[u] = dep[pa] + 1;
    for (int i = 1; i <= SP; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int &v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs(v, u);
    }
}

int Kth_fa(int x, int k) {
    for (int i = 0; i <= 20; i++) {
        if (k & (1 << i)) {
            x = fa[x][i];
        }
    }
    return x;
}
```



### LCA

需要树上倍增 dfs 预处理

```cpp
void dfs1(int u, int pa) {
    fa[u][0] = pa;
    dep[u] = dep[pa] + 1;
    for (int i = 1; i <= SP; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int &v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    int t = dep[u] - dep[v];
    for (int i = 0; i <= SP; i++) {
        if (t & (1 << i)) {
            u = fa[u][i];
        }
    }
    if (u == v) {
        return u;
    }
    for (int i = 20; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}
```



### 路径最小边权

源自 [P1967 [NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967)。首先将树上边权转换为点权，每个点的点权为与父节点连边的边权。

```cpp
// dfs 预处理
void dfs1(int u, int pa) {
    fa[u][0] = pa;
    minv[u][0] = val[u];
    dep[u] = dep[pa] + 1;
    for (int i = 1; i <= M; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
        minv[u][i] = min(minv[u][i - 1], minv[fa[u][i - 1]][i - 1]);
    }
    for (auto [v, w] : g[u]) {
        if (v == pa) {
            continue;
        }
        root[v] = root[u];
        val[v] = w;
        dfs1(v, u);
    }
}

// 查询 u,v 路径上的边权最小值
int query(int u, int v) {
    int ans = INF;
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    int t = dep[u] - dep[v];
    for (int i = 0; i <= M; i++) {
        if (t & (1 << i)) {
            ans = min(ans, minv[u][i]);
            u = fa[u][i];
        }
    }
    if (u == v) {
        return ans;
    }
    for (int i = M; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            ans = min({ans, minv[u][i], minv[v][i]});
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    ans = min({ans, minv[u][0], minv[v][0]});
    return ans;
}
```



### 路径严格次大边权

源自求严格次小生成树 [P4180 [BJWC2010] 严格次小生成树](https://www.luogu.com.cn/problem/P4180) 。

```cpp
struct Tree {
    int n;
    vector<vector<PII>> g;
    vector<int> dep, val;
    vector<array<int, M>> fa, max1, max2;
    Tree(int _n) :
        n(_n), g(n + 1), dep(n + 1), val(n + 1),
        fa(n + 1), max1(n + 1), max2(n + 1) {
    }

    void add(int u, int v, int w) {
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }

    void dfs1(int u, int pa) {
        dep[u] = dep[pa] + 1;
        fa[u][0] = pa;
        max1[u][0] = val[u];
        max2[u][0] = -INF;
        for (int i = 1; i < M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            int tmp[4] = {max1[u][i - 1], max1[fa[u][i - 1]][i - 1],
                          max2[u][i - 1], max2[fa[u][i - 1]][i - 1]};
            sort(tmp, tmp + 4);
            max1[u][i] = tmp[3];
            int p = 2;
            while (p >= 0 && tmp[p] == tmp[3]) {
                p--;
            }
            max2[u][i] = (p == -1 ? INF : tmp[p]);
        }

        for (auto [v, w] : g[u]) {
            if (v == pa) {
                continue;
            }
            val[v] = w;
            dfs1(v, u);
        }
    }

    // 查询 (u, v) 路径上严格小于 value 的最大边权
    int query(int u, int v, int value) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }

        auto get = [&](int x, int i)->int {
            return (max1[x][i] == value) ? max2[x][i] : max1[x][i];
        };

        int ans = -INF;
        int t = dep[u] - dep[v];
        for (int i = 0; i < M; i++) {
            if (t & (1 << i)) {
                ans = max(ans, get(u, i));
                u = fa[u][i];
            }
        }
        if (u == v) {
            return ans;
        }
        for (int i = M - 1; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                ans = max({ans, get(u, i), get(v, i)});
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        ans = max({ans, max1[u][0], max1[v][0]});
        return ans;
    }
};

```



## LCA 总结

[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

### 树上倍增

$O(n\log n)$ 预处理，$O(n\log n)$ 单次查询。

先进行 dfs 预处理，先序处理点 $u$ 的深度 $d[u]$ 和点 $u$ 的第 $2^i$ 级祖先$f[u][i]$。核心是转移方程 $fa[u][i] = fa[fa[u][i-1]][i-1]$。

然后求 LCA。原理在于公共祖先的二分性：存在某一高度 $i$，使得对于任意 $j\ge i$，$x$ 和 $y$ 的第 $j$级祖先都相同。因此利用二分性进行二进制优化。

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int M = 25;

struct Tree {
    int n, root;
    vector<int> dep;
    vector<array<int, M>> fa;
    vector<vector<int>> g;

    Tree (int _n, int _root): n(_n), root(_root), fa(n + 1), g(n + 1), dep(n + 1) {}
    void add(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    void dfs1(int u, int pa) {
        fa[u][0] = pa;
        dep[u] = dep[pa] + 1;
        for (int i = 1; i < M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
        }
        for (int v : g[u]) {
            if (v == pa) {
                continue;
            }
            dfs1(v, u);
        }
    }
    int lca(int u, int v) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }
        int t = dep[u] - dep[v];
        for (int i = 0; i < M; i++) {
            if (t & (1 << i)) {
                u = fa[u][i];
            }
        }
        for (int i = M - 1; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        return u == v ? u : fa[u][0];
    }
};

void SolveTest() {
    int n, q, root;
    cin >> n >> q >> root;
    Tree tr(n + 1, root);
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        tr.add(u, v);
    }
    tr.dfs1(root, 0);
    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << tr.lca(u, v) << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 离线Tarjan算法

$O(n+q)$预处理，$O(1)$ 查询

过程

1. 以s为根节点，从根节点开始
2. 递归遍历该点u所有子节点v，标记这些子节点v已被访问过，用并查集将v合并到u上，即`fa[v]=u`
3. 寻找与当前点u有询问关系的点p
4. 若是p已经被访问过了，则可以确认u和p的最近公共祖先为v被合并到的父亲节点a

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

struct DSU {
    int n;
    vector<int> fa;
    DSU(int _n) : n(_n), fa(n + 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            fa[x] = y;
        }
    }
};

int n, m, root;
vector<vector<int>> g;
vector<vector<PII>> q;
vector<int> ans, vis;

//Tarjan算法
void dfs(int u, DSU &dsu) {
    vis[u] = 1;
    for (int v : g[u]) {
        if (vis[v]) {
            continue;
        }
        dfs(v, dsu);
        dsu.merge(v, u); // 这个地方的合并方向一定不能反，否则会错
    }
    for (auto [v, id] : q[u]) {
        if (vis[v]) {
            ans[id] = dsu.find(v);
        }
    }
}

void SolveTest() {
    cin >> n >> m >> root;
    DSU dsu(n);
    q.assign(n + 1, {});
    g.assign(n + 1, {});
    ans.assign(m + 1, 0);
    vis.assign(n + 1, 0);

    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        q[u].push_back({v, i});
        q[v].push_back({u, i});
    }

    dfs(root, dsu);

    for (int i = 1; i <= m; i++) { //这里小细节容易出错
        cout << ans[i] << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 欧拉序列+RMQ

$O(n\log n)$ 预处理，$O(1)$ 单次查询

欧拉序列：DFS每次到达一个结点时都将编号记录下来，可以得到一个长度为 $2n-1$的序列，即为欧拉序列$Eu[1...2n-1]$

记 $pos[u]$ 为点$u$在欧拉序列中第一次出现的位置。

基于以下性质：

- 由于 $LCA(u,v)$ 在 DFS 访问的过程中一定是早于其子树上所有点的，因此对于 $LCA(x,y)$ 子树上任意点 $k$，$pos[LCA(x,y)]$ 一定小于 $pos[k]$
- DFS首次访问$x,y$的过程中一定会经过 $LCA(x,y)$，且不会经过 $LCA(x,y)$ 的子树以外的任何点

得到 $pos[LCA(u,v)]=min\{pos[k]\ |\  k\in E[pos[u]...pos[v]]\}$

记$t[i]=pos[Eu[i]]$，则$LCA(u,v)=Eu[min\{ t[i]\ |\ pos[u]\le i\le pos[v\}]$转化为区间 RMQ 问题

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int M = 25;

struct ST {
    int n;
    vector<int> Logn;
    vector<array<int, 25>> f;
    void init(vector<int> &a) { //将 a 构建ST表
        n = a.size() - 1;
        Logn.assign(n * 2 + 1, 0);
        Logn[1] = 0, Logn[2] = 1;
        for (int i = 3; i <= 2 * n; i++) {
            Logn[i] = Logn[i / 2] + 1;
        }

        f.assign(n + 1, {});
        for (int i = 1; i <= n; i++) {
            f[i][0] = a[i];
        }
        for (int j = 1; j <= Logn[n]; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                f[i][j] = min (f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int querymin (int x, int y) {
        if (x > y) {
            swap (x, y);
        }
        int s = Logn[y - x + 1];
        return min(f[x][s], f[y - (1 << s) + 1][s]);
    }
};

struct Tree {
    int n, root, dfncnt = 0;
    vector<int> val, Eu, pos, dep;
    vector<vector<int>> g;
    ST st;
    Tree (int _n, int _root): n(_n), root(_root),
        val(n + 1), Eu(n * 2 + 1), pos(n * 2 + 1), dep(n * 2 + 1), g(n + 1) {}
    void add(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }
    void pre() {
        dfs1(root, 0, 1);
        vector<int> tmp = pos;
        for (int i = 1; i <= dfncnt; i++) {
            tmp[i] = pos[Eu[i]];
        }
        st.init(tmp);
    }
    void dfs1(int u, int pa, int depth) {
        Eu[++dfncnt] = u;
        pos[u] = dfncnt;
        dep[dfncnt] = depth; // 将 dfn 映射为深度
        for (int v : g[u]) {
            if (v == pa) {
                continue;
            }
            dfs1(v, u, depth + 1);
            Eu[++dfncnt] = u;
            dep[dfncnt] = depth;
        }
    }
    int lca(int u, int v) {
        return Eu[st.querymin(pos[u], pos[v])];
    }
};

void SolveTest() {
    int n, q, root;
    cin >> n >> q >> root;
    Tree tr(n + 1, root);
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        tr.add(u, v);
    }
    tr.pre();
    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << tr.lca(u, v) << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 树上前缀

### 树上距离 （边前缀和）

$sum[u]$ 表示从根节点到 $u$ 的路径上的边权和，可通过一次 DFS 预处理。

$dis(u,v)$ 表示树上两点距离（路径边权和）。

那么有：
$$
dis(u, v) = sum(u) + sum(v) - 2\times sum(LCA(u, v))
$$
[#10134. Dis](https://loj.ac/p/10134) 给出一有边权的树棵树，多次询问两点之间最短距离。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int N = 2e5 + 7, M = 25;
int n, q;

vector<vector<PII>> g(N);
vector<int> dep(N), sum(N);
vector<array<int, M>> fa(N);

void dfs1(int u, int pa) {
    dep[u] = dep[pa] + 1;
    fa[u][0] = pa;
    for (int i = 1; i < M; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (auto [v, w] : g[u]) {
        if (v == pa) {
            continue;
        }
        sum[v] = sum[u] + w;
        dfs1(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    int t = dep[u] - dep[v];
    for (int i = 0; i < M; i++) {
        if (t & (1 << i)) {
            u = fa[u][i];
        }
    }
    if (u == v) {
        return u;
    }
    for (int i = M - 1; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

void SolveTest() {
    cin >> n >> q;
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }

    dfs1(1, 0);
    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << sum[u] + sum[v] - 2 * sum[lca(u, v)] << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



### 点前缀和

设 $sum[u]$ 表示节点 $u$ 到根节点的点权总和。

$dis(u, v)$ 表示树上两点路径点权和。

那么有：
$$
dis(u,v) = sum[u] + sum[v] - sum[LCA(x,y)] - sum[fa[LCA(x,y)]]
$$
[P4427 [BJOI2018]求和](https://www.luogu.com.cn/problem/P4427) 定义一个点的深度是到根路径上的边数。给一棵树，多次查询两点之间路径上所有点深度的 $k(k\le50)$ 次方之和。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"
int Testnum = 1;
/**********************  Core code begins  **********************/
const int N = 7e5, MOD = 998244353;
int idx = 0, nxt[N], head[N], to[N], dep[N], sum[N][60], fa[N][35];

void addedge(int u, int v) {
    to[++idx] = v;
    nxt[idx] = head[u];
    head[u] = idx;
}

void dfspre(int u, int pa) {
    fa[u][0] = pa;
    for (int i = 1; i <= 30; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == pa) {
            continue;
        }
        dep[v] = dep[u] + 1;
        int tmp = 1;
        for (int i = 1; i <= 50; i++) {
            tmp = tmp * dep[v] % MOD;
            sum[v][i] = (sum[u][i] + tmp) % MOD;
        }
        dfspre(v, u);
    }
}

int LCA(int u, int v) {
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    int t = dep[u] - dep[v];
    for (int i = 0; i <= 30; i++) {
        if (t & (1 << i)) {
            u = fa[u][i];
        }
    }
    for (int i = 30; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return u == v ? u : fa[u][0];
}

int n, m;
void SolveTest() {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
		cin >> u >> v;
        addedge(u, v);
        addedge(v, u);
    }

    dep[1] = 0;
    dfspre(1, 0);

    cin >> m;
    while (m--) {
        int u, v, k;
        cin >> u >> v >> k;
        int ans = (((sum[u][k] + sum[v][k] - sum[LCA(u, v)][k] - sum[fa[LCA(u, v)][0]][k]) % MOD) + MOD) % MOD;
        cout << ans << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```





## 树上差分

树上差分类似区间差分，可以 $O(1)$ 路径加，$O(N)$ 还原。

注意，不同于区间的前缀与差分,树上前缀和树上差分并不是简单的互逆关系。树上前缀是向根节点的方向累加，而差分还原是向叶子节点的方向累加。

### 对点差分

假设树上原点权为 $a$，树上差分点权为 $b$。

1. 差分过程：

$$
b[u] = a[u] - \sum_{v\in son(u)}a[v]
$$
即： **$u$ 的真实点权减去 $u$ 所有儿子的真实点权的和**。

2. 还原过程：

$$
a[u] = \sum_{v\in subtree(u)}b[v]
$$

即：**真实点权等于子树内所有差分点权之和；或者 dfs 后序累加**。

3. 修改过程：

$u \rightarrow v$ 路径上的所有点权加上 $w$，对于差分数组 $b$ 就是：

- `b[u] += w;`
- `b[v] += w;`
- `b[lca(u, v)] -= w;`
- `b[fa[lca(u, v)]] -= w;`

[P3128 [USACO15DEC]Max Flow P](https://www.luogu.com.cn/problem/P3128) 给定一棵树，$k$ 次操作，初始所有点权为 $0$ 。每次操作给出两点 $u,\ v$，将 $u \rightarrow v$ 路径上的点权+1。最后输出所有点权最大值。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int N = 2e5, M = 25;
array<int, N> dep, a, b;
vector<array<int, M>> fa(N);
vector<vector<int>> g(N);

void dfs1(int u, int pa) {
    fa[u][0] = pa;
    dep[u] = dep[pa] + 1;
    for (int i = 1; i < M; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int v : g[u]) {
        if (v != pa) {
            dfs1(v, u);
        }
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    int t = dep[u] - dep[v];
    for (int i = 0; i < M; i++) {
        if (t & (1 << i)) {
            u = fa[u][i];
        }
    }
    for (int i = M - 1; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return u == v ? u : fa[u][0];
}

void dfsGet(int u, int pa) {
    for (int v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfsGet(v, u);
        a[u] += a[v];
    }
}

int n, q;
void SolveTest() {
    cin >> n >> q;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(1, 0);
    while (q--) {
        int u, v;
        cin >> u >> v;
        b[u]++;
        b[v]++;
        b[lca(u, v)]--;
        b[fa[lca(u, v)][0]]--;
    }
    a = b;
    dfsGet(1, 0);
    cout << *max_element(a.begin() + 1, a.begin() + n + 1) << endl;
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```

### 对边差分

我们用每个点记录它到父节点连边的长度，再对这个数组进行差分。剩下的和对点差分没什么区别。

$u,\ v$ 路径上的所有边权加 $w$，对差分数组 $b$ 就是：

- `b[u] += w;`
- `b[v] += w;`
- `b[lca(u, v)] -= w * 2;`



## 重链剖分

思想：把一棵树拆解成若干个连续的数组。且每一个数组都不相交。

$top[]$ 数组：每一条链的链首。

### 维护树上路径

[【模板】轻重链剖分/树链剖分 - 洛谷](https://www.luogu.com.cn/problem/P3384)

【题意】

维护树上信息

- `1 x y z`：将树从 x 到 y 结点最短路径上所有节点的值都加上 z。
- `2 x y`：求树从 x 到 y 结点最短路径上所有节点的值之和。
- `3 x z`：将以 x为根节点的子树内所有节点值都加上 z。
- `4 x` ：求以 x为根节点的子树内所有节点值之和

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int N = 2e5 + 7;
int MOD;

struct Segtr {
#define lp (p * 2)
#define rp (p * 2 + 1)

    array<int, N * 4> sum, tag;

    void pushup(int p) {
        sum[p] = sum[lp] + sum[rp];
    }
    void pushdown(int p, int l, int r) {
        if (tag[p] == 0) {
            return;
        }
        int mid = (l + r) / 2;
        sum[lp] += (mid - l + 1) * tag[p];
        sum[rp] += (r - mid) * tag[p];
        tag[lp] += tag[p];
        tag[rp] += tag[p];
        tag[p] = 0;
    }
    void build(int p, int l, int r, array<int, N> &a) {
        if (l == r) {
            sum[p] = a[l];
            return;
        }
        int mid = (l + r) / 2;
        build(lp, l, mid, a);
        build(rp, mid + 1, r, a);
        pushup(p);
    }
    int query(int p, int l, int r, int x, int y) {
        if (x <= l && r <= y) {
            return sum[p];
        }
        pushdown(p, l, r);
        int ans = 0, mid = (l + r) / 2;
        if (x <= mid) {
            ans += query(lp, l, mid, x, y);
        }
        if (y > mid) {
            ans += query(rp, mid + 1, r, x, y);
        }
        return ans;
    }
    void modify(int p, int l, int r, int x, int y, int k) {
        if (x <= l && r <= y) {
            tag[p] += k;
            sum[p] += (r - l + 1) * k;
            return;
        }
        pushdown(p, l, r);
        int mid = (l + r) / 2;
        if (x <= mid) {
            modify(lp, l, mid, x, y, k);
        }
        if (y > mid) {
            modify(rp, mid + 1, r, x, y, k);
        }
        pushup(p);
    }
};

// Heavy Hath Composition
struct HPC {
    int n, root, dfncnt;
    array<int, N> a, val, fa, dep, siz, wson, top, dfn;
    vector<vector<int>> g;
    Segtr seg;

    HPC(int _n, int _root) : n(_n), root(_root), g(n + 1) {}

    void dfs1(int u, int pa) {
        dep[u] = dep[pa] + 1;
        fa[u] = pa;
        siz[u] = 1;
        for (int v : g[u]) {
            if (v == pa) {
                continue;
            }
            dfs1(v, u);
            siz[u] += siz[v];
            if (!wson[u] || siz[v] > siz[wson[u]]) {
                wson[u] = v;
            }
        }
    }

    void dfs2(int u, int topf) {
        dfn[u] = ++dfncnt;
        val[dfncnt] = a[u];
        top[u] = topf;
        if (!wson[u]) {
            return;
        }
        dfs2(wson[u], topf);
        for (int v : g[u]) {
            if (dfn[v] || v == wson[u]) {
                continue;
            }
            dfs2(v, v);
        }
    }

    void prework() {
        dfs1(root, 0);
        dfs2(root, root);
        seg.build(1, 1, n, val);
    }

    // 树链查询
    int query1(int x, int y) {
        int res = 0;
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) {
                swap(x, y);
            }
            res += seg.query(1, 1, n, dfn[top[x]], dfn[x]);
            res %= MOD;
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) {
            swap(x, y);
        }
        res += seg.query(1, 1, n, dfn[x], dfn[y]);
        return res % MOD;
    }

    // 树链修改
    void modify1(int x, int y, int k) {
        k %= MOD;
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) {
                swap(x, y);
            }
            seg.modify(1, 1, n, dfn[top[x]], dfn[x], k);
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) {
            swap(x, y);
        }
        seg.modify(1, 1, n, dfn[x], dfn[y], k);
    }

    // 子树查询
    int query2(int x) {
        return seg.query(1, 1, n, dfn[x], dfn[x] + siz[x] - 1) % MOD;
    }

    // 子树修改
    void modify2(int x, int k) {
        seg.modify(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k);
    }
};

void SolveTest() {
    int n, q, root;
    cin >> n >> q >> root >> MOD;
    HPC tr(n, root);

    for (int i = 1; i <= n; i++) {
        cin >> tr.a[i];
    }

    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        tr.g[u].push_back(v);
        tr.g[v].push_back(u);
    }

    tr.prework();

    for (int i = 1; i <= q; i++) {
        int op, u, v, k;
        cin >> op >> u;
        if (op == 1) {
            cin >> v >> k;
            tr.modify1(u, v, k);
        } else if (op == 2) {
            cin >> v;
            cout << tr.query1(u, v) << endl;
        } else if (op == 3) {
            cin >> k;
            tr.modify2(u, k);
        } else if (op == 4) {
            cout << tr.query2(u) << endl;
        }
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## 树上启发式合并

【特点】

- 离线
- 静态（没有修改）
- 只针对子树

做到 $O(nlogn)$ 预处理，均摊 $O(1)$ 查询。

例题：[CF 600E - Lomsat gelral](https://codeforces.com/problemset/problem/600/E) 给一个以 $1$ 为根大小为 $n$ 的树，每个节点都有颜色 $c_i(c_i\le n)$。对于以某个完全子树，称其中出现次数最多的颜色“占领”该子树，一个子树可以被多个颜色占领。求对于每一个节点，占领以该节点的完全子树的所有颜色之和。

### 桶式写法

一般思路如下：

1. 先遍历请儿子，计算答案，不保留它对桶的影响。
2. 遍历重儿子，保留它对桶的影响。
3. 再次遍历轻儿子，将其贡献假如当前点的答案。

```cpp
const int N = 2e5 + 6;
int n, m, c[N];
int siz[N], wson[N];
int dfncnt = 0, dfn[N], l[N], r[N], pos[N];
vector<int> g[N];

// cnt 是每种颜色的数量，sum 记录每种数量的颜色编号和，top 数量的最大值，ans是每个点的答案
int cnt[N], sum[N], top = 0, ans[N];

// 第一次 dfs：重链剖分，预处理 dfn序列
void dfs1(int u, int pa) {
    dfn[u] = ++dfncnt;
    pos[dfn[u]] = u;
    l[u] = dfncnt;
    siz[u] = 1;
    int maxv = -1;
    for (int v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > maxv) {
            maxv = siz[v];
            wson[u] = v;
        }
    }
    r[u] = l[u] + siz[u] - 1;
}

// 消除 u 的子树对 cnt[] 和 res 的影响
void del(int u) {
    int co = c[u];
    sum[cnt[co]] -= co;
    cnt[co]--;
    sum[cnt[co]] += co;
    if (top > 0 && sum[top] == 0) {
        --top;
    }
}

// 算上点 u 对 res 和 cnt[] 的影响
void count(int u) {
    int co = c[u];
    sum[cnt[co]] -= co;
    cnt[co]++;
    sum[cnt[co]] += co;
    if (sum[top + 1]) {
        ++top;
    }
}

// 第二次 dfs：树上启发式合并
// keep 表示是否消除 u 的子树对 res 和 cnt[] 的影响
void dfs2(int u, int pa, bool keep) {
    // 计算所有轻儿子的答案，算完一个就消除答案的影响
    for (int v : g[u]) {
        if (v == pa || v == wson[u]) {
            continue;
        }
        dfs2(v, u, 0);
    }
    // 计算重儿子的 ans[u]，保留他对答案的影响
    if (wson[u]) {
        dfs2(wson[u], u, 1);
    }
    // 将 u 的轻儿子对 ans[u] 的影响考虑进来
    for (int v : g[u]) {
        if (v == pa || v == wson[u]) {
            continue;
        }
        for (int i = l[v]; i <= r[v]; i++) {
            count(pos[i]);
        }
    }
    // 最后更新 ans[u]
    count(u);
    ans[u] = sum[top];

    // 如果需要，删除 u 的子树对答案的影响
    if (keep == 0) {
        for (int i = l[u]; i <= r[u]; i++) {
            del(pos[i]);
        }
    }
}

void SolveTest() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &c[i]);
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%lld%lld", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }

    dfs1(1, 0);
    dfs2(1, 0, 1);

    for (int i = 1; i <= n; i++) {
        printf("%lld ", ans[i]);
    }
}
```





### 集合式写法

一般来说会比桶式写法的时间和空间复杂度多一个 $\log$。

但是更清晰，更好写，解决范围更广。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>

int Testnum = 1;
/**********************  Core code begins  **********************/

const int N = 2e5 + 7;
int n, c[N], ans[N];
vector<int> g[N];

int dfncnt = 0, l[N], r[N], siz[N], pos[N], wson[N];
int id[N];

struct node {
    int maxcnt = 0; // 出现最多的次数
    int maxsum = 0; // 出现次数最多的颜色编号和
    map<int, int> cnt; // 记录该子树每种颜色的数量

    void add(int u) {
        cnt[c[u]]++;
        if (cnt[c[u]] > maxcnt) {
            maxcnt = cnt[c[u]];
            maxsum = c[u];
        } else if (cnt[c[u]] == maxcnt) {
            maxsum += c[u];
        }
    }
} p[N];

// 预处理 siz 和 wson
void dfs1(int u, int pa) {
    siz[u] = 1;
    l[u] = ++dfncnt;
    pos[dfncnt] = u;
    for (int v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[wson[u]]) {
            wson[u] = v;
        }
    }
    r[u] = dfncnt;
}

void dfs2(int u, int pa) {
    id[u] = u;
    for (int v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs2(v, u);
    }
    if (wson[u]) {
        id[u] = id[wson[u]];
    }

    for (int v : g[u]) {
        if (v == pa || v == wson[u]) {
            continue;
        }
        for (int i = l[v]; i <= r[v]; i++) {
            p[id[u]].add(pos[i]);
        }
    }
    p[id[u]].add(u);
    ans[u] = p[id[u]].maxsum;
}

void SolveTest() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &c[i]);
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%lld%lld", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }

    dfs1(1, 0);
    dfs2(1, 0);

    for (int i = 1; i <= n; i++) {
        printf("%lld ", ans[i]);
    }
}

/**********************  Core code ends  ***********************/
signed main() {
#ifdef LOCAL
    freopen("in.txt", "r", stdin);
#endif
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```





```cpp
const int N = 2e5 + 6;
int n, m, c[N];
int siz[N], wson[N];
int dfncnt = 0, dfn[N], l[N], r[N], pos[N];
vector<int> g[N];

// cnt 是每种颜色的数量，sum 记录每种数量的颜色编号和，top 数量的最大值，ans是每个点的答案
int cnt[N], sum[N], top = 0, ans[N];

// 第一次 dfs：重链剖分，预处理 dfn序列
void dfs1(int u, int pa) {
    dfn[u] = ++dfncnt;
    pos[dfn[u]] = u;
    l[u] = dfncnt;
    siz[u] = 1;
    int maxv = -1;
    for (int v : g[u]) {
        if (v == pa) {
            continue;
        }
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > maxv) {
            maxv = siz[v];
            wson[u] = v;
        }
    }
    r[u] = l[u] + siz[u] - 1;
}

// 消除 u 的子树对 cnt[] 和 res 的影响
void del(int u) {
    int co = c[u];
    sum[cnt[co]] -= co;
    cnt[co]--;
    sum[cnt[co]] += co;
    if (top > 0 && sum[top] == 0) {
        --top;
    }
}

// 算上点 u 对 res 和 cnt[] 的影响
void count(int u) {
    int co = c[u];
    sum[cnt[co]] -= co;
    cnt[co]++;
    sum[cnt[co]] += co;
    if (sum[top + 1]) {
        ++top;
    }
}

// 第二次 dfs：树上启发式合并
// keep 表示是否消除 u 的子树对 res 和 cnt[] 的影响
void dfs2(int u, int pa, bool keep) {
    // 计算所有轻儿子的答案，算完一个就消除答案的影响
    for (int v : g[u]) {
        if (v == pa || v == wson[u]) {
            continue;
        }
        dfs2(v, u, 0);
    }
    // 计算重儿子的 ans[u]，保留他对答案的影响
    if (wson[u]) {
        dfs2(wson[u], u, 1);
    }
    // 将 u 的轻儿子对 ans[u] 的影响考虑进来
    for (int v : g[u]) {
        if (v == pa || v == wson[u]) {
            continue;
        }
        for (int i = l[v]; i <= r[v]; i++) {
            count(pos[i]);
        }
    }
    // 最后更新 ans[u]
    count(u);
    ans[u] = sum[top];

    // 如果需要，删除 u 的子树对答案的影响
    if (keep == 0) {
        for (int i = l[u]; i <= r[u]; i++) {
            del(pos[i]);
        }
    }
}

void SolveTest() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &c[i]);
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%lld%lld", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }

    dfs1(1, 0);
    dfs2(1, 0, 1);

    for (int i = 1; i <= n; i++) {
        printf("%lld ", ans[i]);
    }
}
```





## 长链剖分

### 求树上 k 级祖先

[洛谷P5903 【模板】树上 k 级祖先](https://www.luogu.com.cn/problem/P5903)

长链剖分可以 $O(n\log n)$ 预处理，$O(1)$回答。

【预处理】

先预处理出树上倍增数组 $fa[u][i]$，表示 $u$ 的第 $2^i$ 级祖先。
并预处理出 $1 ... n$ 每个数二进制下最高位的 1 的位置，即 $highbit(k)$，以下记 $h_k$。

长链剖分后，对于每条链，如果其长度为 $len$，那么在顶点处记录顶点向上的 $len$ 个祖先和向下的 $len$ 个链上的儿子

【查询】

对于每次 $(u,k)$ 的询问：
先利用倍增数组将 $u$ 跳到 $u$ 的第 $2^{h_k}$ 级祖先，设剩下 $k' = k - 2^{h_k}$ 级，显然 $k'< 2^{h_k}$。 

而此时 $u$ 所在长链长度 $>= 2^{h_k}$。所以再将 $u$ 跳到链顶 $top[u]$ 。

之后剩下的级数直接在预处理出的向上向下的数组里O(1)查询即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long lt;
typedef unsigned int ui;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=500010;
ui s;
int n,Q,rt;
struct node{int v,nxt;}E[maxn<<1];
int head[maxn],tot;
int hi[maxn];
int fa[maxn][25],dep[maxn],mxd[maxn];
int son[maxn],top[maxn];
vector<int> pre[maxn],nxt[maxn];
lt ans[maxn*10];

ui get(ui x) 
{
	x^=x<<13;
	x^=x>>17;
	x^=x<<5;
	return s=x; 
}

void add(int u,int v)
{
	E[++tot].nxt=head[u];
	E[tot].v=v;
	head[u]=tot;
}

void dfs1(int u,int pa)
{
	dep[u]=mxd[u]=dep[pa]+1;
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].v;
		if(v==pa) continue;
		dfs1(v,u);
		if(mxd[v]>mxd[u]) mxd[u]=mxd[v],son[u]=v; 
	}
}

void dfs2(int u,int tp)
{
	top[u]=tp;
	if(u==tp)
	{
		int x=u;
		for(int i=0;i<=mxd[u]-dep[u];++i)
		{
			pre[u].push_back(x);
			x=fa[x][0];
		}
		x=u;
		for(int i=0;i<=mxd[u]-dep[u];++i)
		{
			nxt[u].push_back(x);
			x=son[x];
		}
	}
	
	if(son[u]) dfs2(son[u],tp);
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].v;
		if(v==son[u]||v==fa[u][0]) continue;
		dfs2(v,v);
	}
}

int solve(int u,int k)
{
	if(k==0) return u;
	u=fa[u][hi[k]];
	k-=1<<hi[k];
	k-=dep[u]-dep[top[u]];
	u=top[u];
	return k>=0?pre[u][k]:nxt[u][-k];
}

int main()
{
	n=read(); Q=read(); s=read();
	
	hi[0]=-1;
	for(int i=1;i<=n;++i)
	{
		fa[i][0]=read();
		add(fa[i][0],i); add(i,fa[i][0]);
		if(fa[i][0]==0) rt=i;
		hi[i]=hi[i>>1]+1;
	}
	
	dfs1(rt,0); dfs2(rt,rt);
	for(int i=1;(1<<i)<=n;++i)
	for(int u=1;u<=n;++u)
	fa[u][i]=fa[fa[u][i-1]][i-1];
	
	for(int i=1;i<=Q;++i)
	{
		int x=(get(s)^ans[i-1])%n+1;
		int k=(get(s)^ans[i-1])%dep[x];

		ans[i]=solve(x,k);
	}
	
	lt res=ans[1];
	for(int i=2;i<=Q;++i)
	res^=(lt)i*ans[i];
	
	printf("%lld",res);
	return 0;
}

```



### 优化树深度有关 DP

[CF1009F. Dominant Indices](https://codeforces.com/problemset/problem/1009/F)

【题意】

给定一棵以 $1$ 为根，$n$ 个节点的树。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。
对于每个点，求使得 $d(u,x)$ 最大的 $x$，若有多个则输出最小的 $x$。

【分析】

设 $dp[u][k]$ 表示 $u$ 子树中与 $u$ 距离为 $k$ 的节点数，则 $dp[u][k]=\sum dp[v][k-1]$ ($v$ 为 $u$ 的儿子)。

设 $mxlen[u]$ 表示 $u$ 到最远的叶子结点的距离。

每次转移时，可以先选择任意一个儿子 $v$，把 $dp[v][]$ 直接错位复制给 $dp[u][]$。
可通过数组的指针操作 $(dp[u]=dp[v]+1 )$ 以 $O(1)$ 实现。

之后其他儿子的信息暴力合并到dp[u]。
即对每个儿子v，按照上述转移方程进行 $mxlen[v]$ 次更新。

可以发现这样做的复杂度直接由每次暴力合并的 $mxlen$ 决定。
如果我们把第一次直接复制的儿子选为长链剖分的重儿子，那么暴力更新的mxlen就取得最小值，总复杂度就变成了O(n)

还有一点要注意的是dp数组显然不能开 $dp[10^6][10^6]$ 那么大
但由于所有长链长度和就是 $n$，所以可以用指针指向一个大小为n的数组动态使用空间

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;

int read()
{
	int f=1,x=0;
	char ss=getchar();
	while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
	while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
	return f*x;
}

const int maxn=1000010;
int n;
struct node{int v,nxt;}E[maxn<<1];
int head[maxn],tot;
int son[maxn],mxlen[maxn];
int buf[maxn];
int *dp[maxn],*cur=buf;
int ans[maxn];

void add(int u,int v)
{
	E[++tot].nxt=head[u];
	E[tot].v=v;
	head[u]=tot;
}

void dfs1(int u,int pa)
{
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].v;
		if(v==pa) continue;
		dfs1(v,u);
		if(mxlen[v]>mxlen[son[u]]) son[u]=v;
	}
	mxlen[u]=mxlen[son[u]]+1;
}

void dfs2(int u,int pa)
{
	dp[u][0]=1;
	if(son[u])
	{
		dp[son[u]]=dp[u]+1;//错位更新信息
		dfs2(son[u],u);
		ans[u]=ans[son[u]]+1;
	}
	for(int i=head[u];i;i=E[i].nxt)
	{
		int v=E[i].v;
		if(v==son[u]||v==pa) continue;
		
		dp[v]=cur; cur+=mxlen[v];
		dfs2(v,u);
		for(int j=1;j<=mxlen[v];++j)//暴力更新
		{
			dp[u][j]+=dp[v][j-1];
			if(dp[u][j]>dp[u][ans[u]]) ans[u]=j;
			else if(dp[u][j]==dp[u][ans[u]] && j<ans[u]) ans[u]=j;
		}
	}
	if(dp[u][ans[u]]==1) ans[u]=0;
}

int main()
{
	n=read();
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read();
		add(u,v); add(v,u);
	}
	
	dfs1(1,0); 
	
	dp[1]=cur; cur+=mxlen[1];
	dfs2(1,0);
	
	for(int i=1;i<=n;++i)
	printf("%d\n",ans[i]);
	
	return 0;
}
```





## 树分治

### 点分治

【作用】

用来处理大规模的树上路径信息问题。

【步骤】

1. 处理经过当前根节点的路径
2. 删掉根节点
3. 对生成的每棵子树，取重心为根节点，重复前两步

[洛谷 P3806 - 点分治](https://www.luogu.com.cn/problem/P3806) 给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

$1\le n \le 10^4$，$1\le m\le 100$，$1\le k\le 10^7$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/
const int N = 1e7 + 7, M = 2e5 + 7;

int n, m, k;
vector<vector<tuple<int, int>>> g(M);
vector<int> query(M), ret(M); // 分别记录每一个查询的询问和答案
vector<int> vis(M);

int get_size(int u, int pa) {
    if (vis[u]) {
        return 0;
    }
    int res = 1;
    for (auto [v, w] : g[u]) {
        if (v != pa) {
            res += get_size(v, u);
        }
    }
    return res;
}

int get_wc(int u, int pa, int tot, int &wc) {
    if (vis[u]) {
        return 0;
    }
    int sum = 1, maxv = 0;
    for (auto [v, w] : g[u]) {
        if (v == pa) {
            continue;
        }
        int t = get_wc(v, u, tot, wc);
        maxv = max(maxv, t);
        sum += t;
    }
    maxv = max(maxv, tot - sum);
    if (maxv <= tot / 2) {
        wc = u;
    }
    return sum;
}

void get_dist(int u, int pa, int dist, vector<PII> &a, int top) {
    if (vis[u]) {
        return;
    }
    a.push_back({dist, top});
    for (auto [v, w] : g[u]) {
        if (v != pa) {
            get_dist(v, u, dist + w, a, top);
        }
    }
}

void dfs(int u) {
    if (vis[u]) {
        return;
    }
    // 找到当前树的重心，作为新的树根
    get_wc(u, 0, get_size(u, 0), u);
    vis[u] = 1;
    vector<PII> dis = {{0, u}}; // 每一个 pair<int, int> 记录：某个点到u的距离，这个点在哪一棵子树
    for (auto [v, w] : g[u]) {
        vector<int> tmp; // 储存子树 v 内所有点到 u 的距离
        get_dist(v, 0, w, dis, v);
    }
    sort(dis.begin(), dis.end());
    // 双指针统计答案
    for (int i = 1; i <= m; i++) {
        int l = 0, r = dis.size() - 1;
        if (ret[i]) {
            continue;
        }
        while (l < r) {
            auto [dl, froml] = dis[l];
            auto [dr, fromr] = dis[r];
            if (dl + dr > query[i]) {
                r--;
            } else if (dl + dr < query[i]) {
                l++;
            } else if (froml == fromr) {
                if (fromr == dis[r - 1].second) {
                    r--;
                } else {
                    l++;
                }
            } else {
                ret[i] = 1;
                break;
            }
        }
    }
    // 分治，递归子树中的答案
    for (auto [v, w] : g[u]) {
        dfs(v);
    }
}

void SolveTest() {
    cin >> n >> m;
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    for (int i = 1; i <= m; i++) {
        cin >> query[i];
    }
    dfs(1);
    for (int i = 1; i <= m; i++) {
        cout << (ret[i] ? "AYE" : "NAY") << endl;
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```









## 虚树

浓缩信息，将给定关键点和根节点建成树，大树变小树

### 建虚树

【原理】

- 虚树的欧拉序列在原树的欧拉序列中顺序不变
- 而根据欧拉序列又可以确定唯一的DFS顺序进而还原原树

【过程】

预处理整棵树得到dfs序列，记为 $dfn[u]$。

使用一个栈，从栈顶到栈低的元素形成虚树的一条树链。

当我们得到一些关键点的时候，对这些点按照他们的 $dfn[u]$ 值进行排序，然后从 $dfn$ 值较小的开始扫描，结合栈中保存的树链信息就可以将这棵树构建出来。

假设我们当前扫到的关键点为 $u$ ，栈指针为 $top$ ，栈为 $stk$。

1. 如果栈为空，或者栈中只有一个元素，那么应该 $top \leftarrow top + 1,\  stk[top]=u$；
2. 取 $lca = (LCA(u, stk[top]))$，如果 $lca = stk[top]$，则说明 $u$ 点应该接着 $stk[top]$ 点延长当前的树链，进行操作 $top \leftarrow top +1,\ stk[top] = u$。
3. 如果 $lca \ne stk[top]$ ，则说明 $u$ 与 $stk[top]$ 分属 $lca$ 的两棵子树，而且包含 $stk[top]$ 的这棵子树应该已经构建完成了，我们需要做的是：将 $lca$ 包含的 $stk[top]$ 子树的那部分退栈，并将这部分建边形成虚树。如果 $lca$ 不在栈中，那么要把 $lca$ 也加入栈中，保证虚树的结构不出现问题，随后将 $u$ 加入栈中，以表延长树链。



```cpp
//实现逐个将关键点插入形成一颗虚树
void insert(int u){
    if(top <= 1) {
        stk[++top] = u;
        return;
    }
    int lca = LCA(u,stk[top]);
    if(lca == stk[top]) {
        stk[++top] = u;
        return;
    }
    while(top > 1 && dfn[lca] <= stk[top-1]) {
        addedge(stk[top-1],stk[top]);
        --top;
    }
    if(lca != stk[top]) {
        stk[++top] = lca;
    }
    stk[++top] = u;
}
```







[[SDOI2011] 消耗战 - 洛谷](https://www.luogu.com.cn/problem/P2495)

【题意】

给 $n$ 个点的树，有边权，以 $1$ 为根。 $q$ 次询问，每次询问给出 $k$ 个特殊点，求：删除若干条边，使得任何一个特殊点都无法到达根节点，输出删除边的点权和的最小值。

$n \le 2.5 \times 10^5$，$q \le 5\times 10^5$，$\sum k_i \le 5\times 10^5$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define endl "\n"
/**********************  Core code begins  **********************/
const int INF = 1e18;

struct Edge {
	int to, cost;
};

struct VTree {
	int n, root;
	vector<vector<Edge>> g;
	vector<int> mark;
	VTree(int n) : n(n), g(n + 1), mark(n + 1) {
	}

	void addEdge(int u, int v, int w) {
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}

	int dfs(int u, int pa) {
		int ans = 0;
		for (auto [v, w] : g[u]) {
			if (v == pa) {
				continue;
			}
			if (mark[v]) {
				ans += w;
				continue;
			}
			ans += min(w, dfs(v, u));
		}
		return ans;
	}
};

struct Tree {
	static const int M = 25;	// 树的最大深度不超过 (1 << M)
	vector<vector<Edge>> g;
	vector<int> dfn, dep, minv;
	vector<array<int, M>> fa;

	int n, dfncnt = 0;

	Tree(int n) : n(n), g(n + 1),
		dfn(n + 1), dep(n + 1),
		fa(n + 1), minv(n + 1) {
	}

	void addEdge(int u, int v, int w) {
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}

	void dfs1(int u, int pa) {
		dfn[u] = ++dfncnt;
		fa[u][0] = pa;
		dep[u] = dep[pa] + 1;
		for (int i = 1; i < M; i++) {
			fa[u][i] = fa[fa[u][i - 1]][i - 1];
		}
		for (auto [v, w] : g[u]) {
			if (v == pa) {
				continue;
			}
			minv[v] = min(w, minv[u]);
			dfs1(v, u);
		}
	}

	// 查询 u，v 的最近公共祖先
	int lca(int u, int v) {
		if (dep[u] < dep[v]) {
			swap(u, v);
		}
		int t = dep[u] - dep[v];
		for (int i = 0; i < M; i++) {
			if (t & (1 << i)) {
				u = fa[u][i];
			}
		}
		if (u == v) {
			return u;
		}
		for (int i = M - 1; i >= 0; i--) {
			if (fa[u][i] != fa[v][i]) {
				u = fa[u][i];
				v = fa[v][i];
			}
		}
		return fa[u][0];
	}

	// 将 h 中的所有点建立虚树
	VTree build_virtual_tree(vector<int> &h) {
		set<int> st;
		for (int x : h) {
			st.insert(x);
		}
		int k = h.size();
		sort(h.begin(), h.end(), [&](int x, int y) {
			return dfn[x] < dfn[y];
		});
		for (int i = 0; i < k - 1; i++) {
			h.push_back(lca(h[i], h[i + 1]));
		}
		sort(h.begin(), h.end(), [&](int x, int y) {
			return dfn[x] < dfn[y];
		});

		k = unique(h.begin(), h.end()) - h.begin();

		int idcnt = 0;
		map<int, int> id;	// 将原树中的点映射到虚树中的点

		VTree res(k + 1);
		for (int i = 0; i < k; i++) {
			id[h[i]] = ++idcnt;
			if (st.count(h[i])) {
				res.mark[idcnt] = 1;
			}
		}
		res.root = id[1];

		for (int i = 0; i < k - 1; i++) {
			int u = lca(h[i], h[i + 1]);
			int v = h[i + 1];
			int w = minv[v];
			res.addEdge(id[u], id[v], w);
		}
		return res;
	}
};


void SolveTest() {
	int n;
	cin >> n;
	Tree g1(n + 1);
	for (int i = 1; i < n; i++) {
		int u, v, w;
		cin >> u >> v >> w;
		g1.addEdge(u, v, w);
	}

	g1.minv[1] = INF;
	g1.dfs1(1, 0);

	int q, k;
	cin >> q;

	while (q--) {
		cin >> k;
		vector<int> h(k + 1);
		h[0] = 1;
		for (int i = 1; i <= k; i++) {
			cin >> h[i];
		}
		VTree g2 = g1.build_virtual_tree(h);
		cout << g2.dfs(g2.root, 0) << endl;
	}
}

/**********************  Core code ends  ***********************/
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int T = 1;
	// cin >> T;
	for (int i = 1; i <= T; i++) {
		SolveTest();
	}
	return 0;
}
```

