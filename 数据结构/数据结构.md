[TOC]



# STL

## `std::set` 维护下标

类似线段树，平衡树也有两种使用的思路：1. 维护值域；2. 维护下标。通常维护下标是容易忽略的。

用 `std::set` 可以完成这样一类操作：

1. 给某个点打标记 or 删除标记（标记可以为任意值）；
2. 查询某点左/右最近的标记点以及对应的值；
3. 查询标记点的数量，查询最左/最右的标记点，遍历所有标记点……；



例题：

- [2023 ICPC 香港 L. Permutation Compression](https://codeforces.com/gym/104172/problem/L)
- [1841 E. Fill the Matrix](https://codeforces.com/contest/1841/problem/E)



`std::set` 是一棵平衡树，因此本身是相当强大的。



使用 `std::set` 可以方便地维护一个连续序列，实现：

- 将某个位置删除，并将它所在的段分成两个段；
- 查询某个位置所在段的左右边界。



# 线性结构

## 栈

[P4387 验证栈序列](https://www.luogu.com.cn/problem/P4387)

【题意】给定一个排列的入栈和出栈顺序，判断其是否合法。

【思路】把元素按照入栈顺序重新标号。关键是栈内元素一定是单调的，所以用一个堆来维护栈内的元素。

```cpp
void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n + 1), id(n + 1);
    for (int i = 1; i <= n; i++) {
        int x;
        std::cin >> x;
        id[x] = i;
    }
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
        a[i] = id[a[i]];
    }

    int prevMax = 0;
    std::stack<int> stk;

    for (int i = 1; i <= n; i++) {
        if (a[i] > prevMax) {
            while (++prevMax < a[i]) {
                stk.push(prevMax);
            }
        } else if (!stk.empty() && a[i] == stk.top()) {
            stk.pop();
        } else {
            std::cout << "No\n";
            return;
        }
    }
    
    std::cout << "Yes\n";
}
```



## 单调栈

[P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)

【题意】给出项数为 $n$的整数数列 $a[1...n]$。定义函数 $f(i)$ 代表数列中第 $i$个元素之后第一个大于 $a[i]$的元素的下标，即$ f(i)=\min \{\ j\ \ |i<j\le n, a[i]<a[j]\}$。若不存在，则 $f(i)=0$。试求出$f(1...n)$。

```c++
#include <bits/stdc++.h>
#define int long long

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    std::vector<int> ans(n + 1);
    std::stack<int> stk;
    for (int i = n; i >= 1; i--) {
        while (stk.size() && a[i] >= a[stk.top()]) {
            stk.pop();
        }
        ans[i] = (stk.size() ? stk.top() : n + 1);
        stk.push(i);
    }
    
    for (int i = 1; i <= n; i++) {
        std::cout << (ans[i] == n + 1 ? 0 : ans[i]) << " ";
    }

    return 0;
}
```



## 单调队列

[P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)

【题意】有一个长为 $n$的序列 $a$，以及一个大小为 $k$的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最小值和最大值。

```c++
#include <bits/stdc++.h>
#define int long long

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, k;
    std::cin >> n >> k;

    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    // 滑动窗口最小值
    std::deque<int> queMin;
    std::vector<int> ansMin(n + 1);
    for (int i = 1; i <= n; i++) {
        while (queMin.size() && a[i] <= a[queMin.back()]) {
            queMin.pop_back();
        }
        while (queMin.size() && queMin.front() < i - k + 1) {
            queMin.pop_front();
        }
        queMin.push_back(i);
        ansMin[i] = a[queMin.front()];
    }
    for (int i = k; i <= n; i++) {       
        std::cout << ansMin[i] << " ";
    }

    std::cout << "\n";

    // 滑动窗口最大值
    std::deque<int> queMax;
    std::vector<int> ansMax(n + 1);
    for (int i = 1; i <= n; i++) {
        while (queMax.size() && a[i] >= a[queMax.back()]) {
            queMax.pop_back();
        }
        while (queMax.size() && queMax.front() < i - k + 1) {
            queMax.pop_front();
        }
        queMax.push_back(i);
        ansMax[i] = a[queMax.front()];
    }
    for (int i = k; i <= n; i++) {
        std::cout << ansMax[i] << " ";
    }
    
    return 0;
}
```



# 倍增思想

## ST表

[ST表模板题 P1816](https://www.luogu.com.cn/problem/P1816)

```c++
#include <bits/stdc++.h>
#define int long long

template<typename T, class Comp = std::less<T>>
struct RMQ {
	const int n;
	const Comp cmp;
	std::vector<std::vector<T>> f;
    
	// 要求 init 的下标从 1开始，把 init[0] 空出来
	RMQ(const std::vector<T> &init) : n(init.size() - 1), cmp(Comp()) {
		int lg = std::__lg(n);
		f.assign(n + 1, std::vector<T>(lg + 1));
		for (int i = 1; i <= n; i++) {
			f[i][0] = init[i];
		}
		for (int j = 1; j <= lg; j++) {
			for (int i = 1; i + (1 << j) - 1 <= n; i++) {
				f[i][j] = std::min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1], cmp);
			}
		}
	}

	T rmq(int l, int r) {
		int s = std::__lg(r - l + 1);
		return std::min(f[l][s], f[r - (1 << s) + 1][s], cmp);
	}
};

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);

	int n, m;
	std::cin >> n >> m;
	std::vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		std::cin >> a[i];
	}

	RMQ<int, std::less<int>> ST(a);
	while (m--) {
		int l, r;
		std::cin >> l >> r;
		if (l > r) {
			std::swap(l, r);
		}
		std::cout << ST.rmq(l, r) << " ";
	}

	return 0;
}
```



## 跳区间

[1175E. Minimal Segment Cover](https://codeforces.com/contest/1175/problem/E)              

【题意】给 $n$ 条线段，每条线段覆盖区间 $[l_i,r_i]$。$m$ 次询问，每次给出区间 $[x,y]$，问最少选择多少线段能将 $[x,y]$ 完全覆盖。不能则输出 $-1$。

$n,m\le 2\cdot 10^5$，$0\le x_i\le y_i\le 5\cdot 10^5$，$0\le l_i\le r_i\le 5\cdot 10^5$。

【做法】对于每个位置 $i$，预处理从这个点及左边的位置开始，使用 $2^j$ 条线段，能到达的右边最远点。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;

    const int N = 5e5 + 10, M = 20;

    // f[i][j] 表示：从 i 开始，使用 (1<<j) 条线段，能到达的最远位置
    std::vector f(N + 1, std::array<int, M + 1>());
    for (int i = 1; i <= n; i++) {
        int l, r;
        std::cin >> l >> r;
        f[l][0] = std::max(f[l][0], r);
    }
    for (int i = 1; i <= N; i++) {
        f[i][0] = std::max({f[i][0], i, f[i - 1][0]});
    }

    for (int i = 1; i <= M; i++) {
        for (int j = 0; j <= N; j++) {  // 很坑！位置从 0 开始！
            f[j][i] = f[f[j][i - 1]][i - 1];
        }
    }

    while (q--) {
        int l, r;
        std::cin >> l >> r;
        int ans = 0;
        for (int i = M; i >= 0; i--) {
            if (f[l][i] < r) {
                ans += (1 << i);
                l = f[l][i];
            }
        }
        if (f[l][0] >= r) {
            std::cout << ans + 1 << "\n";
        } else {
            std::cout << "-1\n";
        }
    }

    return 0;
}
```

​                                                  

# 堆

## 对顶堆

作用：动态维护一个集合

- 插入元素
- 查询第 $k$ 小的值
- 删除第 $k$ 小的元素
- 查询前 $k$ 小元素的和
- ...

也可以将它弱化，维护集合中位数，例题：[RMID2 - Running Median Again](https://www.luogu.com.cn/problem/SP16254)

用 splay/权值线段树 之类的都能轻松解决，但是对顶堆肯定码量小不容易错。本质上是两个堆，大根堆维护较小的若干元素，小根堆维护较大的若干元素。

```cpp
struct DoubleEndedHeap {
    int tot = 0;
    std::priority_queue<int> heap1;    
    std::priority_queue<int, std::vector<int>, std::greater<int>> heap2; 
    // 在两个堆之间转移元素，维护 heap1 的大小为 k
    void update(int k) {
        while (heap1.size() < k) {
            heap1.push(heap2.top());
            heap2.pop();
        }
        while (heap1.size() > k) {
            heap2.push(heap1.top());
            heap1.pop();
        }
    }
    // 插入值为 x 的元素
    void insert(int x) {
        if (heap1.empty() || x <= heap1.top()) {
            heap1.push(x);
        } else {
            heap2.push(x);
        }
        tot++;
    }
    // 查询第 k 小
    int query(int k) {
        update(k);
        return heap1.top();
    }
    // 删除第 k 小的元素
    void remove(int k) {
        update(k);
        heap1.pop();
        tot--;
    }
};
```

此外，还可以通过所谓 “延迟删除” 的技巧实现 “删除一个值为 $x$ 的元素” 功能。但是代码长度翻了一倍，失去了短小的价值，不如直接写权值线段树。



## 左偏树（可并堆）

[P3377 【模板】左偏树（可并堆）](https://www.luogu.com.cn/problem/P3377)

【题意】

一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：

1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在用一个堆内，则无视此操作）。

2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。

【思路】

启发式合并能过，但是左偏树仍然有不可替代性。

左偏树的主要性质：

1. 堆性质：如果是小根堆，那么有父节点的权值 $\le$ 儿子节点的权值

2. 左偏性质：对任何一个结点，它的左儿子的 `dis` 大于等于右儿子的 `dis`

    关于 `dis` 的定义：

    - 定义“外结点”：左儿子或右儿子为空
    - 定义`dis`：空结点的 `dis = -1`，外结点的 `dis = 0`，其余点的 `dist = min(dis[lson], dis[rson])`


延申性质：

- 任何一个节点的左儿子是一个深度为 $d$ 的满二叉树，右儿子是一个深度介于 $[d-1,d]$ 的不满二叉树。


```c++
#include <bits/stdc++.h>

using i64 = long long;

template<class Key, typename Compare = std::less<Key>>
class LefistTree {
public:
    struct Node {
        Node *l = nullptr, *r = nullptr, *fa = this;
        Key key;
        int dis = 0;
        bool del = false;

        Node(Key v) {
            key = v;
        }

        // 返回所在堆的根节点指针
        Node *find() {
            return fa == this ? this : fa = fa->find();
        }
    };

    Compare comp;

    // 返回所在堆的堆顶信息
    Key top(Node *p) {
        assert(p != nullptr && p->del == false);
        return p->find()->key;
    }

    // 合并 p1 所在的堆与 p2所在的堆
    Node *merge(Node *p1, Node *p2) {
        p1 = p1->find();
        p2 = p2->find();
        if (p1 == p2) {
            return p1;
        }
        auto t = mergeRT(p1, p2);
        p1->fa = t;
        p2->fa = t;
        return t;
    }

    // 弹出 p 所在堆的堆顶，返回新的堆顶指针
    Node *pop(Node *p) {
        assert(p != nullptr && p->del == false);
        p = p->find();
        Node *t = mergeRT(p->l, p->r);
        p->del = true;
        if (p->l != nullptr) {
            p->l->fa = t;
        }
        if (p->r != nullptr) {
            p->r->fa = t;
        }
        p->fa = t;              // 为了其他 fa 指向 p 的点能在路径压缩时更新 fa
        p->l = p->r = nullptr;
        return t;
    }

private:
    Node *mergeRT(Node *p1, Node *p2) {
        if (p1 == nullptr) {
            return p2;
        }
        if (p2 == nullptr) {
            return p1;
        }
        if (!comp(p1->key, p2->key)) {
            std::swap(p1, p2);
        }
        p1->r = mergeRT(p1->r, p2);
        if ((p1->l ? p1->l->dis : 0) < (p1->r ? p1->r->dis : 0)) {
            std::swap(p1->l, p1->r);
        }
        p1->dis = (p1->r ? p1->r->dis : 0) + 1;
        return p1;
    }
};

struct Info {
    int val, id;
    friend bool operator< (const Info &lhs, const Info &rhs) {
        if (lhs.val == rhs.val) {
            return lhs.id < rhs.id;
        }
        return lhs.val < rhs.val;
    }
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;

    using Node = LefistTree<Info>::Node;
    std::vector<Node*> node(n + 1);
    for (int i = 1; i <= n; i++) {
        int x;
        std::cin >> x;
        node[i] = new Node({x, i});
    }

    LefistTree<Info> heap;

    while (q--) {
        int op, x, y;
        std::cin >> op;
        if (op == 1) {
            std::cin >> x >> y;
            if (node[x]->del || node[y]->del) {
                continue;
            }
            heap.merge(node[x], node[y]);
        } else {
            std::cin >> x;
            if (node[x]->del) {
                std::cout << "-1\n";
                continue;
            }
            std::cout << heap.top(node[x]).val << "\n";
            heap.pop(node[x]);
        }
    }

    return 0;
}
```



# 并查集

并查集类似一棵有向树，区别是边的方向从子节点指向父节点；

并查集分为普通并查集和带权并查集两大类；

普通并查集维护的是**元素之间的连通性**，本质是合并两个连通块、查询两个元素是否在同一连通块、查询连通块大小；

带权并查集维护的是**元素之间的相对关系**，主要有两种应用：

- **直接意义上地维护两个元素的距离**；离线后可以用差分约束解决
- 通过模意义的距离合并，维护元素的类别关系；类似的问题通常也可以离线二分图解决

[一篇讲解带权并查集的博客](https://blog.csdn.net/yjr3426619/article/details/82315133?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166610987716782390584572%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166610987716782390584572&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82315133-null-null.142)

## 普通并查集

```c++
struct DSU {
    int n;
    std::vector<int> fa, siz;

    DSU(int n) {
        this->n = n;
        fa.resize(n + 1);
        siz.assign(n + 1, 1);
        std::iota(fa.begin(), fa.end(), 0);
    }

    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }

    bool same(int x, int y) {
        return find(x) == find(y);
    }

    // 合并后 x == fa[y];
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        fa[y] = x;
        siz[x] += siz[y];
        return true;
    }

    int size(int x) {
        return siz[find(x)];
    }
};
```



## 带权并查集

在DSU的基础上，维护每个点到集合根点的距离

```c++
// 带权并查集
template<typename T>
struct DSU {
    int n;
    std::vector<int> fa;
    std::vector<T> dis;

    DSU(int n_) : n(n_), fa(n + 1), dis(n + 1) {
        std::iota(fa.begin(), fa.end(), 0);
    }

    bool same(int x, int y) {
        return find(x) == find(y);
    }

    int find(int x) {
        if (fa[x] != x) {
            int u = find(fa[x]);
            dis[x] += dis[fa[x]];
            fa[x] = u;
        }
        return fa[x];
    }

    // 把 y 所在集合合并到 x，满足 dis[y] = dis[x] + dist，返回是否发生冲突
    bool merge(int x, int y, T dist) {
        int fx = find(x), fy = find(y);
        if (fx != fy) {
            fa[fy] = fx;
            dis[fy] = dis[x] - dis[y] + dist;
            return true;
        } else {
            return dis[y] == dis[x] + dist;
        }
    }

    T getDis(int x) {
        return dis[find(x)];
    }
};
```

题目

- [P1892 [BOI2003]团伙](https://www.luogu.com.cn/problem/P1892)
- [P2024 [NOI2001]食物链](https://www.luogu.com.cn/problem/P2024)
- [1850H. The Third Letter](https://codeforces.com/contest/1850/problem/H)



## 启发式合并

【题意】

[P3201 [HNOI2009] 梦幻布丁](https://www.luogu.com.cn/problem/P3201)

$n$ 个布丁摆成一行，进行 $m$ 次操作。每次将某个颜色的布丁全部变成另一种颜色的，然后再询问当前一共有多少段颜色。 $1 \leq n, m \leq 10^5$，$1 \leq a_i ,x, y \leq 10^6$。

【代码】

```cpp
#include <bits/stdc++.h>
#define int long long

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m, ans = 0, N = 1e6 + 7;
    std::cin >> n >> m;
    std::vector<std::vector<int>> pos(N);
    std::vector<int> a(n + 2), mp(N);

    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
        mp[a[i]] = a[i];				
        pos[a[i]].push_back(i);
        if (a[i] != a[i - 1]) {
            ans++;
        }
    }

    for (int qq = 1; qq <= m; qq++) {
        int op, x, y;
        std::cin >> op;
        if (op == 1) {
            std::cin >> x >> y;
            if (mp[y] == mp[x]) {
                continue;
            }
            if (pos[mp[x]].size() > pos[mp[y]].size()) {
                std::swap(mp[y], mp[x]);
            }
            y = mp[y], x = mp[x];
            
            // 开始启发式合并
            for (int i : pos[x]) {
                if (a[i - 1] == y) {
                    ans--;
                }
                if (a[i + 1] == y) {
                    ans--;
                }
            }
            for (int i : pos[x]) {
                a[i] = y;
                pos[y].push_back(i);
            }
            pos[x].clear();
        } else {
            std::cout << ans << "\n";
        }
    }

    return 0;
}
```



# 树状数组

## 一维树状数组

[单点修改，区间求和](https://www.luogu.com.cn/problem/P3374)

```c++
template<class T>
struct Fenwick {
    int n;
    std::vector<T> a;

    Fenwick(int n = 0) {
        init(n);
    }

    void init(int n) {
        this->n = n;
        a.assign(n + 1, T());
    }

    void add(int x, T k) {
        for (int i = x; i <= n; i += i & -i) {
            a[i] += k;
        }
    }

    T preSum(int x) {
        T res = 0;
        for (int i = x; i; i -= i & -i) {
            res += a[i];
        }
        return res;
    }

    T sum(int l, int r) {
        assert(l > 0 && r <= n);
        return preSum(r) - preSum(l - 1);
    }
};

```





## 树状数组上二分（不会）





## 动态开点树状数组

源自于 [F. Pathwalks](https://codeforces.com/problemset/problem/960/F)  需要维护 $n$ 个树状数组，每个树状数组的范围是 $[1,10^5]$。技巧是将树状数组的数组换为 `std::map<int, int>`。

```cpp
// map 实现的 “动态开点树状数组”
struct BIT {
    static const int MAXN = 1e5 + 7;
    std::map<int, int> tr;
    
    void add(int x, int k) {
        for (int i = x; i < MAXN; i += i & -i) {
            tr[i] = std::max(tr[i], k);
        }
    }
    
    int query(int x) {
        int res = 0;
        for (int i = x; i; i -= i & -i) {
            res = std::max(res, tr[i]);
        }
        return res;
    }
};
```





## 离线二维数点

[P3755 [CQOI2017] 老C的任务](https://www.luogu.com.cn/problem/P3755)

题意：多次查询矩形内点值和，可离线。

完全离散化的写法（横纵坐标都离散化）：

```cpp
#include <bits/stdc++.h>

using i64 = long long;

template<typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
    Fenwick(int n) {
        this->n = n;
        a.assign(n + 1, 0);
    }
    void add(int x, T k) {
        for (int i = x; i <= n; i += i & -i) {
            a[i] += k;
        }
    }
    T preSum(int x) {
        T res = 0;
        for (int i = x; i; i -= i & -i) {
            res += a[i];
        }
        return res;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    // 读入数据并离散化
    int n, q;
    std::cin >> n >> q;
    std::vector<std::array<int, 3>> Node(n + 1);
    std::vector<std::array<int, 4>> qu(q + 1);
    std::vector<int> value;           // 用来离散化
    for (int i = 1; i <= n; i++) {
        int x, y, v;
        std::cin >> x >> y >> v;
        Node[i] = {x, y, v};
        value.insert(value.end(), {x, y});
    }
    for (int i = 1; i <= q; i++) {
        int xa, ya, xb, yb;
        std::cin >> xa >> ya >> xb >> yb;
        qu[i] = {xa, ya, xb, yb};
        value.insert(value.end(), {xa - 1, ya - 1, xa, ya, xb, yb});    // 特别要注意，对于询问的离散化是 xa-1,ya-1
    }

    std::sort(value.begin(), value.end());
    value.erase(std::unique(value.begin(), value.end()), value.end());
    auto getVal = [&](i64 x) -> int {
        int res = std::lower_bound(value.begin(), value.end(), x) - value.begin();
        assert(value[res] == x);
        return res + 1;
    };

    for (int i = 1; i <= n; i++) {
        for (int j : {0, 1}) {
            Node[i][j] = getVal(Node[i][j]);
        }
    }
    for (int i = 1; i <= q; i++) {
        for (int j = 0; j < 4; j++) {
            qu[i][j] = getVal(qu[i][j]);
        }
    }

    /***********************************************************************************/
    // 上面都只是在离散化，现在有 n 个点 Node[i]，n 次查询 qu[i]，横纵坐标全都分布在 1~N 范围
    const int N = value.size();

    struct Query {
        int y, id, type;
    };
    struct Point {
        int y;
        i64 v;
    };

    std::vector query(N + 1, std::vector<Query>());
    std::vector point(N + 1, std::vector<Point>());

    for (int i = 1; i <= n; i++) {
        auto [x, y, v] = Node[i];
        point[x].push_back({y, v});
    }
    for (int id = 1; id <= q; id++) {
        auto [xa, ya, xb, yb] = qu[id];
        int type = 0;
        for (int i : {xa - 1, xb}) {
            for (int j : {ya - 1, yb}) {
                query[i].push_back({j, id, type++});
            }
        }
    }

    std::vector ans(q + 1, std::array<i64, 4>());   // 每次询问涉及四个部分的组合
    Fenwick<i64> fen(N + 1);

    for (int i = 1; i <= N; i++) {
        for (auto [y, v] : point[i]) {
            fen.add(y, v);
        }
        for (auto [y, id, type] : query[i]) {
            ans[id][type] = fen.preSum(y);
        }
    }
    for (int i = 1; i <= q; i++) {
        auto t = ans[i];
        i64 res = t[3] - t[2] - t[1] + t[0];
        std::cout << res << "\n";
    }

    return 0;
}
```



另一种写法（只离散化纵坐标）

```cpp
#include <bits/stdc++.h>
#define int long long
using PII = std::pair<int, int>;

struct BIT {
    int n;
    std::vector<int> tr;
    BIT(int _n): n(_n), tr(_n + 1, 0) {}
    void add(int x, int k) {
        for (int i = x; i <= n; i += i & -i) {
            tr[i] += k;
        }
    }
    int query(int x) {
        int res = 0;
        for (int i = x; i; i -= i & -i) {
            res += tr[i];
        }
        return res;
    }
};

struct Node {
    int x, y, val;
};
struct Query {
    int x, y, sig, id;
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    // 读入数据并排序
    int n, q;
    std::cin >> n >> q;
    std::vector<Node> node(n + 1);
    std::vector<int> tmp;           // 用来离散化
    for (int i = 1; i <= n; i++) {
        int x, y, val;
        std::cin >> x >> y >> val;
        node[i] = {x, y, val};
        tmp.push_back(y);
    }

    std::sort(node.begin() + 1, node.end(), [&](auto a, auto b) {
        return a.x < b.x;
    });

    std::vector<Query> qu(q + 1);   
    for (int i = 1; i <= q; i++) {  
        int xa, ya, xb, yb;
        std::cin >> xa >> ya >> xb >> yb;
        qu.push_back({xa - 1, ya - 1, 1, i});   // 将每一个询问拆成四个部分
        qu.push_back({xa - 1, yb, -1, i});
        qu.push_back({xb, ya - 1, -1, i});
        qu.push_back({xb, yb, 1, i});
        tmp.push_back(ya - 1);
        tmp.push_back(yb);
    }

    std::sort(qu.begin(), qu.end(), [&](auto a, auto b) {
        return a.x < b.x;
    });

    // 离散化
    std::sort(tmp.begin(), tmp.end());
    tmp.erase(std::unique(tmp.begin(), tmp.end()), tmp.end());
    auto get = [&](int x) {
        return std::lower_bound(tmp.begin(), tmp.end(), x) - tmp.begin() + 1;
    };

    // 扫描线
    std::vector<int> ans(q + 1);
    BIT tr(tmp.size() + 1);
    int cur = 1;
    for (auto [x, y, sig, id] : qu) {
        y = get(y);
        while (cur <= n && node[cur].x <= x) {
            tr.add(get(node[cur].y), node[cur].val);
            cur++;
        }
        ans[id] += sig * tr.query(y);
    }

    for (int i = 1; i <= q; i++) {
        std::cout << ans[i] << "\n";
    }
    return 0;
}
```





# 线段树

## 普通线段树

如果不涉及到区间修改，那么就不需要懒标记 `Tag` 类，也不需要 `pushDown()` 操作。

```cpp
template<class Info>
class SegmentTree {
public:
    SegmentTree() = default;

    template<class T>
    SegmentTree(std::vector<T> init_) {
        // 注意，用于初始化的 init_ 下标从 1 开始！
        n = init_.size() - 1;
        info.assign(n * 4, {});
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (l == r) {
                info[p] = init_[l];
                return;
            }
            int mid = (l + r) / 2;
            build(p * 2, l, mid);
            build(p * 2 + 1, mid + 1, r);
            pushUp(p);
        };
        build(1, 1, n);
    }

    void indexAssign(int x, const Info &v) {
        indexAssign(1, 1, n, x, v);
    }

    void indexInc(int x, const T &v) {
        indexInc(1, 1, n, x, v);
    }

    Info rangeQuery(int x, int y) {
        return rangeQuery(1, 1, n, x, y);
    }

private:
    int n;
    std::vector<Info> info;
    void pushUp(int p) {
        info[p] = info[p * 2] + info[p * 2 + 1];
    }
    void indexAssign(int p, int l, int r, int x, const Info &v) {
        if (l == r) {
            info[p] = v;
            return;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            indexAssign(p * 2, l, mid, x, v);
        } else {
            indexAssign(p * 2 + 1, mid + 1, r, x, v);
        }
        pushUp(p);
    }
    
    template<class T>
    void indexInc(int p, int l, int r, int x, const T &v) {
        if (l == r) {
            info[p].inc(v);
            return;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            indexInc(p * 2, l, mid, x, v);
        } else {
            indexInc(p * 2 + 1, mid + 1, r, x, v);
        }
        pushUp(p);
    }

    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= x && r <= y) {
            return info[p];
        }
        int mid = (l + r) / 2;
        Info res = {};
        if (x <= mid) {
            res = res + rangeQuery(p * 2, l, mid, x, y);
        }
        if (y > mid) {
            res = res + rangeQuery(p * 2 + 1, mid + 1, r, x, y);
        }
        return res;
    }
};

struct Info {
    Info() {}
    Info(int x) {}
    void inc(int x) {}
    friend Info operator+(const Info &lhs, const Info &rhs) {}
};
```



## 懒标记线段树

### 通用板子

如果涉及到区间修改，那么久需要懒标记。

把 `Tag` 和 `Info` 抽象出来，代码量稍大一点，但是有助于处理复杂的区间维护问题。

```cpp
template<class Info, class Tag>
class LazySegmentTree {
public:
    LazySegmentTree() = default;

    template<typename T>
    void init(std::vector<T> &a) {
        // 注意，用于初始化的 init_ 下标从 1 开始！
        init(a, 1, a.size() - 1);
    }

    template<typename T>
    void init(std::vector<T> &a, int l, int r) {
        // 注意，用于初始化的 init_ 下标从 1 开始！
        L = l;
        R = r;
        n = a.size() - 1;
        info.resize(n * 4);
        tag.resize(n * 4);

        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (l == r) {
                info[p] = a[l];
                return;
            }
            int mid = (l + r) / 2;
            build(p * 2, l, mid);
            build(p * 2 + 1, mid + 1, r);
            pushUp(p);
        };

        build(1, 1, n);
    }

    void indexAssign(int x, Info v) {
        indexAssign(1, L, R, x, v);
    }

    Info rangeQuery(int x, int y) {
        return rangeQuery(1, L, R, x, y);
    }

    void rangeModify(int x, int y, Tag v) {
        rangeModify(1, L, R, x, y, v);
    }

private:
    std::vector<Info> info;
    std::vector<Tag> tag;
    int n, L, R;

    void pushUp(int p) {
        info[p] = info[p * 2] + info[p * 2 + 1];
    }

    void pushDown(int p) {
        info[p * 2].apply(tag[p]);
        info[p * 2 + 1].apply(tag[p]);
        tag[p * 2].apply(tag[p]);
        tag[p * 2 + 1].apply(tag[p]);
        tag[p] = Tag();
    }

    void indexAssign(int p, int l, int r, int x, Info v) {
        if (l == x && r == x) {
            info[p] = v;
            return;
        }
        pushDown(p);
        int mid = (l + r) / 2;
        if (x <= mid) {
            indexAssign(p * 2, l, mid, x, v);
        } else {
            indexAssign(p * 2 + 1, mid + 1, r, x, v);
        }
        pushUp(p);
    }

    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= x && r <= y) {
            return info[p];
        }
        pushDown(p);
        int mid = (l + r) / 2;
        if (y <= mid) {
            return rangeQuery(p * 2, l, mid, x, y);
        }
        if (x > mid) {
            return rangeQuery(p * 2 + 1, mid + 1, r, x, y);
        }
        return rangeQuery(p * 2, l, mid, x, y) + rangeQuery(p * 2 + 1, mid + 1, r, x, y);
    }

    void rangeModify(int p, int l, int r, int x, int y, Tag v) {
        if (l >= x && r <= y) {
            info[p].apply(v);
            tag[p].apply(v);
            return;
        }
        pushDown(p);
        int mid = (l + r) / 2;
        if (x <= mid) {
            rangeModify(p * 2, l, mid, x, y, v);
        }
        if (y > mid) {
            rangeModify(p * 2 + 1, mid + 1, r, x, y, v);
        }
        pushUp(p);
    }
};
```



### 技巧：递归 pushUp

[P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)

【题意】维护一个序列，多次操作：

- 单点修改（可加可减）；
- 查询整个序列中，有多少个元素严格大于它左边的所有元素。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;

    std::vector<int> ans(n * 4);
    std::vector<double> maxv(n * 4);

    auto query = [&](auto self, int p, int l, int r, double limit) -> double {
        if (maxv[p] <= limit) {
            return 0;
        }
        if (l == r) {
            return maxv[p] > limit;
        }
        int mid = (l + r) / 2;
        if (maxv[p * 2] <= limit) {
            return self(self, p * 2 + 1, mid + 1, r, limit);
        }
        return self(self, p * 2, l, mid, limit) + ans[p] - ans[p * 2];
    };

    auto modify = [&](auto self, int p, int l, int r, int x, double k) -> void {
        if (l == x && r == x) {
            ans[p] = 1;
            maxv[p] = k;
            return;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            self(self, p * 2, l, mid, x, k);
        } else {
            self(self, p * 2 + 1, mid + 1, r, x, k);
        }
        maxv[p] = std::max(maxv[p * 2], maxv[p * 2 + 1]);
        ans[p] = ans[p * 2] + query(query, p * 2 + 1, mid + 1, r, maxv[p * 2]);
    };

    std::vector<double> a(n + 1);
    while (q--) {
        int x, y;
        std::cin >> x >> y;
        modify(modify, 1, 1, n, x, 1.0 * y / x);
        std::cout << ans[1] << "\n";
    }

    return 0;
}
```



### 简单线段树

简单加法线段树

[P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

- 区间加法
- 区间求和

```cpp
template<int MAXN>
struct SegTree {
    std::array<int, MAXN> sum, tag;
    void build(int p, int l, int r, std::vector<int> &init_) {
        if (l == r) {
            sum[p] = init_[l];
            return;
        }
        int mid = (l + r) / 2;
        build(p * 2, l, mid, init_);
        build(p * 2 + 1, mid + 1, r, init_);
        pushUp(p);
    }
    void pushUp(int p) {
        sum[p] = sum[p * 2] + sum[p * 2 + 1];
    }
    void pushDown(int p, int l, int r) {
        if (tag[p] == 0) {
            return;
        }
        int mid = (l + r) / 2;
        sum[p * 2] += (mid - l + 1) * tag[p];
        sum[p * 2 + 1] += (r - mid) * tag[p];
        tag[p * 2] += tag[p];
        tag[p * 2 + 1] += tag[p];
        tag[p] = 0;
    }
    int RangeSum(int p, int l, int r, int x, int y) {
        if (l > y || r < x) {
            return 0;
        }
        if (x <= l && r <= y) {
            return sum[p];
        }
        pushDown(p, l, r);
        int mid = (l + r) / 2;
        return RangeSum(p * 2, l, mid, x, y) + RangeSum(p * 2 + 1, mid + 1, r, x, y);
    }
    void RangeAdd(int p, int l, int r, int x, int y, int k) {
        if (l > y || r < x) {
            return;
        }
        if (x <= l && r <= y) {
            sum[p] += (r - l + 1) * k;
            tag[p] += k;
            return;
        }
        pushDown(p, l, r);
        int mid = (l + r) / 2;
        RangeAdd(p * 2, l, mid, x, y, k);
        RangeAdd(p * 2 + 1, mid + 1, r, x, y, k);
        pushUp(p);
    }
};
```



简单 01 线段树

- 区间赋值 0/1
- 区间求和

```cpp
struct SegmentTree {
	struct Info {
		int sum = 0, tag = -1;
	};
	vector<Info> info;
	SegmentTree(int n): info(n * 4) {}
	void pushup(int p) {
		info[p].sum = info[ls(p)].sum + info[rs(p)].sum;
	}
	void pushdown(int p, int l, int r) {
		if (info[p].tag == -1) {
			return;
		}
		int mid = (r + l) >> 1;
		info[ls(p)] = {(mid - l + 1) * info[p].tag, info[p].tag};
		info[rs(p)] = {(r - mid) * info[p].tag, info[p].tag};
		info[p].tag = -1;
		assert(info[p].sum >= 0);
		assert(info[ls(p)].sum >= 0);
		assert(info[rs(p)].sum >= 0);
	}
	void build(int p, int l, int r, vector<int> &a) {
		if (l == r) {
			info[p].sum = a[l];
			return;
		}
		int mid = (l + r) >> 1;
		build(ls(p), l, mid, a);
		build(rs(p), mid + 1, r, a);
		pushup(p);
	}
	void modify(int p, int l, int r, int x, int y, int k) {
		if (x > y) {	// 这个判断不能忘，否则会 RE
			return;
		}
		if (x <= l && r <= y) {
			info[p].sum = (r - l + 1) * k;
			info[p].tag = k;
			return;
		}
		int mid = (l + r) >> 1;
		pushdown(p, l, r);
		if (x <= mid) {
			modify(ls(p), l, mid, x, y, k);
		}
		if (y > mid) {
			modify(rs(p), mid + 1, r, x, y, k);
		}
		pushup(p);
		assert(info[p].sum >= 0);
	}
	int qsum(int p, int l, int r, int x, int y) {
		if (x <= l && r <= y) {
			return info[p].sum;
		}
		int mid = (l + r) >> 1, ans = 0;
		pushdown(p, l, r);
		if (x <= mid) {
			ans += qsum(ls(p), l, mid, x, y);
		}
		if (y > mid) {
			ans += qsum(rs(p), mid + 1, r, x, y);
		}
		return ans;
	}
};
```





## 李超线段树（不会）





## 区间最值和历史最值（不会）







## 动态开点线段树：分裂与合并

注意事项：

- 如果有区间为负数的情形，递归过程中的 `mid` 必须定义为 `int mid = ((l + r) >> 1); `，而不能定义为 `int mid = (l + r) / 2;`
- 空间能开多大就开多大。

[P5494 【模板】线段树分裂](https://www.luogu.com.cn/problem/P5494)

【题意】

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

- `0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。
- `1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

- `2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

- `3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。
- `4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

【题解】

```cpp
#include <bits/stdc++.h>
#define int long long

struct Node {
    int sum = 0;
    Node *ls = nullptr, *rs = nullptr;
    void pushUp() {
        sum = (ls ? ls->sum : 0) + (rs ? rs->sum : 0);
    }
};

struct DynamicSegmentTree {
    // 将给定序列建成线段树
    Node *build(int l, int r, std::vector<int> &a) {
        Node *p = new Node;
        if (l == r) {
            p->sum = a[l];
            return p;
        }
        int mid = (l + r) / 2;
        p->ls = build(l, mid, a);
        p->rs = build(mid + 1, r, a);
        p->pushUp();
        return p;
    }

    // 线段树分裂
    Node *split(Node *&p, int l, int r, int x, int y) {
        if (p == nullptr || x > r || y < l) {
            return nullptr;
        } 
        if (l >= x && r <= y) {
            auto res = p;
            p = nullptr;
            return res;
        }
        Node *res = new Node;
        int mid = (l + r) / 2;
        res->ls = split(p->ls, l, mid, x, y);
        res->rs = split(p->rs, mid + 1, r, x, y);
        p->pushUp();
        res->pushUp();
        return res;
    }

    // 合并两棵线段树
    Node *merge(Node *p1, Node *p2, int l, int r) {
        if (p1 == nullptr) {
            return p2;
        }
        if (p2 == nullptr) {
            return p1;
        }
        if (l == r) {
            p1->sum += p2->sum;
            delete p2;
            return p1;
        }
        int mid = (l + r) / 2;
        p1->ls = merge(p1->ls, p2->ls, l, mid);
        p1->rs = merge(p1->rs, p2->rs, mid + 1, r);
        p1->pushUp();
        delete p2;
        return p1;
    }

    // 单点修改
    Node *indexInc(Node *p, int l, int r, int x, int k) {
        if (p == nullptr) {
            p = new Node;
        }
        if (l == x && r == x) {
            p->sum += k;
            return p;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            p->ls = indexInc(p->ls, l, mid, x, k);
        } else {
            p->rs = indexInc(p->rs, mid + 1, r, x, k);
        }
        p->pushUp();
        return p;
    }

    // 查询区间和
    int query(Node *p, int l, int r, int x, int y) {
        if (p == nullptr) {
            return 0;
        }
        if (l >= x && r <= y) {
            return p->sum;
        }
        int mid = (l + r) / 2, res = 0;
        if (x <= mid) {
            res += query(p->ls, l, mid, x, y);
        }
        if (y > mid) {
            res += query(p->rs, mid + 1, r, x, y);
        }
        return res;
    }

    // 查询全局第 k 小
    int k_th(Node *p, int l, int r, int k) {
        if (p->sum < k) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        int mid = (l + r) >> 1;
        if (p->ls && p->ls->sum >= k) {
            return k_th(p->ls, l, mid, k);
        } else {
            return k_th(p->rs, mid + 1, r, k - (p->ls ? p->ls->sum : 0));
        }
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m;
    std::cin >> n >> m;
    std::vector<Node*> root(m + 2);
    std::vector<int> a(n + 1);

    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }
    int segcnt = 0;
    DynamicSegmentTree tr;
    root[++segcnt] = tr.build(1, n, a);

    for (int i = 1; i <= m; i++) {
        int op;
        std::cin >> op;
        if (op == 0) {
            int p, x, y;
            std::cin >> p >> x >> y;
            root[++segcnt] = tr.split(root[p], 1, n, x, y);
        }
        if (op == 1) {
            int p, t;
            std::cin >> p >> t;
            tr.merge(root[p], root[t], 1, n);
        }
        if (op == 2) {
            int p, k, x;
            std::cin >> p >> k >> x;
            tr.indexInc(root[p], 1, n, x, k);
        }
        if (op == 3) {
            int p, x, y;
            std::cin >> p >> x >> y;
            std::cout << tr.query(root[p], 1, n, x, y) << "\n";
        }
        if (op == 4) {
            int p, k;
            std::cin >> p >> k;
            std::cout << tr.k_th(root[p], 1, n, k) << "\n";
        }
    }
    return 0;
}
```



## 扫描线

[P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

求 $n$ 个四边平行于坐标轴的矩形的面积并。

```c++
#include <bits/stdc++.h>

using i64 = long long;

/**
 * @attention 本题的特殊性：保证了所有的正线段都存在对称的负线段。
*/
struct SegmentTree {
    struct Info {
        // sum:被覆盖部分的长度，len:区间总长度，cnt:区间被完整覆盖的次数
        bool leaf = false;
        int sum = 0, len = 0, cnt = 0;
    };
    std::vector<Info> info;
    int n;

    SegmentTree(std::vector<int> &a) {
        int n = a.size() - 1;
        info.assign(n * 4, Info());

        auto build = [&](auto self, int p, int l, int r, std::vector<int> &a) -> void {
            if (l == r) {
                info[p].leaf = true;
                info[p].len = a[l];
                return;
            }
            int mid = (l + r) / 2;
            self(self, p * 2, l, mid, a);
            self(self, p * 2 + 1, mid + 1, r, a);
            info[p].len = info[p * 2].len + info[p * 2 + 1].len;
        };

        build(build, 1, 1, n, a);
    }

    void pushUp(int p) {
        if (info[p].leaf) {
            if (info[p].cnt > 0) {
                info[p].sum = info[p].len;
            } else {
                info[p].sum = 0;
            }
            return;
        }
        if (info[p].cnt > 0) {
            info[p].sum = info[p * 2].len + info[p * 2 + 1].len;
        } else {
            info[p].sum = info[p * 2].sum + info[p * 2 + 1].sum;
        }
    }

    void modify(int p, int l, int r, int x, int y, int k) {
        if (x <= l && r <= y) {
            info[p].cnt += k;
            pushUp(p);
            return;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            modify(p * 2, l, mid, x, y, k);
        }
        if (y > mid) {
            modify(p * 2 + 1, mid + 1, r, x, y, k);
        }
        pushUp(p);
    }

    int query() {
        return info[1].sum;
    }
};

struct Line {
    int x, y1, y2, type;
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector<Line> line;
    std::vector<int> value; // 用来离散化

    for (int i = 1; i <= n; i++) {
        int x1, y1, x2, y2;
        std::cin >> x1 >> y1 >> x2 >> y2;
        line.push_back({x1, y1, y2, 1});
        line.push_back({x2, y1, y2, -1});

        value.push_back(y1);
        value.push_back(y2);
    }

    std::sort(value.begin(), value.end());
    value.erase(std::unique(value.begin(), value.end()), value.end());

    auto getVal = [&](int x) {
        return lower_bound(value.begin(), value.end(), x) - value.begin() + 1;
    };

    int m = value.size() - 1;
    std::vector<int> a(m + 1);
    for (int i = 1; i <= m; i++) {
        a[i] = value[i] - value[i - 1];
    }

    // 下面开始扫描线正文
    std::sort(line.begin(), line.end(), [](const Line &a, const Line &b) {
        return a.x < b.x;
    });
    SegmentTree tr(a);
    i64 ans = 0;

    for (int i = 0; i < line.size(); i++) {
        if (i > 0) {
            ans += 1LL * tr.query() * (line[i].x - line[i - 1].x);
        }
        tr.modify(1, 1, m, getVal(line[i].y1), getVal(line[i].y2) - 1, line[i].type);
    }
    std::cout << ans;

    return 0;
}
```



# Trie

## 普通 Trie

[P8306 【模板】字典树](https://www.luogu.com.cn/problem/P8306)

【题意】

给定 $n$ 个模式串 $s_1,s_2,...,s_n$。每次询问给出一个文本串 $t$，查询有多少模式串 $s_i$ 满足：文本串 $t$ 是 $s_i$ 的前缀。本题的字符串包含：大小写字母和阿拉伯数字。

【代码】

静态数组写法：

```cpp
#include <bits/stdc++.h>

int hash(char c) {
    if (isdigit(c)) return c - '0';
    if (islower(c)) return 10 + c - 'a';
    return 36 + c - 'A';
}

struct Trie {
    struct Node {
        int cnt = 0;            // 记录有多少个串经过这个点
        int ch[65] = {};
    };

    int nodecnt = 1;            // 1 是根节点
    std::vector<Node> node = {Node(), Node()};

    int newNode() {
        node.emplace_back(Node());
        return ++nodecnt;
    }

    void insert(std::string &s) {
        int p = 1;
        node[p].cnt += 1;
        for (int i = 0; i < s.length(); i++) {
            int c = hash(s[i]);
            if (!node[p].ch[c]) {
                node[p].ch[c] = newNode();
            }
            p = node[p].ch[c];
            node[p].cnt += 1;
        }
    }

    int askPrifix(std::string &s) {
        int p = 1;
        for (int i = 0; i < s.length(); i++) {
            int c = hash(s[i]);
            p = node[p].ch[c];
            if (p == 0) {
                break;
            }
        }
        return node[p].cnt;
    }
};

void solve() {
    int n, q;
    std::cin >> n >> q;

    Trie tr;
    for (int i = 1; i <= n; i++) {
        std::string s;
        std::cin >> s;
        tr.insert(s);
    }
    for (int i = 1; i <= q; i++) {
        std::string s;
        std::cin >> s;
        std::cout << tr.askPrifix(s) << "\n";
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int T;
    std::cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```



指针写法：

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int hash(char c) {
    if (isdigit(c)) return c - '0';
    if (islower(c)) return 10 + c - 'a';
    return 36 + c - 'A';
}

struct Trie {
    struct Node {
        int cnt = 0, end = 0;
        std::array<Node *, 65> ch = {};
    };

    Node *root = new Node;

    ~Trie() {
        auto clear = [&](auto self, Node *&t) -> void {
            for (auto p : t->ch) {
                if (p != nullptr) {
                    self(self, p);
                }
            }
            delete(t);
            t = nullptr;
        };
        clear(clear, root);
    }

    void insert(std::string &s) {
        auto p = root;
        root->cnt += 1;
        for (int i = 0; i < s.length(); i++) {
            int c = hash(s[i]);
            if (p->ch[c] == nullptr) {
                p->ch[c] = new Node;
            }
            p = p->ch[c];
            p->cnt += 1;
        }
        p->end += 1;
    }

    int askPrefix(std::string &s) {
        auto p = root;
        for (int i = 0; i < s.length(); i++) {
            int c = hash(s[i]);
            p = p->ch[c];
            if (p == nullptr) {
                break;
            }
        }
        return p == nullptr ? 0 : p->cnt;
    }
};

void solve() {
    int n, q;
    std::cin >> n >> q;

    Trie tr;
    for (int i = 1; i <= n; i++) {
        std::string s;
        std::cin >> s;
        tr.insert(s);
    }
    for (int i = 1; i <= q; i++) {
        std::string s;
        std::cin >> s;
        std::cout << tr.askPrefix(s) << "\n";
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```



## 01 Trie

主要用于：维护一个集合 $S$，实现：

- 向 $S$ 中插入一个数字；
- 对于给定的数字 $x$，查询 $S$ 中的元素异或 $x$ 的最大值。

[The XOR Largest Pair](https://ac.nowcoder.com/acm/contest/1010/B)

【题意】在给定的 $n$ 个整数 $a_1,...,a_n$ 中选出两个进行 $\operatorname {xor}$ 运算，求得到的最大结果。

静态数组写法：

```cpp
#include <bits/stdc++.h> 

const int MAXN = 2e6;

struct Trie {
    struct Node {
        int ch[2] = {0, 0};
        int cnt = 0;
    };
    static const int M = 31;    // 数据不会超过 2^32
    int root = 1, nodecnt = 1;
    std::array<Node, MAXN> node;
    
    void insert(int x) {        // 向 trie 中插入一个值
        int now = root;
        for (int i = M - 1; i >= 0; i--) {
            int t = (1 & (x >> i));
            if (!node[now].ch[t]) {
                node[now].ch[t] = ++nodecnt;
            }
            node[now].cnt++;
            now = node[now].ch[t];
        }
        node[now].cnt++;
    }
    int ask(int x) {            // 查询 trie 中的值与 x 异或的最大结果
        int ans = 0, now = root;
        for (int i = M - 1; i >= 0; i--) {
            int t = (1 & (x >> i));
            if (node[now].ch[t ^ 1] > 0) {
                t ^= 1;
            }
            ans += t * (1ll << i);
            now = node[now].ch[t];
        }
        return ans ^ x;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, ans = 0;
    Trie tr;
    std::cin >> n;

    for (int i = 1; i <= n; i++) {
        int x;
        std::cin >> x;
        tr.insert(x);
        ans = std::max(ans, tr.ask(x));
    }
    std::cout << ans << "\n";

    return 0;
}
```

指针写法：

```cpp
#include <bits/stdc++.h> 

struct Trie {
    struct Node {
        Node *ch[2] = {nullptr, nullptr};
        int cnt = 0;
    };
    static const int M = 31;    // 数据不会超过 2^32
    Node *root = new Node();
    
    void insert(int x) {        // 向 trie 中插入一个值
        Node *now = root;
        for (int i = M - 1; i >= 0; i--) {
            int t = (1 & (x >> i));
            if (now->ch[t] == nullptr) {
                now->ch[t] = new Node();
            }
            now->cnt++;
            now = now->ch[t];
        }
        now->cnt++;
    }
    
    int ask(int x) {            // 查询 trie 中的值与 x 异或的最大结果
        assert(root->cnt > 0);
        int ans = 0;
        Node *now = root;
        for (int i = M - 1; i >= 0; i--) {
            int t = (1 & (x >> i));
            if (now->ch[t ^ 1] != nullptr) {
                t ^= 1;
            }
            ans += t * (1ll << i);
            now = now->ch[t];
        }
        return ans ^ x;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, ans = 0;
    Trie tr;
    std::cin >> n;

    for (int i = 1; i <= n; i++) {
        int x;
        std::cin >> x;
        tr.insert(x);
        ans = std::max(ans, tr.ask(x));
    }
    std::cout << ans << "\n";

    return 0;
}
```

相关例题

- [P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551) 给一棵带边权的树，求树上所有路径的最大异或和



# 可持久化

数组写法的时间空间都略优于指针写法，前提是空间开的比较精确。但是问题在于通常情况下很难准确计算应该开多大空间。

指针写法的优点在于不需要考虑开多大空间，并且写起来比较优雅。



## 可持久化数组

[P3919 【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919)

维护一个长度为 $n$ 的数组，支持操作：


1. 在某个历史版本上修改某一个位置上的值，生成一个新的版本

2. 访问某个历史版本上的某一位置的值，复制该版本为一个新的版本

```cpp
#include <bits/stdc++.h>

#define int long long
const int N = 3e7 + 7;

struct Segs {
    struct Node {
        int l, r, val;
    };
    
    int cnt = 0;
    std::array<Node, N> node;

    int build(std::vector<int> &a, int l, int r) {
        int rt = ++cnt;
        if (l == r) {
            node[rt].val = a[l];
            return rt;
        }
        int mid = (l + r) >> 1;
        node[rt] = {build(a, l, mid), build(a, mid + 1, r), 0};
        return rt;
    }

    int modify(int p, int l, int r, int x, int k) {
        int rt = ++cnt;
        node[rt] = {node[p].l, node[p].r, k};
        if (l == r) {
            return rt;
        }
        int mid = (l + r) >> 1;
        if (x <= mid) {
            node[rt].l = modify(node[p].l, l, mid, x, k);
        } else {
            node[rt].r = modify(node[p].r, mid + 1, r, x, k);
        }
        return rt;
    }

    int query(int p, int l, int r, int x) {
        if (l == r) {
            return node[p].val;
        }
        int mid = (l + r) >> 1;
        if (x <= mid) {
            return query(node[p].l, l, mid, x);
        } else {
            return query(node[p].r, mid + 1, r, x);
        }
    }
} seg;

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }
    std::vector<int> root(q + 1);
    root[0] = seg.build(a, 1, n);
    for (int i = 1; i <= q; i++) {
        int op, p, x, k;
        std::cin >> p >> op >> x;
        if (op == 1) { // 在版本 p 的基础上，a[x] 修改为 k
            std::cin >> k;
            root[i] = seg.modify(root[p], 1, n, x, k);
        } else {
            std::cout << seg.query(root[p], 1, n, x) << "\n";
            root[i] = root[p];
        }
    }

    return 0;
}
```



## 可持久化权值线段树

### 区间第 $k$ 小

[P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834) 给定序列，每次查询区间内第 $k$ 小。

关键是定义一个空节点：

```cpp
    std::vector<Node*> root(n + 1);
    Node *zero = new Node({});
    zero->l = zero->r = zero;
    root[0] = zero;
```

这样能避免空指针的问题。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

struct Node {
    Node *l = nullptr, *r = nullptr;
    int sum = 0;
    Node(Node *t) {
        if (t) {
            *this = *t;
        }
    }
};

Node *add(Node *t, int l, int r, int x, int k) {
    t = new Node(t);
    t->sum += k;
    if (l == r) {
        return t;
    }
    int mid = (l + r) / 2;
    if (x <= mid) {
        t->l = add(t->l, l, mid, x, k);
    } else {
        t->r = add(t->r, mid + 1, r, x, k);
    }
    return t;
}

int query(Node *t1, Node *t2, int l, int r, int k) {
    if (l == r) {
        return l;
    }
    int mid = (l + r) / 2;
    int cnt = t2->l->sum - t1->l->sum;
    if (cnt >= k) {
        return query(t1->l, t2->l, l, mid, k);
    } else {
        return query(t1->r, t2->r, mid + 1, r, k - cnt);
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    auto vala = a;
    std::sort(vala.begin() + 1, vala.end());
    vala.erase(std::unique(vala.begin() + 1, vala.end()), vala.end());
    for (int i = 1; i <= n; i++) {
        a[i] = std::lower_bound(vala.begin() + 1, vala.end(), a[i]) - vala.begin();
    }

    std::vector<Node*> root(n + 1);
    Node *zero = new Node({});
    zero->l = zero->r = zero;
    root[0] = zero;

    for (int i = 1; i <= n; i++) {
        root[i] = add(root[i - 1], 1, n, a[i], 1);
    }

    for (int i = 1; i <= q; i++) {
        int l, r, k;
        std::cin >> l >> r >> k;
        int ans = query(root[l - 1], root[r], 1, n, k);
        std::cout << vala[ans] << "\n";
    }

    return 0;
}
```



### 区间不同值的个数

[[SDOI2009] HH的项链](https://ac.nowcoder.com/acm/problem/20325) 给定序列，每次查询某个区间内有多少不同的值。

```cpp
#include <bits/stdc++.h>

struct Node {
    Node *l = nullptr, *r = nullptr;
    int sum = 0;
    Node(Node *t = nullptr) {
        if (t != nullptr) {
            *this = *t;
        }
    }
};

Node *add(Node *t, int l, int r, int x, int k) {
    t = new Node(t);
    t->sum += k;
    if (l == r) {
        return t;
    }
    int mid = (l + r) / 2;
    if (x <= mid) {
        t->l = add(t->l, l, mid, x, k);
    } else {
        t->r = add(t->r, mid + 1, r, x, k);
    }
    return t;
}

int query(Node *t, int l, int r, int x, int y) {
    if (t == nullptr) {
        return 0;
    }
    if (l >= x && r <= y) {
        return t->sum;
    }
    int mid = (l + r) / 2, res = 0;
    if (x <= mid) {
        res += query(t->l, l, mid, x, y);
    } 
    if (y > mid) {
        res += query(t->r, mid + 1, r, x, y);
    }
    return res;
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n;
    std::vector<int> a(n + 1), pre(1000007);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    std::vector<Node *> root(n + 1);
    Node *zero = new Node;
    zero->l = zero->r = zero;
	root[0] = zero;

    for (int i = 1; i <= n; i++) {
        root[i] = root[i - 1];
        if (pre[a[i]]) {
            root[i] = add(root[i], 1, n, pre[a[i]], -1); 
        }
        root[i] = add(root[i], 1, n, i, 1);
        pre[a[i]] = i;
    }

    std::cin >> q;
    for (int i = 1; i <= q; i++) {
        int l, r;
        std::cin >> l >> r;
        std::cout << query(root[r], 1, n, l, r) << "\n";
    }

    return 0;
}
```



### 区间 mex

[P4137 Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137) 给一个序列，每次查询区间 $\operatorname{mex}$（最小的没有出现的自然数）。

思路：对所有前缀分别维护一棵权值线段树，维护每一个权值最后一次出现的下标。每个版本实现单点修改，查询的值小于 $k$  的最小下标。 

```cpp
#include <bits/stdc++.h>

using i64 = long long;

struct Node {
    Node *l = nullptr, *r = nullptr;
    int minVal = 0;
    Node(Node *t = nullptr) {
        if (t != nullptr) {
            *this = *t;
        }
    }
    void pushUp() {
        if (l == nullptr && r == nullptr) {
            return;
        }
        minVal = 1e9;
        if (l != nullptr) {
            minVal = std::min(minVal, l->minVal);
        }
        if (r != nullptr) {
            minVal = std::min(minVal, r->minVal);
        }
    }
};

Node *insert(Node *t, int l, int r, int x, int k) {
    t = new Node(t);
    if (l == r) {
        t->minVal = k;
        return t;
    }
    int mid = (l + r) / 2;
    if (x <= mid) {
        t->l = insert(t->l, l, mid, x, k);
    } else {
        t->r = insert(t->r, mid + 1, r, x, k);
    }
    t->pushUp();
    return t;
}

int query(Node *t, int l, int r, int k) {
    if (l == r) {
        return l;
    }
    int mid = (l + r) / 2;
    if (t->l->minVal < k) {
        return query(t->l, l, mid, k);
    } else {
        return query(t->r, mid + 1, r, k);
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;

    std::vector<int> a(n + 1); 
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
        a[i] = std::min(a[i], n);
    }

    std::vector<Node *> root(n + 1);
    Node *zero = new Node;
    zero->l = zero->r = zero;
    root[0] = zero;

    for (int i = 1; i <= n; i++) {
        root[i] = insert(root[i - 1], 0, n, a[i], i);
    }
    while (q--) {
        int l, r;
        std::cin >> l >> r;
        std::cout << query(root[r], 0, n, l) << "\n";
    }

    return 0;
}
```



## 可持久化 01 Trie

[P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)

```cpp
#include <bits/stdc++.h>
#define int long long

const int N = 3e7 + 7;

struct Tries {
    struct Node {
        int tot = 0; 			// 记录有多少串经过该点
        int ch[2] = {};
    };
    int cnt = 0, M = 31;
    std::array<Node, N> node = {};

    int insert(int p, int x) {
        int rt = ++cnt, now = rt;
        for (int i = M; i >= 0; i--) {
            int t = (x >> i) & 1;
            node[now].ch[t] = ++cnt;
            if (p) {
                node[now].ch[t ^ 1] = node[p].ch[t ^ 1];
            }
            p = node[p].ch[t];
            now = node[now].ch[t];
            node[now].tot = node[p].tot + 1;
        }
        return rt;
    }
    int ask(int p1, int p2, int x) {
        int res = 0;
        for (int i = M; i >= 0; i--) {
            int t = (x >> i) & 1;
            if (node[node[p2].ch[t ^ 1]].tot - node[node[p1].ch[t ^ 1]].tot > 0) {
                res += 1 << i;
                p1 = node[p1].ch[t ^ 1];
                p2 = node[p2].ch[t ^ 1];
            } else {
                p1 = node[p1].ch[t];
                p2 = node[p2].ch[t];
            }
        }
        return res;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;
    n++;

    std::vector<int> a(n + q + 1), root(n + q + 1);
    Tries tr;
    root[0] = tr.insert(0, 0);
    root[1] = tr.insert(root[0], 0);
    for (int i = 2; i <= n; i++) {
        std::cin >> a[i];
        a[i] ^= a[i - 1];
        root[i] = tr.insert(root[i - 1], a[i]);
    }

    for (int i = 1; i <= q; i++) {
        std::string op;
        int l, r, x;
        std::cin >> op;
        if (op == "A") {
            std::cin >> a[++n];
            a[n] ^= a[n - 1];
            root[n] = tr.insert(root[n - 1], a[n]);
        } else {
            std::cin >> l >> r >> x;
            x ^= a[n];
            int ans = tr.ask(root[l - 1], root[r], x);
            std::cout << ans << "\n";
        }
    }

    return 0;
}
```



## 可持久化并查集

[P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)

【题意】

给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。

有 $m$ 次操作。操作分为 $3$ 种：

 - `1 a b` 合并 $a,b$ 所在集合；

 - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；

 - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。

【思路】

并查集的暴力合并复杂度是 $O(n^2)$。有两种方法可以将它的复杂度优化到 $O(n\log n)$。一种是路径压缩，一种是按秩合并（启发式合并，dsu）。

路径压缩是无法实现可持久化的，感性的理解是后面的合并操作可能会“抹掉”前面的合并信息。

所以采用按秩合并，即每次合并的方向都是将较小的集合合并到较大的集合上。

所以维护两个可持久化数组，分别记录每一个版本中：每一个点的 $fa$，以及每个点的子树大小。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define endl "\n"
/**********************  Core code begins  **********************/
const int N = 3e7 + 7;

struct Segs {
    struct Info {
        int l = 0, r = 0, val = 0;
    };
    int cnt = 0;
    array<Info, N> info = {};
    int build(vector<int> &a, int l, int r) {
        int rt = ++cnt;
        if (l == r) {
            info[rt].val = a[l];
            return rt;
        }
        int mid = (l + r) >> 1;
        info[rt] = {build(a, l, mid), build(a, mid + 1, r), 0};
        return rt;
    }
    int modify(int p, int l, int r, int x, int k) {
        int rt = ++cnt;
        info[rt] = {info[p].l, info[p].r, k};
        if (l == r) {
            return rt;
        }
        int mid = (l + r) >> 1;
        if (x <= mid) {
            info[rt].l = modify(info[p].l, l, mid, x, k);
        } else {
            info[rt].r = modify(info[p].r, mid + 1, r, x, k);
        }
        return rt;
    }
    int query(int p, int l, int r, int x) {
        if (l == r) {
            return info[p].val;
        }
        int mid = (l + r) >> 1;
        if (x <= mid) {
            return query(info[p].l, l, mid, x);
        } else {
            return query(info[p].r, mid + 1, r, x);
        }
    }
} fa, siz;

void SolveTest() {
    int n, q;
    cin >> n >> q;
    // 分别记录每一个版本的两棵主席树的根
    vector<int> root_fa(n + q + 1), root_size(n + q + 1);
    // 初始化版本 0
    vector<int> tmpfa(n + 1), tmpsiz(n + 1, 1);
    iota(tmpfa.begin(), tmpfa.end(), 0);
    root_fa[0] = fa.build(tmpfa, 1, n);
    root_size[0] = siz.build(tmpsiz, 1, n);

    // 并查集的查询过程，没有路径压缩
    auto find = [&](int x, int k) { 
        int y = fa.query(root_fa[k], 1, n, x);
        while (y != x) {
            x = y;
            y = fa.query(root_fa[k], 1, n, x);
        }
        return y;
    };

    for (int i = 1; i <= q; i++) {
        int op, x, y;
        cin >> op;
        if (op == 1) {
            cin >> x >> y;
            // 查询两个点的根节点，并判断是否在同一集合
            x = find(x, i - 1);
            y = find(y, i - 1);
            assert(x > 0 && y > 0);
            if (x == y) {
                root_fa[i] = root_fa[i - 1];
                root_size[i] = root_size[i - 1];    
                continue;
            }
            // 查询两个集合的大小，按秩合并
            int sizx = siz.query(root_size[i - 1], 1, n, x);
            int sizy = siz.query(root_size[i - 1], 1, n, y);
            if (sizx > sizy) { 
                swap(x, y);
            }
            root_fa[i] = fa.modify(root_fa[i - 1], 1, n, x, y);
            root_size[i] = siz.modify(root_size[i - 1], 1, n, y, sizx + sizy);
        } else if (op == 2) {
            int k;
            cin >> k;
            // 这个版本就是把第 k 个版本复制一遍
            root_fa[i] = root_fa[k];
            root_size[i] = root_size[k];
        } else {
            int x, y;
            cin >> x >> y;
            x = find(x, i - 1);
            y = find(y, i - 1);
            cout << (x == y) << endl;
            root_fa[i] = root_fa[i - 1];
            root_size[i] = root_size[i - 1];           
        }
    }
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T = 1;
    // cin >> T;
    for (int i = 1; i <= T; i++) {
        SolveTest();
    }
    return 0;
}
```



# 分块

## 懒标记

[数列分块入门 4](https://loj.ac/p/6280) 

【题意】区间加，区间求和。关键是给分块打懒标记的思想。

```cpp
#include <bits/stdc++.h>
#define int long long

struct Blo {
    int l, r;
    int sum = 0, tag = 0;
};

struct Blocks {
    std::vector<int> a, id;
    std::vector<Blo> b;
    int n, len;

    Blocks(std::vector<int> &_a) : a(_a), n(a.size() - 1) {
        len = sqrt(n) + 1;
        id.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            id[i] = (i + len - 1) / len;
        }
        b.resize(id[n] + 1);
        for (int i = 1; i <= n; i++) {
            b[id[i]].sum += a[i];
        }
        for (int i = 1; i <= id[n]; i++) {
            b[i].l = (i - 1) * len + 1;
            b[i].r = std::min(i * len, n);
        }
    }

    void modify(int l, int r, int k) {
        for (int i = l; i <= r && id[i] == id[l]; i++) {
            a[i] += k;
            b[id[i]].sum += k;
        }
        if (id[l] != id[r]) {
            for (int i = r; id[i] == id[r]; i--) {
                a[i] += k;
                b[id[i]].sum += k;
            }
        }
        for (int i = id[l] + 1; i < id[r]; i++) {
            b[i].tag += k;
            b[i].sum += (b[i].r - b[i].l + 1) * k;
        }
    }

    int query(int l, int r) {
        int res = 0;
        for (int i = l; i <= r && id[i] == id[l]; i++) {
            res += a[i] + b[id[i]].tag;
        }
        if (id[l] != id[r]) {
            for (int i = r; id[i] == id[r]; i--) {
                res += a[i] + b[id[i]].tag;
            }
        }
        for (int i = id[l] + 1; i < id[r]; i++) {
            res += b[i].sum;
        }
        return res;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    Blocks blo(a);

    for (int qq = 1; qq <= n; qq++) {
        int op, l, r, c;
        std::cin >> op >> l >> r >> c;
        if (op == 0) {
            blo.modify(l, r, c);
        } else {
            std::cout << blo.query(l, r) % (c + 1) << "\n";
        }
    }

    return 0;
}
```



## 块内重构

[数列分块入门 2](https://loj.ac/p/6278) 

【题意】区间加，区间查询小于 $x$ 的个数

【做法】查询时二分，修改时端点块暴力排序重构，中间块打懒标记。

```cpp
#include <bits/stdc++.h>
#define int long long

struct Blo {
    std::vector<int> vec;
    int l, r;               // 这个块维护区间的左右端点下标
    int tag = 0;    		// 加法懒标记
    int query(int k) {      // 查询块内小于 k 的值的个数
        return std::lower_bound(vec.begin(), vec.end(), k - tag) - vec.begin();
    }
};

struct Blocks {
    std::vector<int> a, id; // 原序列，下标所在的块号
    std::vector<Blo> b;
    int n, len;

    Blocks(std::vector<int> &_a): a(_a), n(a.size() - 1) {  // a 的下标从 1 开始
        len = sqrt(n) + 1;
        id.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            id[i] = (i + len - 1) / len;
        }
        b.resize(id[n] + 1);
        for (int i = 1; i <= id[n]; i++) {
            b[i].l = (i - 1) * len + 1;
            b[i].r = std::min(i * len, n);
            update(i);
        }
    }

    void update(int x) {    			    // 暴力重构块 x
        std::vector<int> tmp;
        for (int i = b[x].l; i <= b[x].r; i++) {
            tmp.push_back(a[i]);
        }
        sort(tmp.begin(), tmp.end());
        b[x].vec = std::move(tmp);  // 这里不要画蛇添足把 tag 清空
    }

    void modify(int l, int r, int k) {    // 将序列的区间 [l,r] 整体 +=k
        for (int i = l; i <= r && id[i] == id[l]; i++) {  
            a[i] += k;
        }
        update(id[l]);
        if (id[l] != id[r]) {                              
            for (int i = r; id[i] == id[r]; i--) {
                a[i] += k;
            }
            update(id[r]);
        }
        for (int i = id[l] + 1; i < id[r]; i++) {           
            b[i].tag += k;
        }
    }

    int query(int l, int r, int k) {    // 查询原序列 [l,r] 中小于 k 的数字个数
        int res = 0;
        for (int i = l; i <= r && id[i] == id[l]; i++) {    
            res += (a[i] + b[id[i]].tag < k);
        }
        if (id[l] != id[r]) {                             
            for (int i = r; id[i] == id[r]; i--) {
                res += (a[i] + b[id[i]].tag < k);
            }
        }
        for (int i = id[l] + 1; i < id[r]; i++) {              
            res += b[i].query(k);
        }
        return res;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    Blocks blo(a);

    for (int qq = 1; qq <= n; qq++) {
        int op, l, r, c;
        std::cin >> op >> l >> r >> c;
        if (op == 0) {
            blo.modify(l, r, c);
        } else {
            std::cout << blo.query(l, r, c * c) << "\n";
        }
    }

    return 0;
}
```



[数列分块入门 3](https://loj.ac/p/6279) 

【题意】区间加，区间查询比 $x$ 小的最大元素

【做法】本题也可以用上个题的方法，每块排序二分。这里采用另一种方法，用 set 辅助维护每个块。

```cpp
#include <bits/stdc++.h>
#define int long long

const int INF = 1e18;

struct Blo {
    std::set<int> st;
    int l, r;
    int tag = 0;
    int query(int k) {
        auto it = st.lower_bound(k - tag);
        if (it == st.begin()) {
            return -INF;
        }
        return *(std::prev(it)) + tag;
    }
};

struct Blocks {
    std::vector<int> a, id;
    std::vector<Blo> b;
    int n, len;

    Blocks(std::vector<int> &_a) : a(_a), n(a.size() - 1) {  // a 的下标从 1 开始
        len = sqrt(n) + 1;
        id.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            id[i] = (i + len - 1) / len;
        }
        b.resize(id[n] + 1);
        for (int i = 1; i <= id[n]; i++) {
            b[i].l = (i - 1) * len + 1;
            b[i].r = std::min(i * len, n);
            update(i);
        }
    }

    void update(int x) {
        std::set<int> st;
        for (int i = b[x].l; i <= b[x].r; i++) {
            st.insert(a[i]);
        }
        b[x].st = std::move(st);
    }

    void modify(int l, int r, int k) {    // 将序列的区间 [l,r] 整体 +=k
        for (int i = l; i <= r && id[i] == id[l]; i++) {
            a[i] += k;
        }
        update(id[l]);
        if (id[l] != id[r]) {
            for (int i = r; id[i] == id[r]; i--) {
                a[i] += k;
            }
            update(id[r]);
        }
        for (int i = id[l] + 1; i < id[r]; i++) {
            b[i].tag += k;
        }
    }

    int query(int l, int r, int k) {    // 查询原序列 [l,r] 中小于 k 的数字个数
        int res = -INF;
        for (int i = l; i <= r && id[i] == id[l]; i++) {
            int x = a[i] + b[id[i]].tag;
            if (x < k) {
                res = std::max(res, x);
            }
        }
        if (id[l] != id[r]) {
            for (int i = r; id[i] == id[r]; i--) {
                int x = a[i] + b[id[i]].tag;
                if (x < k) {
                    res = std::max(res, x);
                }
            }
        }
        for (int i = id[l] + 1; i < id[r]; i++) {
            res = std::max(res, b[i].query(k));
        }
        if (res == -INF) {
            return -1;
        }
        return res;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    Blocks blo(a);

    for (int qq = 1; qq <= n; qq++) {
        int op, l, r, c;
        std::cin >> op >> l >> r >> c;
        if (op == 0) {
            blo.modify(l, r, c);
        } else {
            std::cout << blo.query(l, r, c) << "\n";
        }
    }

    return 0;
}
```



# 莫队

## 普通莫队

[P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)

【题意】

给出一个大小为 $n$ 的序列 $a$。$m$ 次询问，每次查询 $[l,r]$ 的数字是否全部相同。$n \le 5\cdot 10^4$，$m \le 2 \cdot 10^5$，$0 \le a_i \le 10^6$。

【思路】

这里为了使用莫队，改为求求区间 $[l,r]$ 的不同数字个数。

```cpp
#include <bits/stdc++.h>
#define int long long

struct Query {
	int id, l, r;
};

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);

	int n, m;
	std::cin >> n >> m;
	std::vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		std::cin >> a[i];
	}

	std::vector<Query> qu(m);
	std::vector<std::string> ans(m);
	for (int i = 0; i < m; i++) {
		int l, r;
		std::cin >> l >> r;
		qu[i] = {i, l, r};
	}

	// 将询问分块并排序
	int blen = pow(n, 0.5) + 1;         
	std::vector<int> bloid(n + 1);
	for (int i = 1; i <= n; i++) {
		bloid[i] = (i + blen - 1) / blen;
	}
	std::sort(qu.begin() + 1, qu.end(), [&](auto a, auto b) {
		if (bloid[a.l] == bloid[b.l]) {
			return bloid[a.l] % 2 ? a.r < b.r : a.r > b.r;
		}
		return bloid[a.l] < bloid[b.l];
	});

	// 莫队所需的数据结构和三个函数
	int cnt[1000007] = {}, res = 0;
	auto add = [&](int x) {
		if (cnt[x] == 0) {
			res++;
		}
		cnt[x]++;
	};
	auto del = [&](int x) {
		cnt[x]--;
		if (cnt[x] == 0) {
			res--;
		}
	};
	auto getans = [&]() {
		return res;
	};

	// 莫队
	int l = 1, r = 0;
	for (int i = 0; i < m; i++) {
		auto [id, ql, qr] = qu[i];
		while (r < qr) {
			add(a[++r]);
		}
		while (r > qr) {
			del(a[r--]);
		}
		while (l > ql) {
			add(a[--l]);
		}
		while (l < ql) {
			del(a[l++]);
		}
		ans[id] = (getans() == qr - ql + 1 ? "Yes" : "No");
	}
	for (int i = 0; i < m; i++) {
		std::cout << ans[i] << "\n";
	}

	return 0;
}
```

PS：这里只是为了用莫队而用莫队，当然实际上有简单的 $O(n)$ 的做法：

- $last[i]$ 表示左边最近的与 $a[i]$ 相等的位置；
- $left[i]$ 表示 $last$ 的前缀最大值；
- 判断 $left[i] < l$ 是否成立即可。

```cpp
#include <bits/stdc++.h>
#define int long long

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

	int n, m;
	std::cin >> n >> m;
	std::vector<int> pos(n + 1), last(n + 1), left(n + 1);

	for (int i = 1; i <= n; i++) {
		int x;
		std::cin >> x;
		left[i] = pos[x];
		pos[x] = i;
		last[i] = std::max(last[i - 1], left[i]);
	}

	for (int i = 1; i <= m; i++) {
		int l, r;
		std::cin >> l >> r;
		std::cout << (last[r] < l ? "Yes" : "No") << "\n";
	}

    return 0;
}
```



## 树上莫队

[nc227884. 树上莫队模板题](https://ac.nowcoder.com/acm/problem/227884)

【题意】

给一棵树，包含 $n$ 个点，每个点有点权 $a$。$m$ 次询问，每次查询两点间颜色种类数。

```cpp
#include <bits/stdc++.h>
#define int long long

struct Query {
	int l, r, lca, id;
};

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);

	int n, q;
	std::cin >> n;

	std::vector<std::vector<int>> adj(n + 1);
	std::vector<int> col(n + 1);
	for (int i = 1; i <= n; i++) {
		std::cin >> col[i];
	}

	// 离散化
	auto tmp = col;
	std::sort(tmp.begin() + 1, tmp.end());
	for (int i = 1; i <= n; i++) {
		col[i] = lower_bound(tmp.begin() + 1, tmp.end(), col[i]) - tmp.begin();
	}

	for (int i = 1; i < n; i++) {
		int u, v;
		std::cin >> u >> v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	std::vector<int> euler(2 * n + 1), in(2 * n + 1), out(2 * n + 1), pos(2 * n + 1);	// 欧拉序相关
	std::vector<int> wson(n + 1), siz(n + 1), top(n + 1), fa(n + 1), dep(n + 1);		// lca 相关
	int eucnt = 0;

	std::function<void(int, int)> dfs1 = [&](int u, int pa) {
		siz[u] = 1;
		fa[u] = pa;
		dep[u] = dep[pa] + 1;
		euler[++eucnt] = u;
		in[u] = eucnt;
		for (int v : adj[u]) {
			if (v == pa) {
				continue;
			}
			dfs1(v, u);
			siz[u] += siz[v];
			if (wson[u] == 0 || siz[v] > siz[wson[u]]) {
				wson[u] = v;
			}
		}
		euler[++eucnt] = u;
		out[u] = eucnt;
	};

	std::function<void(int, int)> dfs2 = [&](int u, int topf) {
		top[u] = topf;
		if (wson[u]) {
			dfs2(wson[u], topf);
		}
		for (int v : adj[u]) {
			if (v != wson[u] && v != fa[u]) {
				dfs2(v, v);
			}
		}
	};

	dfs1(1, 0);
	dfs2(1, 1);

	auto lca = [&](int x, int y) {
		while (top[x] != top[y]) {
			if (dep[top[x]] < dep[top[y]]) {
				std::swap(x, y);
			}
			x = fa[top[x]];
		}
		if (dep[x] > dep[y]) {
			std::swap(x, y);
		}
		return x;
	};

    std::cin >> q;
	std::vector<Query> qu(q + 1);
	std::vector<int> ans(q + 1);

	for (int i = 1; i <= q; i++) {
		int u, v;
		std::cin >> u >> v;
		if (in[u] > in[v]) {
			std::swap(u, v);
		}
		int _lca = lca(u, v);
		if (_lca == u) {
			qu[i] = {in[u], in[v], 0, i};
		} else {
			qu[i] = {out[u], in[v], _lca, i};
		}
	}

	int blen = sqrt(n * 2);		// 块长
	auto getid = [&](int x) {	// 求块编号
		return x / blen;
	};

	std::sort(qu.begin() + 1, qu.end(), [&](auto x, auto y) {
		if (getid(x.l) == getid(y.l)) {
			return x.r < y.r;
		}
		return getid(x.l) < getid(y.l);
	});

	// 准备莫队
    const int M = 1e6 + 7;
	std::vector<int> cnt(n * 2 + 1), used(n * 2 + 1);
	int res = 0;
	auto add = [&](int pos) {
		res += (++cnt[col[pos]] == 1);
	};
	auto del = [&](int pos) {
		res -= (--cnt[col[pos]] == 0);
	};
	auto cal = [&](int pos) {
		if (!used[pos]) {
			add(pos);
		} else {
			del(pos);
		}
		used[pos] ^= 1;
	};

	// 开始莫队
	int l = 1, r = 0;
	for (int i = 1; i <= q; i++) {
		int ql = qu[i].l, qr = qu[i].r, id = qu[i].id;
		while (l > ql) {
			cal(euler[--l]);
		}
		while (l < ql) {
			cal(euler[l++]);
		}
		while (r > qr) {
			cal(euler[r--]);
		}
		while (r < qr) {
			cal(euler[++r]);
		}
		if (qu[i].lca) {
			cal(qu[i].lca);
		}
		ans[id] = res;
		if (qu[i].lca) {
			cal(qu[i].lca);
		}
	}
	for (int i = 1; i <= q; i++) {
		std::cout << ans[i] << "\n";
	}
	return 0;
}
```





## 带修莫队

[P1903 [国家集训队] 数颜色 / 维护队列](https://www.luogu.com.cn/problem/P1903)

【题意】

给出一个大小为 $n$ 的序列 $a$。$m$ 次询问，每次操作有两种：

- 查询 $[l,r]$ 的不同数字个数；
- 将 $a_p$ 修改为 $c$。

$n \le 1.4 \cdot 10^5$，$1 \le a_i \le 10^6$。

【代码】

要注意块长的设置。块长为 $\sqrt n$ 就会 T，设为 $n^{\frac{3}{4}}$ 就跑的飞快。

```cpp
#include <bits/stdc++.h>
#define int long long
const int MAXN = 1e6 + 7;

struct Query {
	int id, l, r, t;
};
struct Modify {
	int pos, col;
};

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);

	int n, m;
	std::cin >> n >> m;
	std::vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		std::cin >> a[i];
	}

	std::vector<Query> qu;
	std::vector<Modify> mo(1); 		// 这里很重要，要空出 mo[0]
	for (int i = 1; i <= m; i++) {
		std::string op;
		int l, r;
		std::cin >> op >> l >> r;
		if (op == "Q") {
			qu.push_back({(int)qu.size(), l, r, (int)mo.size() - 1});
		} else {
			mo.push_back({l, r});
		}
	}

	int blen = pow(n, 0.75);
	auto getid = [&](int x) {
		return x / blen;
	};

	std::sort(qu.begin(), qu.end(), [&](auto a, auto b) {
		if (getid(a.l) != getid(b.l)) {
			return getid(a.l) < getid(b.l);
		}
		if (getid(a.r) != getid(b.r)) {
			return getid(a.r) < getid(b.r);
		}
		return a.t < b.t;
	});

	// 准备莫队
	int cnt[MAXN] = {}, res = 0;
	std::vector<int> ans(qu.size());

	auto add = [&](int x) {
		if (cnt[x] == 0) {
			res++;
		}
		cnt[x]++;
	};
	auto del = [&](int x) {
		cnt[x]--;
		if (cnt[x] == 0) {
			res--;
		}
	};
	auto getans = [&]() {
		return res;
	};
	
	// 开始莫队
	int l = 1, r = 0, t = 0;
	for (int i = 0; i < qu.size(); i++) {
		auto [id, ql, qr, tm] = qu[i];
        while (r < qr) {
            add(a[++r]);
        }
        while (r > qr) {
            del(a[r--]);
        }
        while (l > ql) {
            add(a[--l]);
        }
        while (l < ql) {
            del(a[l++]);
        }
		auto work = [&]() {
			if (mo[t].pos >= l && mo[t].pos <= r) {
				del(a[mo[t].pos]);
				add(mo[t].col);
			}
			std::swap(a[mo[t].pos], mo[t].col);
		};
		while (t < tm) {
			t++;
			work();
		}
		while (t > tm) {
			work();
			t--;
		}
		ans[id] = res;
	}
	for (int x : ans) {
		std::cout << x << "\n";
	}

	return 0;
}
```



## 回滚莫队

[P5906 【模板】回滚莫队&不删除莫队](https://www.luogu.com.cn/problem/P5906)

```cpp
#include <bits/stdc++.h>
#define int long long

struct Query {
	int id, l, r;
};

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);

	// a 的输入和离散化
	int n, m;
	std::cin >> n;
	std::vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		std::cin >> a[i];
	}
	auto tmpa = a;
	sort(tmpa.begin() + 1, tmpa.end());
	tmpa.erase(std::unique(tmpa.begin() + 1, tmpa.end()), tmpa.end());
	for (int i = 1; i <= n; i++) {
		a[i] = lower_bound(tmpa.begin() + 1, tmpa.end(), a[i]) - tmpa.begin();
	}

	// 询问的输入和排序，与普通莫队没有区别
	std::cin >> m;
	std::vector<Query> qu(m + 1);
	std::vector<int> ans(m + 1);

	for (int i = 1; i <= m; i++) {
		int l, r;
		std::cin >> l >> r;
		qu[i] = {i, l, r};
	}

	int blen = sqrt(n) + 1;
	auto getid = [&](int x) {
		return (x + blen - 1) / blen;
	};

	std::sort(qu.begin() + 1, qu.end(), [&](auto a, auto b) {
		if (getid(a.l) != getid(b.l)) {
			return getid(a.l) < getid(b.l);
		}
		return a.r < b.r;
	});

	// 在莫队的过程中，记录某个值最左的出现位置，最右的出现位置
	std::vector<int> lpos(n + 1), rpos(n + 1);

    // j 枚举询问左端点块号，i 记录询问编号
	for (int j = 1, i = 1; j <= getid(n); j++) {		
		int br = std::min(n, j * blen);		// br 是当前块的右边界
		int l = br + 1, r = l - 1, res = 0;
		for (; getid(qu[i].l) == j; i++) {

			// 如果询问的左右端点在同一个块内，就暴力统计答案
			if (getid(qu[i].r) == j) {
				int res = 0;
				std::unordered_map<int, int> last;
				for (int k = qu[i].l; k <= qu[i].r; k++) {
					if (!last[a[k]]) {
						last[a[k]] = k;
					} else {
						res = std::max(res, k - last[a[k]]);
					}
				}
				ans[qu[i].id] = res;
				continue;
			}

			// r 向右延申，l 向左延申
			while (r < qu[i].r) {
				r++;
				rpos[a[r]] = r;
				if (lpos[a[r]] == 0) {
					lpos[a[r]] = r;
				}
				res = std::max(res, r - lpos[a[r]]);
			}
			int tp = res;			// r不回滚，l回滚，所以把右边的答案存下来
			while (l > qu[i].l) {
				l--;
				if (rpos[a[l]]) {
					res = std::max(res, rpos[a[l]] - l);
				} else {
					rpos[a[l]] = l;
				}
			}
			ans[qu[i].id] = res;

			// “回滚” 的过程：清空左端块对答案的影响
			while (l <= br) {
				if (rpos[a[l]] == l) {
					lpos[a[l]] = 0;
				}
				l++;
			}
			res = tp;
		}

		// 清空右边块对答案的影响
		while (r >= br) {
			lpos[a[r]] = rpos[a[r]] = 0;
			r--;
		}
	}

	for (int i = 1; i <= m; i++) {
		std::cout << ans[i] << "\n";
	}

	return 0;
}
```





## 二次离线莫队（不会）





# CDQ 分治

## 三维偏序

```cpp
#include <bits/stdc++.h>
#define int long long

struct BIT {
    int n;
    std::vector<int> tr;
    BIT(int _n) : n(_n), tr(_n + 1, 0) {}
    void add(int x, int nodecnt) {
        for (int i = x; i <= n; i += i & -i) {
            tr[i] += nodecnt;
        }
    }
    int query(int x) {
        int res = 0;
        for (int i = x; i; i -= i & -i) {
            res += tr[i];
        }
        return res;
    }
};

struct Node {
    int x, y, z, ans, cnt = 1;
    bool operator==(Node t) {
        return x == t.x && y == t.y && z == t.z;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    // 读入所有点，并三关键字排序
    int n, MAXN;
    std::cin >> n >> MAXN;
    std::vector<Node> node(n + 1);

    for (int i = 1; i <= n; i++) {
        int x, y, z;
        std::cin >> x >> y >> z;
        node[i] = {x, y, z};
    }
    std::sort(node.begin() + 1, node.end(), [&](auto a, auto b) {
        if (a.x != b.x) {
            return a.x < b.x;
        }
        if (a.y != b.y) {
            return a.y < b.y;
        }
        return a.z < b.z;
    });

    // 去重，将重复点的数量记录到 Node::cnt 中
    int nodecnt = 0;
    for (int i = 1; i <= n; i++) {
        if (node[i] == node[nodecnt]) {
            node[nodecnt].cnt++;
        } else {
            node[++nodecnt] = node[i];
        }
    }
    node.erase(node.begin() + nodecnt + 1, node.end());

    // CDQ 分治正文
    BIT tr(MAXN + 1);

    std::function<void(int, int)> cdq = [&](int l, int r) {
        if (l >= r) {
            return;
        }
        int mid = (l + r) / 2;
        cdq(l, mid);
        cdq(mid + 1, r);
        int i = l, j = mid + 1;
        std::vector<Node> tmp;
        while (i <= mid && j <= r) {
            if (node[i].y <= node[j].y) {
                tr.add(node[i].z, node[i].cnt);
                tmp.push_back(node[i++]);
            } else {
                node[j].ans += tr.query(node[j].z);
                tmp.push_back(node[j++]);
            }
        }
        while (i <= mid) {
            tr.add(node[i].z, node[i].cnt);
            tmp.push_back(node[i++]);
        }
        while (j <= r) {
            node[j].ans += tr.query(node[j].z);
            tmp.push_back(node[j++]);
        }
        for (int i = l; i <= mid; i++) {
            tr.add(node[i].z, -node[i].cnt);
        }
        for (int i = l, j = 0; j < tmp.size(); i++, j++) {
            node[i] = tmp[j];
        }
    };

    cdq(1, nodecnt);

    // 统计答案并输出
    std::vector<int> ans(n + 1);
    for (int i = 1; i <= nodecnt; i++) {
        ans[node[i].ans + node[i].cnt - 1] += node[i].cnt;
    }

    for (int i = 0; i < n; i++) {
        std::cout << ans[i] << "\n";
    }
    return 0;
}
```



## 二维数点

[P3755 [CQOI2017] 老C的任务](https://www.luogu.com.cn/problem/P3755)

【题意】平面内若干点，每个点有一个值。每次询问给出一个矩形，求矩形内点值之和。

```cpp
#include <bits/stdc++.h>
#define int long long

struct Node {
    int x, y, val, type;
    int sig, id, ans;
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, q;
    std::cin >> n >> q;
    std::vector<Node> node;
    std::vector<int> ans(q + 1);
    for (int i = 1; i <= n; i++) {
        int x, y, val;
        std::cin >> x >> y >> val;
        node.push_back({x, y, val, 1, 1, 0, 0});
    }
    for (int i = 1; i <= q; i++) {
        int xa, ya, xb, yb;
        std::cin >> xa >> ya >> xb >> yb;
        node.push_back({xb,     yb,     0, 2, 1, i, 0});
        node.push_back({xa - 1, yb,     0, 2, -1, i, 0});
        node.push_back({xb,     ya - 1, 0, 2, -1, i, 0});
        node.push_back({xa - 1, ya - 1, 0, 2, 1, i, 0});
    }

    std::sort(node.begin(), node.end(), [&](auto a, auto b) {
        if (a.x != b.x) {
            return a.x < b.x;
        } else if (a.y != b.y) {
            return a.y < b.y;
        } else {
            return a.type < b.type;
        }
    });

    std::function<void(int, int)> cdq = [&](int l, int r) {
        if (l >= r) {
            return;
        }
        int mid = (l + r) / 2;
        cdq(l, mid);
        cdq(mid + 1, r);
        int i = l, j = mid + 1, cnt = 0;
        std::vector<Node> tmp;
        while (i <= mid && j <= r) {
            if (node[i].y <= node[j].y) {
                if (node[i].type == 1) {
                    cnt += node[i].val;
                }
                tmp.push_back(node[i++]);
            } else {
                node[j].ans += cnt;
                tmp.push_back(node[j++]);
            }
        }
        while (i <= mid) {
            tmp.push_back(node[i++]);
        }
        while (j <= r) {
            node[j].ans += cnt;
            tmp.push_back(node[j++]);
        }
        for (int i = l, j = 0; j < tmp.size(); i++, j++) {
            node[i] = tmp[j];
        }
    };

    cdq(0, node.size() - 1);

    for (int i = 0; i < node.size(); i++) {
        if (node[i].type == 2) {
            ans[node[i].id] += node[i].sig * node[i].ans;
        }
    }
    for (int i = 1; i <= q; i++) {
        std::cout << ans[i] << "\n";
    }
    return 0;
}
```



# 整体二分



# 树套树

对于套线段树的数据结构，有一个棘手的点是不方便 `pushUp()`。所以要么是单点修改，要么使用标记永久化的技巧。



## 树状数组套树状数组

[#133. 二维树状数组 1：单点修改，区间查询](https://loj.ac/p/133)

【题意】维护一个二维平面，单点修改，查询矩形区域内的和。

```cpp
#include <bits/stdc++.h>
#define int long long

struct BIT_2d {
    int n, m;
    std::vector<std::vector<int>> a;
    BIT_2d(int _n, int _m) : n(_n), m(_m), a(n + 1, std::vector<int>(m + 1)) {}
    
    void modify(int x, int y, int k) {
        for (int i = x; i <= n; i += i & -i) {
            for (int j = y; j <= m; j += j & -j) {
                a[i][j] += k;
            }
        }
    }
    
    int query(int x, int y) {
        int res = 0;
        for (int i = x; i; i -= i & -i) {
            for (int j = y; j; j -= j & -j) {
                res += a[i][j];
            }
        }
        return res;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m;
    std::cin >> n >> m;
    BIT_2d bit(n, m);

    for (int op; std::cin >> op;) {
        if (op == 1) {
            int x, y, k;
            std::cin >> x >> y >> k;
            bit.modify(x, y, k);
        } else {
            int xa, ya, xb, yb;
            std::cin >> xa >> ya >> xb >> yb;
            std::cout << bit.query(xb, yb) - bit.query(xa - 1, yb) - bit.query(xb, ya - 1) + bit.query(xa - 1, ya - 1) << "\n";
        }
    }

    return 0;
}
```





## 树状数组套线段树

[P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)

【题意】有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。

$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。

【思路】外层树状数组，内层线段树。实测线段树套线段树会 T，但是像求和这样的操作是树状数组可以胜任的，并且树状数组常数更优。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

// 一个动态开点线段树。支持单点加，区间求和
class SegmentTree {
public:
    int L, R;
    SegmentTree(int L, int R) {             // 确定这棵线段树维护的区间范围
        this->L = L;
        this->R = R;
    }
    void add(int x, int k) {                // 单点加
        root = add(root, L, R, x, k);
    }
    int query(int x, int y) {               // 查询区间和
        return query(root, L, R, x, y);
    }

private:
    struct Node {
        int val;
        Node *l = nullptr, *r = nullptr;
        Node(int v = 0) {
            val = v;
        }
        void pushUp() {
            if (l == nullptr && r == nullptr) {
                return;
            }
            val = (l == nullptr ? 0 : l->val) + (r == nullptr ? 0 : r->val);
        }
    };

    Node *root = nullptr;

    Node *add(Node *t, int l, int r, int x, int k) {
        if (t == 0) {
            t = new Node();
        }
        if (l == x && r == x) {
            t->val += k;
            return t;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            t->l = add(t->l, l, mid, x, k);
        } else {
            t->r = add(t->r, mid + 1, r, x, k);
        }
        t->pushUp();
        return t;
    }
    int query(Node *t, int l, int r, int x, int y) {
        if (t == nullptr) {
            return 0;
        }
        if (l >= x && r <= y) {
            return t->val;
        }
        int mid = (l + r) / 2, res = 0;
        if (x <= mid) {
            res += query(t->l, l, mid, x, y);
        }
        if (y > mid) {
            res += query(t->r, mid + 1, r, x, y);
        }
        return res;
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, k;
    std::cin >> n >> k;

    std::vector<std::array<int, 3>> a(n + 1);
    for (int i = 1; i <= n; i++) {
        for (int j : {0, 1, 2}) {
            std::cin >> a[i][j];
        }
    }

    std::sort(a.begin() + 1, a.end());

    const int N = 2e5 + 10;
    std::vector<SegmentTree> fenwick(N + 1, SegmentTree(1, N + 1));

    // 在点 (x, y) += k
    auto add = [&](int x, int y, int k) {
        for (int i = x; i <= N; i += i & -i) {
            fenwick[i].add(y, k);
        }
    };

    // 查询点 (x_1, y_1) 到点 (x_2, y_2) 围成矩形的点值和
    auto query = [&](int x_1, int x_2, int y_1, int y_2) -> int {
        auto query = [&](int x, int y_1, int  y_2) -> int {
            int res = 0;
            for (int i = x; i; i -= i & -i) {
                res += fenwick[i].query(y_1, y_2);
            }
            return res;
        };
        return query(x_2, y_1, y_2) - query(x_1 - 1, y_1, y_2);
    };

    int sum = 1;
    std::vector<int> ans(n + 1);
    for (int i = 1; i <= n; i++) {
        if (a[i + 1] == a[i]) {
            sum += 1;
            continue;
        }
        add(a[i][1], a[i][2], sum);
        int res = query(1, a[i][1], 1, a[i][2]);
        ans[res] += sum;
        sum = 1;
    }

    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] << "\n";
    }

    return 0;
}
```



## 树状数组套权值线段树

[P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617) 

【题意】给定一个含有 $n$ 个数的序列 $a_1,a_2 \dots a_n$，需要支持两种操作：  

- `Q l r k` 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数  
- `C x y` 表示将 $a_x$ 改为 $y$

【思路】在 $[1,n]$ 的每一个位置 $pos$ 上维护一棵动态开点权值线段树，记为 $root[pos]$。这棵权值线段树维护的是原序列若干个点的权值分布情况。哪些点呢？考虑一棵树状数组 $BIT$，$BIT[pos]$ 维护了若干个位置的和。那么这里的 $root[pos]$ 也维护了同样的若干个位置的权值分布情况。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

namespace SGT {
    struct Node {
        int sum = 0;
        Node *l = nullptr, *r = nullptr;
    };

    Node *add(Node *t, int l, int r, int x, int k) {
        if (t == nullptr) {
            t = new Node;
        }
        t->sum += k;
        if (l == r) {
            return t;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            t->l = add(t->l, l, mid, x, k);
        } else {
            t->r = add(t->r, mid + 1, r, x, k);
        }
        return t;
    }

    // 在某棵权值线段树中查找区间 [l, r] 范围内的第 k 大。
    // 这棵权值线段树是由 pos_add 里的树减去 pos_del 里的树构成
    int query(std::vector<Node *> &pos_add, std::vector<Node *> &pos_del, int l, uint r, int k) {
        if (l == r) {
            return l;
        }
        int mid = (l + r) / 2, sum = 0;
        for (auto p : pos_add) {
            sum += ((p && p->l) ? p->l->sum : 0);
        }
        for (auto p : pos_del) {
            sum -= ((p && p->l) ? p->l->sum : 0);
        }
        if (k <= sum) {
            for (auto &p : pos_add) {
                p = (p ? p->l : nullptr);
            }
            for (auto &p : pos_del) {
                p = (p ? p->l : nullptr);
            }
            return query(pos_add, pos_del, l, mid, k);
        } else {
            for (auto &p : pos_add) {
                p = (p ? p->r : nullptr);
            }
            for (auto &p : pos_del) {
                p = (p ? p->r : nullptr);
            }
            return query(pos_add, pos_del, mid + 1, r, k - sum);
        }
    }
} // namespace SGT

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n + 1), value;
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
        value.push_back(a[i]);
    }

    std::vector<std::array<int, 4>> qu(q + 1);
    for (int i = 1; i <= q; i++) {
        char op;
        std::cin >> op >> qu[i][1] >> qu[i][2];
        qu[i][0] = (op == 'Q' ? 1 : 2);
        if (op == 'Q') {
            std::cin >> qu[i][3];
        } else {
            value.push_back(qu[i][2]);
        }
    }

    std::sort(value.begin(), value.end());
    value.erase(std::unique(value.begin(), value.end()), value.end());

    auto get = [&](int x) -> int {
        return std::lower_bound(value.begin(), value.end(), x) - value.begin() + 1;
    };

    for (int i = 1; i <= n; i++) {
        a[i] = get(a[i]);
    }
    for (int i = 1; i <= q; i++) {
        if (qu[i][0] == 2) {
            qu[i][2] = get(qu[i][2]);
        }
    }

    const int N = value.size() + 10;
    std::vector<SGT::Node *> root(n + 1, nullptr);

    auto add = [&](int pos, int x, int k) {
        for (int i = pos; i <= n; i += i & -i) {
            root[i] = SGT::add(root[i], 1, N, x, k);
        }
    };

    auto query = [&](int l, int r, int k) {
        std::vector<SGT::Node *> pos_add, pos_del;
        for (int i = r; i; i -= i & -i) {
            pos_add.push_back(root[i]);
        }
        for (int i = l - 1; i; i -= i & -i) {
            pos_del.push_back(root[i]);
        }
        return SGT::query(pos_add, pos_del, 1, N, k);
    };

    for (int i = 1; i <= n; i++) {
        add(i, a[i], 1);
    }

    for (int i = 1; i <= q; i++) {
        auto [op, x, y, k] = qu[i];
        if (qu[i][0] == 1) {
            int ans = query(x, y, k);
            std::cout << value[ans - 1] << "\n";
        } else {
            add(x, a[x], -1);
            a[x] = y;
            add(x, y, 1);
        }
    }

    return 0;
}
```



## 线段树套线段树

有一些问题是树状数组套线段树无法解决的，因为树状数组要求所维护的性质必须具有可减性，但是像区间最值这样的操作是树状数组无法实现的。但是线段树套线段树一般需要**标记永久化**的技巧避免 `pushUp()`。

[P3437 [POI2006]TET-Tetris 3D](https://www.luogu.com.cn/problem/P3437)

【题意】

维护一个 $1000\times 1000$ 的平面。若干次操作：

- 矩形区间查询最大值，然后矩形区间赋值，保证赋的值不小于该矩形区间最大值

这个问题需要一个技巧：标记永久化。这个技巧使用的前提是所有的修改操作都是非减的。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

// 线段树，实现区间赋值，查询区间最大值
class SegmentTree {
public:
    SegmentTree(int L, int R) {
        this->L = L;
        this->R = R;
        int n = R - L + 1;
        maxv.assign(n * 2 + 100, 0);
        tag.assign(n * 2 + 100, 0);
    }
    void assign(int x, int y, int k) {
        assign(1, L, R, x, y, k);
    }
    int query(int x, int y) {
        return query(1, L, R, x, y);
    }
private:
    int L, R;
    std::vector<int> maxv, tag;

    void assign(int p, int l, int r, int x, int y, int k) {
        maxv[p] = std::max(maxv[p], k);
        if (l >= x && r <= y) {
            tag[p] = std::max(tag[p], k);
            return;
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            assign(p * 2, l, mid, x, y, k);
        }
        if (y > mid) {
            assign(p * 2 + 1, mid + 1, r, x, y, k);
        }
    }
    int query(int p, int l, int r, int x, int y) {
        if (l >= x && r <= y) {
            return maxv[p];
        }
        int mid = (l + r) / 2;
        int res = tag[p];
        if (x <= mid) {
            res = std::max(res, query(p * 2, l, mid, x, y));
        }
        if (y > mid) {
            res = std::max(res, query(p * 2 + 1, mid + 1, r, x, y));
        }
        return res;
    }
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int W, H, n;
    std::cin >> W >> H >> n;

    std::vector<SegmentTree> maxv(W * 2 + 100, SegmentTree(0, H)), tag(maxv);

    auto modify = [&](auto self, int p, int l, int r, int x_1, int x_2, int y_1, int y_2, int k) -> void {
        maxv[p].assign(y_1, y_2, k);
        if (l >= x_1 && r <= x_2) {
            tag[p].assign(y_1, y_2, k);
            return;
        }
        int mid = (l + r) / 2;
        if (x_1 <= mid) {
            self(self, p * 2, l, mid, x_1, x_2, y_1, y_2, k);
        }
        if (x_2 > mid) {
            self(self, p * 2 + 1, mid + 1, r, x_1, x_2, y_1, y_2, k);
        }
    };

    auto query = [&](auto self, int p, int l, int r, int x_1, int x_2, int y_1, int y_2) -> int {
        if (l >= x_1 && r <= x_2) {
            return maxv[p].query(y_1, y_2);
        }
        int mid = (l + r) / 2;
        int res = tag[p].query(y_1, y_2);
        if (x_1 <= mid) {
            res = std::max(res, self(self, p * 2, l, mid, x_1, x_2, y_1, y_2));
        }
        if (x_2 > mid) {
            res = std::max(res, self(self, p * 2 + 1, mid + 1, r, x_1, x_2, y_1, y_2));
        }
        return res;
    };

    for (int i = 1; i <= n; i++) {
        int dx, dy, k, x_1, y_1;
        std::cin >> dx >> dy >> k >> x_1 >> y_1;
        int x_2 = x_1 + dx - 1;
        int y_2 = y_1 + dy - 1;
        k += query(query, 1, 0, H, x_1, x_2, y_1, y_2);
        modify(modify, 1, 0, H, x_1, x_2, y_1, y_2, k);
    }

    std::cout << query(query, 1, 1, H, 1, H, 1, W);

    return 0;
}
```



# Splay

splay 的最大特点是：灵活。似乎没有什么操作是其他平衡树能做但是 splay 做不了的。

## 普通平衡树

[普通平衡树](https://www.luogu.com.cn/problem/P3369)

splay 抓住三点：

- 理解左旋和右旋的过程
- splay 的核心函数 `splay()` 的作用和操作方式
- 如何去维护信息：分成两大类（需要 `pushup()` 和需要的 `pushdown()`）

```c++
#include <bits/stdc++.h>

struct Node {
    Node *ch[2] = {nullptr, nullptr};
    Node *fa = nullptr;
    int val, cnt = 1;
    int cntSum = 1;

    Node(int v_) : val(v_) {}
    ~Node() {
        if (ch[0]) {
            delete ch[0];
            ch[0] = nullptr;
        }
        if (ch[1]) {
            delete ch[1];
            ch[1] = nullptr;
        }
    }
    bool pos() {
        return fa->ch[1] == this;
    }
    void pushUp() {
        cntSum = cnt + (ch[0] ? ch[0]->cntSum : 0) + (ch[1] ? ch[1]->cntSum : 0);
    }
    void rotate() {
        Node *q = fa;
        bool x = !pos();
        q->ch[!x] = ch[x];
        if (ch[x] != nullptr) {
            ch[x]->fa = q;
        }
        fa = q->fa;
        if (q->fa != nullptr) {
            q->fa->ch[q->pos()] = this;
        }
        ch[x] = q;
        q->fa = this;
        q->pushUp();
        pushUp();
    }
    void splay(Node *des = nullptr) {
        while (fa != des) {
            if (fa->fa != des) {
                if (pos() == fa->pos()) {
                    fa->rotate();
                } else {
                    rotate();
                }
            }
            rotate();
        }
        pushUp();
    }
};

void clear(Node *&t) {
    t->ch[0] = t->ch[1] = nullptr;
    delete t;
    t = nullptr;
}

// 查询节点前驱（没有则返回自己）
Node *prev(Node *t) {
    t = t->ch[0];
    if (t == nullptr) {
        return t;
    }
    while (t->ch[1] != nullptr) {
        t = t->ch[1];
    }
    return t;
}

// 查询节点后继（没有则返回自己）
Node *next(Node *t) {
    t = t->ch[1];
    if (t == nullptr) {
        return t;
    }
    while (t->ch[0] != nullptr) {
        t = t->ch[0];
    }
    return t;
}

// 查询值 x 的排名
int rank(Node *&t, int x) {
    int res = 0;
    Node *p = nullptr;
    while (1) {
        if (t == nullptr) {
            if (p != nullptr) {
                p->splay();
            }
            return res + 1;
        }
        if (x < t->val) {
            p = t;
            t = t->ch[0];
        } else {
            res += (t->ch[0] == nullptr ? 0 : t->ch[0]->cntSum);
            if (t->val == x) {
                t->splay();
                return res + 1;
            }
            res += t->cnt;
            p = t;
            t = t->ch[1];
        }
    }
}

// 查询排名为 k 的元素值（算重复值）
int kth(Node *&t, int k) {
    assert(t != nullptr);
    if (t->ch[0] != nullptr) {
        if (k <= t->ch[0]->cntSum) {
            return kth(t->ch[0], k);
        } else {
            k -= t->ch[0]->cntSum;
        }
    }
    if (k <= t->cnt) {
        return t->val;
    }
    return kth(t->ch[1], k - t->cnt);
}

// 插入一个数值 x，返回新的根
void insert(Node *&t, int x) {
    Node *p = nullptr;
    while (t != nullptr) {
        if (t->val == x) {
            t->cnt += 1;
            t->pushUp();
            if (p != nullptr) {
                p->pushUp();
            }
            t->splay();
            return;
        }
        p = t;
        t = t->ch[x > t->val];
    }
    t = new Node(x);
    t->fa = p;
    if (p != nullptr) {
        p->ch[x > p->val] = t;
        p->pushUp();
    }
    t->splay();
}

// 删除一个数值 x，返回新的根
void del(Node *&t, int x) {
    rank(t, x);
    if (t->cnt > 1) {
        t->cnt -= 1;
        t->pushUp();
        return;
    }
    if (t->ch[0] == nullptr && t->ch[1] == nullptr) {
        clear(t);
        return;
    }
    if (t->ch[0] != nullptr && t->ch[1] != nullptr) {
        auto p = prev(t);
        t->ch[1]->fa = p;
        p->ch[1] = t->ch[1];
        p->ch[1]->pushUp();

        t = t->ch[0];
        clear(t->fa);
        return;
    }
    int c = (t->ch[0] == nullptr ? 1 : 0);
    t = t->ch[c];
    clear(t->fa);
    return;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int q;
    std::cin >> q;
    Node *root = nullptr;
    while (q--) {
        int op, x;
        std::cin >> op >> x;
        if (op == 1) {
            insert(root, x);
        } else if (op == 2) {
            del(root, x);
        } else if (op == 3) {
            std::cout << rank(root, x) << "\n";
        } else if (op == 4) {
            std::cout << kth(root, x) << "\n";
        } else if (op == 5) {
            insert(root, x);
            std::cout << prev(root)->val << "\n";
            del(root, x);
        } else {
            insert(root, x);
            std::cout << next(root)->val << "\n";
            del(root, x);
        }
    }

    if (root != nullptr) {
        delete root;
    }
    return 0;
}
```



## 文艺平衡树

[文艺平衡树](https://www.luogu.com.cn/problem/P3391)

维护一个排列，每次操作将指定区间翻转。

注意：

- 维护区间翻转的懒标记
- 这个题保证了原序列是一个排列，不需要考虑每个数字出现多次的情况

```c++
#include <bits/stdc++.h>

using i64 = long long;

struct Node {
    Node *ch[2] = {nullptr, nullptr};
    Node *fa = nullptr;
    int val;
    int rev = 0;
    int siz = 1;

    Node(int v_): val(v_) {}
    bool pos() {
        return fa->ch[1] == this;
    }
    void pushUp() {
        siz = 1 + (ch[0] ? ch[0]->siz : 0) + (ch[1] ? ch[1]->siz : 0);
    }
    void pushDown() {
        if (rev) {
            std::swap(ch[0], ch[1]);
            rev = 0;
            if (ch[0]) {
                ch[0]->rev ^= 1;
            }
            if (ch[1]) {
                ch[1]->rev ^= 1;
            }
        }
    }
    void rotate() {
        Node *q = fa;
        bool x = !pos();
        q->ch[!x] = ch[x];
        if (ch[x] != nullptr) {
            ch[x]->fa = q;
        }
        fa = q->fa;
        if (q->fa != nullptr) {
            q->fa->ch[q->pos()] = this;
        }
        ch[x] = q;
        q->fa = this;
        q->pushUp();
        pushUp();
    }
    
    void splay(Node *des = nullptr) {
        while (fa != des) {
            if (fa->fa != des) {
                if (pos() == fa->pos()) {
                    fa->rotate();
                } else {
                    rotate();
                }
            }
            rotate();
        }
        pushUp();
    }
};

// 返回中序遍历第 k 位的指针
Node *select(Node *t, int k) {
    assert(t != nullptr);
    t->pushDown();
    if (t->ch[0] != nullptr) {
        if (k <= t->ch[0]->siz) {
            return select(t->ch[0], k);
        } else {
            k -= t->ch[0]->siz;
        }
    }
    if (k == 1) {
        return t;
    }
    return select(t->ch[1], k - 1);
}

// 把一个 vector 的区间 [l, r] 建成 splay，返回根节点
Node *build(std::vector<int> &a, int l, int r) {
    if (l > r) {
        return nullptr;
    }
    int mid = (l + r) / 2;
    auto t = new Node(a[mid]);
    if (l == r) {
        return t;
    }
    t->ch[0] = build(a, l, mid - 1);
    t->ch[1] = build(a, mid + 1, r);
    for (int i : {0, 1}) {
        if (t->ch[i] != nullptr) {
            t->ch[i]->fa = t;
        }
    }
    t->pushUp();
    return t;
}

// 把以 t 为根的 splay 的中序遍历区间 [l, r] 翻转，返回新的根
Node *reverse(Node *t, int l, int r) {
    assert(l > 1);
    auto x = select(t, l - 1);
    auto y = select(t, r + 1);
    x->splay();
    y->splay(x);
    y->ch[0]->rev ^= 1;
    return x;
}

// 中序遍历以 t 为根的 splay
void inorder(Node *t, std::function<void(int)> f) {
    t->pushDown();
    if (t->ch[0] != nullptr) {
        inorder(t->ch[0], f);
    }
    f(t->val);
    if (t->ch[1] != nullptr) {
        inorder(t->ch[1], f);
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;
    std::vector<int> a(n + 2);
    std::iota(a.begin(), a.end(), 0);

    auto root = build(a, 0, n + 1);

    while (q--) {
        int l, r;
        std::cin >> l >> r;
        root = reverse(root, l + 1, r + 1);
    }

    inorder(root, [&](int x) {
        if (x >= 1 && x <= n) {
            std::cout << x << " ";
        }
    });
    return 0;
}
```



# 动态树

用来维护一片森林。每棵树被分为若干条实链。实链之间用虚边相连。

- 每棵树被剖分为由若干条实边组成的实链。树中其余的边称为虚边，用来连接两条实链。
- 每一条实链都用一棵 splay 维护，其中序遍历就是原树中该链从上到下的顺序。每个点的 splay 前驱是原树中的父亲，splay 后继是原树中的儿子。
- 虚边用 splay 的根节点维护。假设一条虚边 $fa[v] = u$，即原树中 $u$ 是 $v$ 的父亲，$v$ 是所在实链的顶端，$u$ 是所在实链的任意位置。那么在 splay 当中是 $v$ 所在的 splay 的根的父指针指向 $u$，而不一定是 $v$ 所在的 splay 节点指向 $u$。但是 $v$ 一定是所在 splay 的中序遍历第一个点，所以是可以还原回树的真实形状的。虚边中，子认父，但是父不认子。



每条实链的 splay 的根节点的父亲是原树种该点的父节点，但是该父节点的儿子中不认这个点。这就是实边和虚边的区别：实边是父子节点互认，虚边是子认父但父不认子。

虚边splay 的根节点维护。



[LCT 模板题](https://www.luogu.com.cn/problem/P3690)

维护一个有点权的森林，若干操作：

- 查询两点路径异或和
- 连接两点，若已联通则不操作
- 删除一条边，若不存在该边则不操作
- 修改点 $x$ 的权值

```cpp
#include <bits/stdc++.h>

using i64 = long long;

struct Info {
    int id, val;
    explicit Info(int id = -1, int val = 0) {
        this->id = id;
        this->val = val;
    }
    friend Info operator+ (Info lhs, Info rhs) {
        return Info(-1, lhs.val ^ rhs.val);
    }
};

namespace LCT {
    struct Node {
        Node *ch[2] = {nullptr, nullptr};
        Node *fa = nullptr;
        bool rev = 0;
        Info info;      // 原树上的节点信息
        Info infoSum;   // splay 中的子树信息和

        Node(Info &&v) {
            info = infoSum = v;
        }
        bool pos() {
            assert(fa != nullptr);
            return fa->ch[1] == this;
        }
        void modify(Info &&v) {
            splay();
            info = v;
            pushUp();
        }
        // 旋转以它为根的子树
        void reverse() {
            std::swap(ch[0], ch[1]);
            rev ^= 1;
        }
        void pushUp() {
            infoSum = info;
            for (int i : {0, 1}) {
                if (ch[i] != nullptr) {
                    infoSum = infoSum + ch[i]->infoSum;
                }
            }
        }
        void pushDown() {
            if (rev) {
                for (int i : {0, 1}) {
                    if (ch[i] != nullptr) {
                        ch[i]->reverse();
                    }
                }
                rev = 0;
            }
        }
        // 判断这个点是否是所在 splay 的根节点
        bool isSplayRoot() {
            if (fa == nullptr) {
                return true;
            }
            return this != fa->ch[0] && this != fa->ch[1];
        }
        // 注意这里的 rotate 与一般的 splay 有区别
        void rotate() {
            Node *q = fa;
            bool x = !pos();
            q->ch[!x] = ch[x];
            if (ch[x] != nullptr) {
                ch[x]->fa = q;
            }
            fa = q->fa;
            if (!q->isSplayRoot()) {            // 区别在这里，不能直接用 q->fa == nullptr 判断
                q->fa->ch[q->pos()] = this;
            }
            ch[x] = q;
            q->fa = this;
            q->pushUp();
            pushUp();
        }
        // 由于在 LCT 当中不保证每次 splay 时，该点已经被从上到下访问一次，所以需要先 pushDown
        void splay() {
            std::vector<Node *> stk;
            Node *cur = this;
            stk.push_back(cur);
            while (!cur->isSplayRoot()) {
                cur = cur->fa;
                stk.push_back(cur);
            }
            while (!stk.empty()) {
                stk.back()->pushDown();
                stk.pop_back();
            }

            while (!isSplayRoot()) {
                if (!fa->isSplayRoot()) {
                    if (pos() == fa->pos()) {
                        fa->rotate();
                    } else {
                        rotate();
                    }
                }
                rotate();
            }
        }
    };

    // 在原树中，将根节点到 x 的路径变为实链，并且 x 是实链末尾
    void access(Node *x) {
        Node *cur = x, *lst = nullptr;
        while (cur != nullptr) {
            cur->splay();
            cur->ch[1] = lst;
            cur->pushUp();
            lst = cur;
            cur = cur->fa;
        }
        x->splay();
    }
    // 在原树中，将 x 变为树根
    // 额外效果：x 成为 splay 根，左子树为空，称为原树实链顶部
    void makeRoot(Node *x) {
        access(x);
        x->reverse();
    }
    // 在原树中，找 x 所在树的树根节点
    // 额外效果：树根成为 splay 根，原本的 x 成为实链底部
    Node *findRoot(Node *x) {
        access(x);
        while (x->ch[0] != nullptr) {
            x->pushDown();
            x = x->ch[0];
        }
        x->splay();
        return x;
    }
    // 在原树中，将从 x 到 y 的路径变成一条实边路径
    // 额外效果：x 成为树根，y 是 x->y 的实链底部
    void split(Node *x, Node *y) {
        makeRoot(x);
        access(y);
    }
    // 在原树中，如果 x,y 不连通，那么加入边 x,y
    void link(Node *x, Node *y) {
        makeRoot(x);
        if (findRoot(y) != x) {
            x->fa = y;
        }
    }
    // 在原树中，如果 x,y 之间有边，则删掉该边
    void cut(Node *x, Node *y) {
        makeRoot(x);
        if (findRoot(y) == x && y->fa == x && y->ch[0] == nullptr) {
            x->ch[1] = nullptr;
            y->fa = nullptr;
            x->pushUp();
        }
    }
    // 在原树中，查询路径和
    Info chainQuery(Node *x, Node *y) {
        split(x, y);
        return y->infoSum;
    }
    // 判断 x, y 是否有边直接相连，可以用来 debug
    bool hasedge(Node *x, Node *y) {
        makeRoot(x);
        return (findRoot(y) == x && y->fa == x && y->ch[0] == nullptr);
    }
}; // namespace LCT


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<LCT::Node *> nodes(n + 1);
    for (int i = 1; i <= n; i++) {
        int x;
        std::cin >> x;
        nodes[i] = new LCT::Node(Info(i, x));
    }

    for (int t = 1; t <= m; t++) {
        int op, x, y;
        std::cin >> op >> x >> y;
        if (op == 0) {
            std::cout << LCT::chainQuery(nodes[x], nodes[y]).val << "\n";
        } else if (op == 1) {
            LCT::link(nodes[x], nodes[y]);
        } else if (op == 2) {
            LCT::cut(nodes[x], nodes[y]);
        } else if (op == 3) {
            nodes[x]->modify(Info(x, y));
        }
    }

    return 0;
}
```



# KD 树
