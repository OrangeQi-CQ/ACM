[TOC]

## 知识体系

- 路径：
    - 多次修改单次查询：树上差分（可能结合线段树合并等）；
    - 多次查询：树上倍增（静态），树上莫队（静态离线），重链剖分；
    - 所有点对：换根 dp（静态），点分治（静态），点分树；
- 子树：
    - 树上启发式合并 / 线段树合并（离线静态），用数据结构维护 dfn 序；

- 组合优化：
    - 构造，思维，贪心
    - 树上背包 dp：枚举子树中的花费；
    - 树上状态机 dp：枚举子树根节点的状态；
    - 虚树 dp：将树上所有点划分为几个点集分别求解；
    - 子树问题的 dp 可以用 树上启发式合并 / 线段树合并加速；
    - 树链问题的 dp 可以用树剖加速。



还有树上分块？





## 重心

定义

- 对于树（无根树）上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。


- 或者说，对于一个无根树，删去该点之后，剩下的连通块大小的最大值最小。


性质

- $u$ 是重心 $\Longleftrightarrow$ $u$ 的所有子树中，最大的子树的size不超过总结点数量的一半。
- 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。
- 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。
- 在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

```cpp
    int centroid = 1, maxSize = n;
    std::vector<int> siz(n + 1);

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        siz[u] = 1;
        int mx = 0;
        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            dfs(v, u);
            siz[u] += siz[v];
            mx = std::max(mx, siz[v]);
        }
        mx = std::max(mx, n - siz[u]);
        if (mx < maxSize) {
            centroid = u;
            maxSize = mx;
        }
    };
```



## 直径

定义

- 树上任意两节点之间最长的简单路径即为树的直径

性质

- 所有的直径的中点重合

DFS求直径和中心：找到直径的两个端点，并找到中心

```cpp
int p1, p2, center, len; // 分别是两个端点，中心，直径长度；

void dfs(int u, int pa, int &p) {
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (v == pa) {
            continue;
        }
        dis[v] = dis[u] + 1;
        fa[v] = u;
        dfs(v, u, p);
        if (dis[v] > dis[p]) {
            p = v;
            fa[v] = u;
        }
    }
}

void work() {
    p1 = 0; // 求直径的一个端点
    dis[1] = 0;
    dfs(1, 0, p1);
    p2 = 0; // 求直径的第二个端点
    dis[p1] = 0;
    dfs(p1, 0, p2);
    len = dis[p2];
    center = p2;
    for (int i = 1; i <= len / 2; i++) {
        center = fa[root];
    }
}
```

树形 DP 求直径

```cpp
void dfs(int u, int fa) {
	for (int i = head[u]; i; i = nxt[i]) {
		int v = to[i], w = edge[i];
		if (v == fa) {
			continue;
		}
		dfs(v, u);
        int t = d1[v] + edge[i];

        if (t > d1[u]) {
            d2[u] = d1[u];
            d1[u] = t;
        } else if (t > d2[u]) {
            d2[u] = t;
        }
	}
}
```





## 树的序列

### DFN 序

其实就是 DFS 先序。$dfn[u]$ 表示 $u$ 在 dfs 过程中第几个访问到。

一般用一个时间戳 $cur$ 记录当前已经访问过了多少节点。

- 用 $in[u]$ 表示访问 $u$ 的时间戳，显然 $in[u] = dfn[u]$。
- 用 $out[u]$ 表示退出子树时的时间戳，显然 $out[u] = in[u] + siz[u] - 1$。
- 以 $u$ 为根的子树的点的 DFN 范围是 $[in[u], out[u]]$。这样可以：
    - 快速判断 $v$ 是否在 $u$ 的子树中。
    - 以 DFN 序为下标存储点的信息。将子树问题转换为区间问题。

- 用 $pos$ 数组将 DFN 序映射回节点编号，即 $pos[in[u]] = u$。 

tips：不能直接复原出树的结构，但借助 $siz[u]$ 可以复原

```c++
    // std::vector adj(n + 1, std::vector<int>());
	std::vector<int> in(n + 1), out(n + 1), pos(n + 1);
    int cur = 0;

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        in[u] = ++cur;
        pos[cur] = u;
        for (int v : adj[u]) {
            if (v != pa) {
                dfs(v, u);
            }
        }
        out[u] = cur;
    };
```



### 欧拉序列

概念：

- 欧拉序列 $Eu$：初始时，欧拉序列是一个空序列。DFS 的过程中，每次进经过一某个结点 $u$（包括第一次进入 $u$，以及搜索完某个儿子之后回到 $u$）时都把 $u$ 加入欧拉序列末尾。这样可以得到一个长度为 $2n-1$的序列，即为欧拉序列 $Eu$

- 记录一个序列 $pos$，$pos[u]$ 表示点 $u$ 在欧拉序列中最早出现的下标。

用处是结合可以 $O(n\log n)$ 预处理， $O(1)$ 在线求 $\operatorname{lca}$：

- 假设 $pos[u]<pos[v]$，那么对于 $p=\operatorname{lca}(u,v)$，在 DFS 遍历到 $u$ 之后，遍历 $v$ 之前，一定会经过一次 $p$，并且一定不会经过 $p$ 的祖先。既然如此，在欧拉序列的下标 $[pos[u], pos[v]]$ 范围内的所有点当中，$p$ 是其中 $pos$ 值最小的。

- 于是做法就呼之欲出了：建立一个序列 $t[i]=pos[Eu[i]]$。查询 $t$ 当中 $[pos[u], pos[v]]$ 区间内的最小值为 $ansp$，那么 $p=pos[ansp]$ 就是所求的 $\operatorname{lca}(u,v)$。

[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

```cpp
#include <bits/stdc++.h>

using i64 = long long;

template<typename T, class Comp = std::less<T>>
struct RMQ {
	const int n;
	const Comp cmp;
	std::vector<std::vector<T>> f;
    
	// 要求 init 的下标从 1开始，把 init[0] 空出来
	RMQ(const std::vector<T> &init) : n(init.size() - 1), cmp(Comp()) {
		int lg = std::__lg(n);
		f.assign(n + 1, std::vector<T>(lg + 1));
		for (int i = 1; i <= n; i++) {
			f[i][0] = init[i];
		}
		for (int j = 1; j <= lg; j++) {
			for (int i = 1; i + (1 << j) - 1 <= n; i++) {
				f[i][j] = std::min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1], cmp);
			}
		}
	}

	T rmq(int l, int r) {
		int s = std::__lg(r - l + 1);
		return std::min(f[l][s], f[r - (1 << s) + 1][s], cmp);
	}
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q, root;
    std::cin >> n >> q >> root;

    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> Eu(n * 2), pos(n + 1), t(n * 2);
    int cur = 0;

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        Eu[++cur] = u;
        pos[u] = cur;
        for (int v : adj[u]) {
            if (v != pa) {
                dfs(v, u);
                Eu[++cur] = u;
            }
        }
    };

    dfs(root, 0);

    for (int i = 1; i <= cur; i++) {
        t[i] = pos[Eu[i]];
    }

    RMQ<int, std::less<int>> ST(t);

    while (q--) {
        int u, v;
        std::cin >> u >> v;
        if (pos[u] > pos[v]) {
            std::swap(u, v);
        }
        int res = Eu[ST.rmq(pos[u], pos[v])];
        std::cout << res << "\n";
    }

    return 0;
}
```



## 树上前缀 / 差分

### 树上前缀

边前缀和：

- $sum[u]$ 表示从根节点到 $u$ 的路径上的边权和，可通过一次 DFS 预处理。


- $dis(u,v)$ 表示树上两点距离（路径边权和）。


- 那么有：

$$
dis(u, v) = sum(u) + sum(v) - 2\times sum(LCA(u, v))
$$

点前缀和

- 设 $sum[u]$ 表示节点 $u$ 到根节点的点权总和。


- $dis(u, v)$ 表示树上两点路径点权和。


- 那么有：

$$
dis(u,v) = sum[u] + sum[v] - sum[LCA(x,y)] - sum[fa[LCA(x,y)]]
$$


### 对点差分

树上差分类似区间差分，可以 $O(1)$ 路径加，$O(N)$ 还原。

注意：**树上前缀和树上差分不是互逆关系**。树上前缀是向根节点的方向累加，而差分还原是向叶子节点的方向累加。

对点差分

假设树上原点权为 $a$，树上差分点权为 $b$。

1. 差分数组 $b$ 的定义：

$$
b[u] = a[u] - \sum_{v\in son(u)}a[v]
$$

2. 树链修改：$u \leftrightarrow v$ 路径上的所有点权加上 $w$

    - $b_u \leftarrow b_u+w$；

    - $b_v\leftarrow b_v + w$；

    - $b[\operatorname{lca}(u,v)] \leftarrow b[\operatorname{lca}(u,v)] - w$；

    - $b[fa[\operatorname{lca}(u,v)] \leftarrow b[fa[\operatorname{lca}(u,v)]-w$

    


3. 用差分数组 $b$ 回推原数组 $a$：

$$
a[u] = b[u] +\sum_{v\in sum(u)}a[v]
$$

例题：[P3128 [USACO15DEC]Max Flow P](https://www.luogu.com.cn/problem/P3128) 给定一棵树，所有点权为 $0$ 。每次操作给出两点 $u,\ v$，将 $u \rightarrow v$ 路径上的点权 $+1$。最后求点权最大值。

### 对边差分

用每个点记录它到父节点连边的长度，再对这个数组进行差分。其余和对点差分没什么区别。

$u\leftrightarrow v$ 路径上的所有边权加 $w$，对差分数组 $b$ 操作：

- $b_u \leftarrow b_u+w$；
- $b_v\leftarrow b_v + w$；
- $b[\operatorname{lca}(u,v)] \leftarrow b[\operatorname{lca}(u,v)] - 2\cdot w$



## 树上倍增

思想：预处理树上每个点的 $2^i$（$0\le i\le \log_2n$） 级祖先，或者每个点到它 $2^i$ 级祖先路径上的信息。

这样就可以将单次的树上路径查询问题由 $O(n)$ 的复杂度将为 $O(\log n)$。

###  $k$ 级祖先 + $LCA$ + 树上距离

```cpp
struct Tree {
    static const int M = 20;
    int n;
    std::vector<std::vector<std::array<int, 2>>> adj;
    std::vector<std::array<int, M + 1>> fa;
    std::vector<i64> dep, preSum;

    Tree(int n) {
        this->n = n;
        adj.assign(n + 1, {});
        fa.assign(n + 1, {});
        dep.assign(n + 1, 0);
        preSum.assign(n + 1, 0);
    }

    void addEdge(int u, int v, int w) {
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    // 一定不要忘了初始化！
    void dfs(int u, int pa) {
        for (int i = 1; i <= M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
        }
        for (auto [v, w] : adj[u]) {
            if (v == pa) {
                continue;
            }
            dep[v] = dep[u] + 1;
            preSum[v] = preSum[u] + w;
            fa[v][0] = u;
            dfs(v, u);
        }
    }

    int jump(int x, int k) {
        for (int i = 0; i <= M; i++) {
            if (k >> i & 1) {
                x = fa[x][i];
            }
        }
        return x;
    };

    int lca(int u, int v) {
        if (dep[u] < dep[v]) {
            std::swap(u, v);
        }
        int d = dep[u] - dep[v];
        for (int i = 0; i <= M; i++) {
            if (d >> i & 1) {
                u = fa[u][i];
            }
        }
        for (int i = M; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        return u == v ? u : fa[u][0];
    }

    i64 dis(int u, int v) {
        return preSum[u] + preSum[v] - 2 * preSum[lca(u, v)];
    }
};
```



### 严格次小生成树

 [P4180 [BJWC2010] 严格次小生成树](https://www.luogu.com.cn/problem/P4180) 

【题意】给无向连通图，求严格次小生成树。保证有解，边权在 $[0,10^9]$ 范围，$1\le n\le 10^5$，$1\le m\le 10^6$。

【思路】先找出最小生成树 MST，枚举每一条不在 MST 当中的边 $(u,v,w)$，在 MST 中求路径 $(u,v)$ 上的边中，边权严格小于 $w$ 的最大值 $w’$，尝试用 $w'$ 替换 $w$，比较取最优就是答案。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

const int INF = 1e9 + 7;

struct DSU {
    int n;
    std::vector<int> fa, siz;

    DSU(int _n) : n(_n), fa(_n + 1), siz(_n + 1, 1) {
        std::iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        fa[y] = x;
        siz[x] += siz[y];
        return true;
    }
    int size(int x) {
        return siz[find(x)];
    }
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::array<int, 3>> edge(m + 1);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        edge[i] = {w, u, v};
    }

    std::sort(edge.begin() + 1, edge.end());

    DSU dsu(n);
    std::vector adj(n + 1, std::vector<std::array<int, 2>>());
    std::vector<bool> used(m + 1);
    i64 ans = 0;    // 最小生成树大小

    for (int i = 1; i <= m; i++) {
        auto [w, u, v] = edge[i];
        if (!dsu.merge(u, v)) {
            continue;
        }
        ans += w;
        used[i] = true;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    const int M = 22;
    std::vector<int> dep(n + 1);
    std::vector<std::array<int, M + 1>> fa(n + 1), max1(n + 1, {-1, -1}), max2(n + 1, {-1, -1});

    std::function<void(int)> dfs = [&](int u) {
        for (int i = 1; i <= M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            int tmp[4] = {max1[u][i - 1], max1[fa[u][i - 1]][i - 1],
                          max2[u][i - 1], max2[fa[u][i - 1]][i - 1]};
            std::sort(tmp, tmp + 4);
            max1[u][i] = tmp[3];
            int p = 2;
            while (p && tmp[p] == tmp[3]) {
                p--;
            }
            max2[u][i] = (p == -1 ? -1 : tmp[p]);
        }

        for (auto [v, w] : adj[u]) {
            adj[v].erase(std::find(adj[v].begin(), adj[v].end(), std::array{u, w}));
            dep[v] = dep[u] + 1;
            fa[v][0] = u;
            max1[v][0] = w;
            dfs(v);
        }
    };

    dfs(1);

    auto query = [&](int u, int v, int value) -> i64 {
        auto get = [&](int x, int i) -> int {
            return max1[x][i] == value ? max2[x][i] : max1[x][i];
        };

        if (dep[u] < dep[v]) {
            std::swap(u, v);
        }
        int res = -1;
        int d = dep[u] - dep[v];
        for (int i = 0; i <= M; i++) {
            if (d & (1 << i)) {
                res = std::max(res, get(u, i));
                u = fa[u][i];
            }
        }
        if (u == v) {
            return res;
        }
        for (int i = M; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                res = std::max({res, get(u, i), get(v, i)});
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        res = std::max({res, get(u, 0), get(v, 0)});
        return res;
    };

    i64 res = 1e18;

    for (int i = 1; i <= m; i++) {
        if (used[i]) {
            continue;
        }
        auto [w, u, v] = edge[i];
        int t = query(u, v, w);
        if (t >= 0) {
            res = std::min(res, ans + w - t);
        }
    }

    std::cout << res;

    return 0;
}
```



## 总结：$LCA$ 

[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

### 树上倍增

$O(n\log n)$ 预处理，$O(n\log n)$ 单次查询。

先进行 dfs 预处理，先序处理点 $u$ 的深度 $d[u]$ 和点 $u$ 的第 $2^i$ 级祖先$f[u][i]$。核心是转移方程 $fa[u][i] = fa[fa[u][i-1]][i-1]$。

然后求 LCA。原理在于公共祖先的二分性：存在某一高度 $i$，使得对于任意 $j\ge i$，$x$ 和 $y$ 的第 $j$级祖先都相同。因此利用二分性进行二进制优化。

```c++
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q, root;
    std::cin >> n >> q >> root;

    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    const int M = 22;
    std::vector<std::array<int, M + 1>> fa(n + 1);
    std::vector<int> dep(n + 1);

    std::function<void(int)> dfs = [&](int u) {
        if (fa[u][0]) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa[u][0]));
        }
        for (int i = 1; i <= M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
        }
        for (int v : adj[u]) {
            dep[v] = dep[u] + 1;
            fa[v][0] = u;
            dfs(v);
        }
    };

    dfs(root);

    auto lca = [&](int u, int v) -> int {
        if (dep[u] < dep[v]) {
            std::swap(u, v);
        }
        int d = dep[u] - dep[v];
        for (int i = 0; i <= M; i++) {
            if (d & (1 << i)) {
                u = fa[u][i];
            }
        }
        for (int i = M; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        return u == v ? u : fa[u][0];
    };

    while (q--) {
        int u, v;
        std::cin >> u >> v;
        std::cout << lca(u, v) << "\n";
    }

    return 0;
}
```



### Tarjan 算法

$O(n+q)$预处理，$O(1)$ 查询。优势是预处理和查询的速度都特别快，缺点是必须离线。应用在虚树的建树过程。

过程：

1. 以s为根节点，从根节点开始
2. 递归遍历该点u所有子节点v，标记这些子节点v已被访问过，用并查集将 $v$ 合并到 $u$ 上，即 `fa[v] = u`
3. 对于与 $u$ 有询问关系的点 $v$，若 $v$ 被访问过了，那么答案就是 `dsu.find(v)`；

```c++
#include <bits/stdc++.h>

using i64 = long long;

struct DSU {
    int n;
    std::vector<int> fa, siz;

    DSU(int _n) : n(_n), fa(_n + 1), siz(_n + 1, 1) {
        std::iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        fa[y] = x;
        siz[x] += siz[y];
        return true;
    }
    int size(int x) {
        return siz[find(x)];
    }
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q, root;
    std::cin >> n >> q >> root;

    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector query(n + 1, std::vector<std::array<int, 2>>());
    std::vector<int> ans(q + 1);

    for (int i = 1; i <= q; i++) {
        int u, v;
        std::cin >> u >> v;
        query[u].push_back({v, i});
        query[v].push_back({u, i});
    }

    std::vector<bool> vis(n + 1);
    DSU dsu(n);

    std::function<void(int)> dfs = [&](int u) {
        vis[u] = 1;
        for (int v : adj[u]) {
            if (vis[v]) {
                continue;
            }
            dfs(v);
            dsu.merge(u, v);    // 合并方向不能反，否则是错的
        }
        for (auto [v, id] : query[u]) {
            if (vis[v]) {
                ans[id] = dsu.find(v);
            }
        }
    };

    dfs(root);
    for (int i = 1; i <= q; i++) {
        std::cout << ans[i] << "\n";
    }

    return 0;
}
```



### 欧拉序列 RMQ

$O(n\log n)$ 预处理，$O(1)$ 单次查询。当查询数量过大时，表现是比树上倍增倍增优秀的，但是写起来比倍增法麻烦一些。可以应用在 Kruscal 重构树的建树过程。

```c++
#include <bits/stdc++.h>

using i64 = long long;

template<typename T, class Comp = std::less<T>>
struct RMQ {
	const int n;
	const Comp cmp;
	std::vector<std::vector<T>> f;
    
	// 要求 init 的下标从 1开始，把 init[0] 空出来
	RMQ(const std::vector<T> &init) : n(init.size() - 1), cmp(Comp()) {
		int lg = std::__lg(n);
		f.assign(n + 1, std::vector<T>(lg + 1));
		for (int i = 1; i <= n; i++) {
			f[i][0] = init[i];
		}
		for (int j = 1; j <= lg; j++) {
			for (int i = 1; i + (1 << j) - 1 <= n; i++) {
				f[i][j] = std::min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1], cmp);
			}
		}
	}

	T rmq(int l, int r) {
		int s = std::__lg(r - l + 1);
		return std::min(f[l][s], f[r - (1 << s) + 1][s], cmp);
	}
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q, root;
    std::cin >> n >> q >> root;

    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> Eu(n * 2), pos(n + 1), t(n * 2);
    int cur = 0;

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        Eu[++cur] = u;
        pos[u] = cur;
        for (int v : adj[u]) {
            if (v != pa) {
                dfs(v, u);
                Eu[++cur] = u;
            }
        }
    };

    dfs(root, 0);

    for (int i = 1; i <= cur; i++) {
        t[i] = pos[Eu[i]];
    }

    RMQ<int, std::less<int>> ST(t);

    while (q--) {
        int u, v;
        std::cin >> u >> v;
        if (pos[u] > pos[v]) {
            std::swap(u, v);
        }
        int res = Eu[ST.rmq(pos[u], pos[v])];
        std::cout << res << "\n";
    }

    return 0;
}
```





## 重链剖分

算法本质：**将树上路径转换为 $\log n$ 段线性区间。**

核心就是求出 $top$ 数组，即每个点所在链的链首，查询时跳重链。

### 板子

[jiangly 的树剖板子](https://codeforces.com/contest/1824/submission/205122552)

注意 `addEdge` 那里已经建立了双向边。主函数里面不要再重复建双向边了。

以下板子根据 jiangly 改编。

```cpp
using PII = std::pair<int, int>;

struct HLD {
    int n;
    std::vector<int> siz, top, dep, fa, in, out, seq;
    std::vector<std::vector<int>> adj;
    int cur = 0;

    void init(int n) {
        this->n = n;
        siz.assign(n + 1, 0);
        top = dep = fa = in = out = seq = siz;
        adj.assign(n + 1, {});
        cur = 0;
    }

    HLD(int n) {
        init(n);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void work(int root = 1) {
        top[root] = root;
        dep[root] = 0;
        fa[root] = 0;
        dfs1(root);
        dfs2(root);
    }

    void dfs1(int u) {
        if (fa[u]) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa[u]));
        }
        siz[u] = 1;
        for (int &v : adj[u]) {
            fa[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                std::swap(v, adj[u][0]);
            }
        }
    }

    void dfs2(int u) {
        in[u] = ++cur;
        seq[cur] = u;
        for (int v : adj[u]) {
            top[v] = (v == adj[u][0] ? top[u] : v);
            dfs2(v);
        }
        out[u] = cur;
    }

    void getChain(int x, int y, std::vector<std::pair<int, int>> &road) {
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) {
                std::swap(x, y);
            }
            road.push_back({in[top[x]], in[x]});
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) {
            std::swap(x, y);
        }
        road.push_back({in[x], in[y]});
    }

    std::pair<int, int> getSubtree(int x) {
        return std::pair{in[x], out[x]};
    }

    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = fa[top[u]];
            } else {
                v = fa[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }

    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }

    int jump(int u, int k) {
        if (dep[u] < k) {
            return 0;
        }
        int d = dep[u] - k;
        while (dep[top[u]] > d) {
            u = fa[top[u]];
        }
        return seq[in[u] - dep[u] + d];
    }

    bool isAncester(int u, int v) {
        return in[u] <= in[v] && in[v] < out[u];
    }
};
```



### 维护树链信息

[【模板】轻重链剖分/树链剖分 - 洛谷](https://www.luogu.com.cn/problem/P3384)

【题意】

维护树上信息

- `1 x y z`：将树从 x 到 y 结点最短路径上所有节点的值都加上 z。
- `2 x y`：求树从 x 到 y 结点最短路径上所有节点的值之和。
- `3 x z`：将以 x为根节点的子树内所有节点值都加上 z。
- `4 x` ：求以 x为根节点的子树内所有节点值之和

```c++
#include <bits/stdc++.h>
#define int long long
using PII = std::pair<int, int>;

struct HLD {
    int n;
    std::vector<int> siz, top, dep, fa, in, out, seq;
    std::vector<std::vector<int>> adj;
    int cur = 0;

    void init(int n) {
        this->n = n;
        siz.assign(n + 1, 0);
        top = dep = fa = in = out = seq = siz;
        adj.assign(n + 1, {});
        cur = 0;
    }

    HLD(int n) {
        init(n);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void work(int root = 1) {
        top[root] = root;
        dfs1(root);
        dfs2(root);
    }

    void dfs1(int u) {
        if (fa[u]) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa[u]));
        }
        siz[u] = 1;
        for (int &v : adj[u]) {
            fa[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                std::swap(v, adj[u][0]);
            }
        }
    }

    void dfs2(int u) {
        in[u] = ++cur;
        seq[in[u]] = u;
        for (int v : adj[u]) {
            top[v] = (v == adj[u][0] ? top[u] : v);
            dfs2(v);
        }
        out[u] = cur;
    }

    std::vector<PII> getChain(int x, int y) {
        std::vector<PII> res;
        while (top[x] != top[y]) {
            if (dep[top[x]] < dep[top[y]]) {
                std::swap(x, y);
            }
            res.push_back({in[top[x]], in[x]});
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) {
            std::swap(x, y);
        }
        res.push_back({in[x], in[y]});
        return res;
    }

    std::pair<int, int> getSubtree(int x) {
        return std::pair{in[x], out[x]};
    }
};

// 经典加法线段树
struct SegmentTree {
    std::vector<int> sum, tag;
    int n;
    void pushUp(int p) {
        sum[p] = sum[p * 2] + sum[p * 2 + 1];
    }
    
    void pushDown(int p, int l, int r) {
        if (tag[p] == 0) {
            return;
        }
        int mid = (l + r) / 2;
        sum[p * 2] += (mid - l + 1) * tag[p];
        tag[p * 2] += tag[p];
        sum[p * 2 + 1] += (r - mid) * tag[p];
        tag[p * 2 + 1] += tag[p];
        tag[p] = 0;
        pushUp(p);
    }
    
    SegmentTree(std::vector<int> &a) {
        n = a.size() - 1;
        sum.assign(n * 4 + 1, 0);
        tag = sum;
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (l == r) {
                sum[p] = a[l];
                return;
            }
            int mid = (l + r) / 2;
            build(p * 2, l, mid);
            build(p * 2 + 1, mid + 1, r);
            pushUp(p);
        };
        build(1, 1, n);
    }
    
    void rangeAdd(int p, int l, int r, int x, int y, int k) {
        if (l >= x && r <= y) {
            sum[p] += (r - l + 1) * k;
            tag[p] += k;
            return;
        }
        int mid = (l + r) / 2;
        pushDown(p, l, r);
        if (x <= mid) {
            rangeAdd(p * 2, l, mid, x, y, k);
        }
        if (y > mid) {
            rangeAdd(p * 2 + 1, mid + 1, r, x, y, k);
        }
        pushUp(p);
    }
    
    int rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= x && r <= y) {
            return sum[p];
        }
        int mid = (l + r) / 2, ans = 0;
        pushDown(p, l, r);
        if (x <= mid) {
            ans += rangeQuery(p * 2, l, mid, x, y);
        }
        if (y > mid) {
            ans += rangeQuery(p * 2 + 1, mid + 1, r, x, y);
        }
        return ans;
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, q, root, MOD;
    std::cin >> n >> q >> root >> MOD;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }

    HLD tree(n);
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        tree.addEdge(u, v);
    }
    tree.work(root);

    auto b = a;
    for (int i = 1; i <= n; i++) {
        b[tree.in[i]] = a[i];
    }
    SegmentTree seg(b);

    while (q--) {
        int op, x, y, u, k;
        std::cin >> op;
        if (op == 1) {
            std::cin >> x >> y >> k;
            auto chain = tree.getChain(x, y);
            for (auto [x, y] : chain) {
                seg.rangeAdd(1, 1, n, x, y, k % MOD);
            }
        } else if (op == 2) {
            std::cin >> x >> y;
            auto chain = tree.getChain(x, y);
            int ans = 0;
            for (auto [x, y] : chain) {
                ans += seg.rangeQuery(1, 1, n, x, y) % MOD;
            }
            std::cout << ans % MOD << "\n";
        } else if (op == 3) {
            std::cin >> u >> k;
            auto [x, y] = tree.getSubtree(u);
            seg.rangeAdd(1, 1, n, x, y, k);
        } else {
            std::cin >> u;
            auto [x, y] = tree.getSubtree(u);
            std::cout << seg.rangeQuery(1, 1, n, x, y) % MOD << "\n";
        }
    }

    return 0;
}
```



Trick：

- [P2486 [SDOI2011] 染色](https://www.luogu.com.cn/problem/P2486) 需要判断两条链交界处是否为同一段颜色
- [P4114 Qtree1](https://www.luogu.com.cn/problem/P4114) 树剖维护边权：要注意把 $lca$ 空出来（`getCahin` 的最后一步改为 `        res.push_back({in[x + 1], in[y]});`）
- [P3979 遥远的国度](https://www.luogu.com.cn/problem/P3979) 换根查询。



## 长链剖分

### 树上 $k$ 级祖先

长链剖分可以 $O(n\log n)$ 预处理，$O(1)$ 查询任意点 $k$ 级祖先。

[P5903 【模板】树上 k 级祖先](https://www.luogu.com.cn/problem/P5903)

【题意】强制在线，多次查询任意点 $k$ 级祖先。

```cpp
#include <bits/stdc++.h>

using i64 = long long;
const int M = 20;

#define ui unsigned int
ui s;

inline ui get() {
    s ^= s << 13;
    s ^= s >> 17;
    s ^= s << 5;
    return s;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q >> s;

    std::vector<std::array<int, M + 1>> fa(n + 1);
    std::vector adj(n + 1, std::vector<int>());
    int root;

    for (int i = 1; i <= n; i++) {
        std::cin >> fa[i][0];
        if (fa[i][0] == 0) {
            root = i;
        } else {
            adj[fa[i][0]].push_back(i);
        }
    }

    std::vector<int> dep(n + 1), h(n + 1);

    std::function<void(int)> dfs1 = [&](int u) {
        for (int i = 1; i <= M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
        }
        h[u] = 1;
        for (int &v : adj[u]) {
            dep[v] = dep[u] + 1;
            dfs1(v);
            h[u] = std::max(h[u], h[v] + 1);
            if (h[v] > h[adj[u][0]]) {
                std::swap(v, adj[u][0]);
            }
        }
    };

    dep[root] = 1;
    dfs1(root);

    std::vector<int> in(n + 1), top(n + 1), Up(n + 1), Down(n + 1);
    int cur = 0;

    std::function<void(int, int p)> dfs2 = [&](int u, int p) {
        in[u] = ++cur;
        Down[cur] = u;
        Up[cur] = p;
        if (adj[u].empty()) {
            return;
        }
        top[adj[u][0]] = top[u];
        dfs2(adj[u][0], fa[p][0]);
        for (int v : adj[u]) {
            if (v == adj[u][0]) {
                continue;
            }
            top[v] = v;
            dfs2(v, v);
        }
    };

    top[root] = root;
    dfs2(root, root);

    auto query = [&](int u, int k) -> int {
        if (k == 0) {
            return u;
        }
        u = fa[u][std::__lg(k)];
        k -= (1 << std::__lg(k));
        k -= (dep[u] - dep[top[u]]);
        u = top[u];
        if (k >= 0) {
            int res = in[u] + k;
            return res > n ? 0 : Up[res];
        } else {
            int res = in[u] - k;
            return res > n ? 0 : Down[res];
        }
    };

    i64 ans = 0, lstans = 0;
    for (int i = 1; i <= q; i++) {
        int x = (get() ^ lstans) % n + 1, k = (get() ^ lstans) % dep[x];
        lstans = query(x, k);
        // std::cerr << x << " " << k << " " << lstans << "\n";
        ans ^= 1LL * i * lstans;
    }

    std::cout << ans;

    return 0;
}
```



### 优化树深度相关 DP

[CF1009F. Dominant Indices](https://codeforces.com/problemset/problem/1009/F)

【题意】

给定一棵以 $1$ 为根，$n$ 个节点的树。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。对于每个点，求使得 $d(u,x)$ 最大的 $x$，若有多个则输出最小的 $x$。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<int>());

    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> in(n + 1), out(n + 1), pos(n + 1), fa(n + 1), h(n + 1);
    int cur = 0;

    std::function<void(int)> dfs1 = [&](int u) {
        if (fa[u]) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa[u]));
        }
        for (int &v : adj[u]) {
            fa[v] = u;
            dfs1(v);
            if (h[v] >= h[adj[u][0]]) {
                h[u] = h[v] + 1;
                std::swap(v, adj[u][0]);
            }
        }
    };

    dfs1(1);

    std::vector dp(n + 1, std::vector<int>());
    std::vector<int> ans(n + 1);

    std::function<void(int)> dfs2 = [&](int u) {
        if (adj[u].empty()) {
            dp[u].push_back(1);
            ans[u] = 0;
            return;
        }
        int wson = adj[u][0];
        dfs2(wson);
        std::swap(dp[wson], dp[u]);
        
        dp[u].push_back(1);             // dp[u][h[u]] = 1（u 自己）
        ans[u] = ans[wson];
        if (dp[u][ans[u]] == 1) {
            ans[u] = h[u];
        }

        for (int v : adj[u]) {
            if (v == adj[u][0]) {
                continue;
            }
            dfs2(v);
            for (int i = h[v]; i >= 0; i--) {
                int t = i + h[u] - h[v] - 1;
                dp[u][t] += dp[v][i];
                if (dp[u][t] > dp[u][ans[u]] || (dp[u][t] == dp[u][ans[u]] && t > ans[u])) {
                    ans[u] = t;
                }
            }
        }
    };

    dfs2(1);

    for (int i = 1; i <= n; i++) {
        std::cout << h[i] - ans[i] << "\n";
    }

    return 0;
}
```



## 树上启发式合并

算法本质：**离线得到所有子树内的全部信息。**

特点：

- 离线
- 静态（没有修改）
- 只针对子树

例题：[CF 600E - Lomsat gelral](https://codeforces.com/problemset/problem/600/E) 给一个以 $1$ 为根大小为 $n$ 的树，每个节点都有颜色 $c_i(c_i\le n)$。对于以某个完全子树，称其中出现次数最多的颜色“占领”该子树，一个子树可以被多个颜色占领。求对于每一个节点，占领以该节点的完全子树的所有颜色之和。

### 桶式写法

一般思路如下：

1. 先遍历请儿子，计算答案，不保留它对桶的影响。
2. 遍历重儿子，保留它对桶的影响。
3. 再次遍历轻儿子，将其贡献假如当前点的答案。

这里有一个很重要的点：**在 dfs 的过程中，只要被删掉的点，后面一定会添加回来。这对信息的统计非常重要。**

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<int>());
    std::vector<int> c(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> c[i];
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> in(n + 1), out(n + 1), pos(n + 1), siz(n + 1), wson(n + 1);
    int cur = 0;

    auto dfs1 = [&](auto self, int u, int pa) -> void {
        in[u] = ++cur;
        pos[cur] = u;
        siz[u] = 1;
        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            self(self, v, u);
            siz[u] += siz[v];
            if (wson[u] == 0 || siz[v] > siz[wson[u]]) {
                wson[u] = v;
            }
        }
        out[u] = cur;
    };

    dfs1(dfs1, 1, 0);

    // cnt 记录每种颜色的出现次数。sum 记录 出现 x 中颜色的颜色编号之和，ans 记录每个子树的答案
    std::vector<i64> cnt(n + 1), sum(n + 1), ans(n + 1);
    int top = 0;    // 记录颜色次数的最大值

    auto add = [&](int u) {
        int color = c[u];
        sum[cnt[color]] -= color;
        cnt[color] += 1;
        sum[cnt[color]] += color;
        if (cnt[color] > top) {
            top = cnt[color];
        }
    };

    auto del = [&](int u) {
        int color = c[u];
        sum[cnt[color]] -= color;
        cnt[color] -= 1;
        sum[cnt[color]] += color;
        top = 0;            // 这里完全不需要担心，因为只要是删掉的点一定会在后面加回来
    };

    auto getAns = [&]() {
        return sum[top];
    };

    auto dfs2 = [&](auto self, int u, int pa, bool keep) -> void {
        for (int v : adj[u]) {
            if (v == pa || v == wson[u]) {
                continue;
            }
            self(self, v, u, false);
        }
        if (wson[u]) {
            self(self, wson[u], u, true);
        }
        for (int v : adj[u]) {
            if (v == pa || v == wson[u]) {
                continue;
            }
            for (int i = in[v]; i <= out[v]; i++) {
                add(pos[i]);
            }
        }
        add(u);
        ans[u] = getAns();
        if (keep == false) {
            for (int i = in[u]; i <= out[u]; i++) {
                del(pos[i]);
            }
        }
    };

    dfs2(dfs2, 1, 0, true);
    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] << " ";
    }

    return 0;
}
```



### 集合式写法

理论上会比桶式写法的时间和空间复杂度多一个 $\log$（实际可能更快）。

但是更清晰，更好写，解决问题的范围更广。

```cpp
#include <bits/stdc++.h>
#define int long long

struct Node {
    int maxcnt = 0, maxsum = 0;
    std::unordered_map<int, int> cnt;

    void add(int x, int k) {
        cnt[x] += k;
        if (cnt[x] > maxcnt) {
            maxcnt = cnt[x];
            maxsum = x;
        } else if (cnt[x] == maxcnt) {
            maxsum += x;
        }
    }
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;
    std::vector<int> c(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> c[i];
    }

    std::vector<std::vector<int>> adj(n + 1);
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int dfncnt = 0;
    std::vector<int> ans(n + 1);
    std::vector<Node> node(n + 1);

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            dfs(v, u);
            if (node[v].cnt.size() > node[u].cnt.size()) {
                std::swap(node[u], node[v]);
            }
            for (auto [col, num] : node[v].cnt) {
                node[u].add(col, num);
            }
        }
        node[u].add(c[u], 1);
        ans[u] = node[u].maxsum;
    };

    dfs(1, 0);
    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] << " ";
    }

    return 0;
}
```



## 【总结】离线静态子树查询

[CF1009F - Dominant Indices](https://www.luogu.com.cn/problem/CF1009F)

【题意】

有根树大小为 $n$。设 $d(u,x)$ 为 $u$ 子树中到 $u$ 距离为 $x$ 的节点数。

对于每个点，求一个最小的 $k$，使得 $d(u,k)$ 最大。

$n\le 10^5$。



### 树上启发式合并

桶式 dsu on tree（理论上比集合式的写法要快一个 $\log$，实际反而慢。要对 `stl` 的性能有足够信心）。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> siz(n + 1), in(n + 1), out(n + 1), pos(n + 1), fa(n + 1);
    std::vector<int> dep(n + 1);
    int cur = 0;

    std::function<void(int)> dfs1 = [&](int u) {
        siz[u] = 1;
        in[u] = ++cur;
        pos[cur] = u;
        if (fa[u]) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa[u]));
        }
        for (int &v : adj[u]) {
            dep[v] = dep[u] + 1;
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                std::swap(v, adj[u][0]);
            }
        }
        out[u] = cur;
    };

    dfs1(1);

    std::vector<int> ans(n + 1), cnt(n + 1);
    int res = 0, maxCnt = 0;

    auto add = [&](int u) {
        cnt[dep[u]] += 1;
        if (cnt[dep[u]] > maxCnt) {
            maxCnt = cnt[dep[u]];
            res = dep[u];
        } else if (cnt[dep[u]] == maxCnt) {
            res = std::min(res, dep[u]);
        }
    };

    auto del = [&](int u) {     // 利用了 dsu on tree 的一个性质：删掉的点一定会再加回来
        cnt[dep[u]] -= 1;
        res = maxCnt = 0;
    };

    auto getAns = [&](int u) -> int {
        return res;
    };

    std::function<void(int, bool)> dfs2 = [&](int u, bool keep) {
        for (int v : adj[u]) {
            if (v != adj[u][0]) {
                dfs2(v, false);
            }
        }
        if (!adj[u].empty()) {
            dfs2(adj[u][0], true);
        }
        for (int v : adj[u]) {
            if (v != adj[u][0]) {
                for (int i = in[v]; i <= out[v]; i++) {
                    add(pos[i]);
                }
            }
        }
        add(u);
        ans[u] = getAns(u);
        if (!keep) {
            for (int i = in[u]; i <= out[u]; i++) {
                del(pos[i]);
            }
        }
    };
    dfs2(1, true);

    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] - dep[i] << "\n";
    }

    return 0;
}
```



集合式 dsu on tree

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    struct Node {
        std::map<int, int> cnt;         // 储存子树中，每种深度点的个数
    };

    std::vector<Node> node(n + 1);
    std::vector<int> dep(n + 1), ans(n + 1);

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        node[u].cnt[dep[u]] = 1;
        int res = dep[u];
        
        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            dep[v] = dep[u] + 1;
            dfs(v, u);
            if (node[v].cnt.size() > node[u].cnt.size()) {
                std::swap(node[u], node[v]);
                res = ans[v];
            }
        }

        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            for (auto [d, c] : node[v].cnt) {
                node[u].cnt[d] += c;
                if (node[u].cnt[d] > node[u].cnt[res] ||
                    (node[u].cnt[d] == node[u].cnt[res] && d < res)) {
                    res = d;
                }
            }
        }

        ans[u] = res;
    };

    dfs(1, 0);
    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] - dep[i] << "\n";
    }

    return 0;
}
```



### 长链剖分

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<int>());

    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> in(n + 1), out(n + 1), pos(n + 1), fa(n + 1), h(n + 1);
    int cur = 0;

    std::function<void(int)> dfs1 = [&](int u) {
        if (fa[u]) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), fa[u]));
        }
        for (int &v : adj[u]) {
            fa[v] = u;
            dfs1(v);
            if (h[v] >= h[adj[u][0]]) {
                h[u] = h[v] + 1;
                std::swap(v, adj[u][0]);
            }
        }
    };

    dfs1(1);

    std::vector dp(n + 1, std::vector<int>());
    std::vector<int> ans(n + 1);

    std::function<void(int)> dfs2 = [&](int u) {
        if (adj[u].empty()) {
            dp[u].push_back(1);
            ans[u] = 0;
            return;
        }
        int wson = adj[u][0];
        dfs2(wson);
        std::swap(dp[wson], dp[u]);
        
        dp[u].push_back(1);             // dp[u][h[u]] = 1（u 自己）
        ans[u] = ans[wson];
        if (dp[u][ans[u]] == 1) {
            ans[u] = h[u];
        }

        for (int v : adj[u]) {
            if (v == adj[u][0]) {
                continue;
            }
            dfs2(v);
            for (int i = h[v]; i >= 0; i--) {
                int t = i + h[u] - h[v] - 1;
                dp[u][t] += dp[v][i];
                if (dp[u][t] > dp[u][ans[u]] || (dp[u][t] == dp[u][ans[u]] && t > ans[u])) {
                    ans[u] = t;
                }
            }
        }
    };

    dfs2(1);

    for (int i = 1; i <= n; i++) {
        std::cout << h[i] - ans[i] << "\n";
    }

    return 0;
}
```



### 线段树合并

[CF1009F - Dominant Indices](https://www.luogu.com.cn/problem/CF1009F)

```cpp
#include <bits/stdc++.h>

using i64 = long long;

const int INF = 1e9;

struct Node {
    int val = 0, res = 0;
    Node *l = nullptr, *r = nullptr;
    void pushUp() {
        if (l == nullptr && r == nullptr) {
            return;
        }
        if (r == nullptr || (l != nullptr && l->val >= r->val)) {
            val = l->val;
            res = l->res;
        } else {
            val = r->val;
            res = r->res;
        } 
    }
};

Node *merge(Node *t1, Node *t2, int l, int r) {
    if (!t1) {
        return t2;
    }
    if (!t2) {
        return t1;
    }
    if (l == r) {
        t1->val += t2->val;
        delete(t2);
        return t1;
    }
    int mid = (l + r) / 2;
    t1->l = merge(t1->l, t2->l, l, mid);
    t1->r = merge(t1->r, t2->r, mid + 1, r);
    delete(t2);
    t1->pushUp();
    return t1;
}

Node *indAdd(Node *t, int l, int r, int x, int k) {
    if (!t) {
        t = new Node;
    }
    if (l == x && r == x) {
        t->val += k;
        t->res = x;
        return t;
    }
    int mid = (l + r) / 2;
    if (x <= mid) {
        t->l = indAdd(t->l, l, mid, x, k);
    } else {
        t->r = indAdd(t->r, mid + 1, r, x, k);
    }
    t->pushUp();
    return t;
}

int query(Node *t) {
    return t->res;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<int>());
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<Node *> root(n + 1);
    std::vector<int> dep(n + 1), ans(n + 1);

    std::function<void(int, int)> dfs = [&](int u, int pa) {
        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            dep[v] = dep[u] + 1;
            dfs(v, u);
            root[u] = merge(root[u], root[v], 1, n);
        }
        root[u] = indAdd(root[u], 1, n, dep[u], 1);	// 一定要先合并子树，再插入当前点。否则会炸空间。
        ans[u] = query(root[u]) - dep[u];
    };

    dep[1] = 1;
    dfs(1, 0);

    for (int i = 1; i <= n; i++) {
        std::cout << ans[i] << "\n";
    }

    return 0;
}
```




## 树分治

### 点分治

算法本质：对树上所有 $\dbinom{n}{2}$ 条路径的查询 $\rightarrow$ $\log$ 次处理 ”一棵树中查询所有经过根节点的路径”。

过程/思想：

1. 找到重心，作为当前树的根
2. 处理经过当前根节点的路径
3. 删掉根节点，每棵子树，取重心为根节点，重复前两步

思维的重心只在第二步，我们只需要在 $O(n\log n)$ 的复杂度内解决：关于树根的路径查询问题。所以也说明了这是一个很套路化的算法，但是写起来细节不少。

比较难搞的一个点：在第二步中，遍历子树时获得了一大堆以当前点 $u$ 为端点的链。怎么把这些链合并起来？

1. 如果询问个数比较少，可以尝试把这些链信息都存下来，尝试用双指针之类的办法
2. 其他时候，只能尝试用 `std::map` 了，否则会退化到 $O(n^2)$。

[P3806 【模板】点分治1](https://www.luogu.com.cn/problem/P3806) （不必容斥）

【题意】给定一棵有 $n$ 个点的树，$q$ 次询问树上距离为 $k$ 的点对是否存在。

$1\le n \le 10^4$，$1\le q\le 100$，$1\le k\le 10^7$。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, q;
    std::cin >> n >> q;

    std::vector<std::vector<std::array<int, 2>>> adj(n + 1);
    for (int i = 1; i < n; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    std::vector<i64> query(q + 1), ans(q + 1);
    for (int i = 1; i <= q; i++) {
        std::cin >> query[i];
    }

    /******************************************************************/

    std::vector<bool> del(n + 1);
    std::unordered_map<int, int> pre, now;   // 之前的子树的链，当前的子树的链

    // 添加链到 now 中
    auto getChain = [&](auto self, int u, int pa, int dist) -> void {
        now[dist] += 1;
        for (auto [v, w] : adj[u]) {
            if (del[v] || v == pa) {
                continue;
            }
            self(self, v, u, dist + w);
        }
    };

    // 求一个集合中的答案
    auto calc = [&]() {
        for (int i = 1; i <= q; i++) {
            int x = query[i];
            if (now.count(x)) {
                ans[i] += now[x];
            }
            for (auto [v, c] : now) {
                if (pre.count(x - v) && pre[x - v] > 0) {
                    ans[i] += 1LL * c * pre[x - v];
                }
            }
        }
    };

    auto solve = [&](auto self, int u, int tot) -> void {
        // 第一步：找到重心作为根
        std::unordered_map<int, int> siz, maxSize;
        int root = -1;
        auto findRoot = [&](auto self, int u, int pa) -> void {
            maxSize[u] = 0;
            siz[u] = 1;
            for (auto [v, w] : adj[u]) {
                if (v == pa || del[v]) {
                    continue;
                }
                self(self, v, u);
                maxSize[u] = std::max(maxSize[u], siz[v]);
                siz[u] += siz[v];
            }
            maxSize[u] = std::max(maxSize[u], tot - siz[u]);
            if (root == -1 || maxSize[u] < maxSize[root]) {
                root = u;
            }
        };
        findRoot(findRoot, u, 0);
        u = root;
        findRoot(findRoot, u, 0);

        // 第二步：处理所有经过根的路径
        pre.clear();
        for (auto [v, w] : adj[u]) {
            if (del[v]) {
                continue;
            }
            now.clear();
            getChain(getChain, v, u, w);
            calc();
            for (auto [v, c] : now) {
                pre[v] += c;
            }
        }

        // 第三步：删掉根以及与根相连的边，递归处理所有子树
        del[u] = 1;
        for (auto [v, w] : adj[u]) {
            if (!del[v]) {
                self(self, v, siz[v]);
            }
        }
    };

    solve(solve, 1, n);

    for (int i = 1; i <= q; i++) {
        std::cout << (ans[i] ? "AYE" : "NAY") << "\n";
    }

    return 0;
}
```



[P4178 Tree](https://www.luogu.com.cn/problem/P4178)（必须容斥）

【题意】给定一棵 $n$ 个节点的树，每条边有边权，求出树上两点距离小于等于 $k$ 的点对数量。

$n\le 40000$。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, target;
    i64 ans = 0;
    std::cin >> n;

    std::vector<std::vector<std::array<int, 2>>> adj(n + 1);
    for (int i = 1; i < n; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    std::cin >> target;

    /******************************************************************/

    std::vector<bool> del(n + 1);
    std::vector<int> pre, now;  // 之前的子树的链，当前的子树的链

    // 添加链到 now 中
    auto getChain = [&](auto self, int u, int pa, int dist) -> void {
        now.push_back(dist);
        for (auto [v, w] : adj[u]) {
            if (del[v] || v == pa) {
                continue;
            }
            self(self, v, u, dist + w);
        }
    };

    // 求一个集合中的答案
    auto calc = [&](std::vector<int> &vec, int flag) {
        std::sort(vec.begin(), vec.end());
        for (int i = 0, j = vec.size() - 1; i < j; i++) {
            while (i < j && vec[i] + vec[j] > target) {
                j--;
            }
            if (i < j) {
                ans += flag * (j - i);
            }
        }
        if (flag == 1) {
            ans += std::lower_bound(vec.begin(), vec.end(), target + 1) - vec.begin();
        }
    };

    auto solve = [&](auto self, int u, int tot) -> void {
        // 第一步：找到重心作为根
        std::unordered_map<int, int> siz, maxSize;
        int root = -1;
        auto findRoot = [&](auto self, int u, int pa) -> void {
            maxSize[u] = 0;
            siz[u] = 1;
            for (auto [v, w] : adj[u]) {
                if (v == pa || del[v]) {
                    continue;
                }
                self(self, v, u);
                maxSize[u] = std::max(maxSize[u], siz[v]);
                siz[u] += siz[v];
            }
            maxSize[u] = std::max(maxSize[u], tot - siz[u]);
            if (root == -1 || maxSize[u] < maxSize[root]) {
                root = u;
            }
        };
        findRoot(findRoot, u, 0);
        u = root;
        findRoot(findRoot, u, 0);
        assert(u == root);

        // 第二步：处理所有经过根的路径
        pre.clear();
        for (auto [v, w] : adj[u]) {
            if (del[v]) {
                continue;
            }
            now.clear();
            getChain(getChain, v, u, w);
            calc(now, -1);
            for (int x : now) {
                pre.push_back(x);
            }
        }
        calc(pre, 1);

        // 第三步：删掉根以及与根相连的边，递归处理所有子树
        del[u] = 1;
        for (auto [v, w] : adj[u]) {
            if (!del[v]) {
                self(self, v, siz[v]);
            }
        }
    };

    solve(solve, 1, n);

    std::cout << ans;

    return 0;
}
```



[P2634 [国家集训队] 聪聪可可](https://www.luogu.com.cn/problem/P2634)

题意：给一棵树，有边权。求从树上任取两点，路径长度是 $3$ 的倍数的概率。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<std::array<int, 2>>());

    for (int i = 1; i < n; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    i64 ans = 0;

    std::vector<bool> vis(n + 1);
    std::vector<int> siz(n + 1), maxSize(n + 1);
    int root, tot;

    std::function<void(int, int)> findRoot = [&](int u, int pa) {
        maxSize[u] = 0;
        siz[u] = 1;
        for (auto [v, w] : adj[u]) {
            if (v == pa || vis[v]) {
                continue;
            }
            findRoot(v, u);
            maxSize[u] = std::max(maxSize[u], siz[v]);
            siz[u] += siz[v];
        }
        maxSize[u] = std::max(maxSize[u], tot - siz[u]);
        if (root == -1 || maxSize[u] < maxSize[root]) {
            root = u;
        }
    };

    std::function<void(int)> dfs = [&](int u) {
        root = -1;
        findRoot(u, 0);
        u = root;

        std::map<int, i64> pre;

        for (auto [v, w] : adj[u]) {
            if (vis[v]) {
                continue;
            }
            std::map<int, i64> now;

            std::function<void(int, int, int)> getChain = [&](int x, int pa, int sum) {
                now[sum] += 1;
                siz[x] = 1;
                if (sum == 0) {
                    std::cerr << x << " " << u;
                    ans += 1;
                }
                for (auto [y, w] : adj[x]) {
                    if (vis[y] || y == pa) {
                        continue;
                    }
                    getChain(y, x, (sum + w) % 3);
                    siz[x] += siz[y];
                }
            };

            getChain(v, u, w % 3);
            
            for (auto [l, cnt] : now) {
                int x = ((3 - l) % 3 + 3) % 3;
                if (pre.count(x)) {
                    ans += cnt * pre[x];
                }
            }
            for (auto [l, cnt] : now) {
                pre[l] += cnt;
            }
        }

        vis[u] = 1;
        for (auto [v, w] : adj[u]) {
            if (!vis[v]) {
                tot = siz[v];
                dfs(v);
            }
        }
    };

    tot = n;
    dfs(1);

    ans = ans * 2 + n;
    i64 ans2 = 1LL * n * n, g = std::gcd(ans, ans2);
    std::cout << ans / g << "/" << ans2 / g;

    return 0;
}
```



### 点分树（待完成）





## 虚树

算法本质：将给定关键点和根节点建成树，大树变小树，进而可以树形 dp。

原理：

- 虚树的欧拉序列在原树的欧拉序列中顺序不变；
- 而根据欧拉序列又可以确定唯一的DFS顺序进而还原原树。

关键

- **需要能够快速得到虚树的边权。通常需要倍增之类的预处理。**

过程：

- 预处理整棵树得到dfs序列，记为 $dfn[u]$。


- 使用一个栈，从栈顶到栈低的元素形成虚树的一条树链。


- 当我们得到一些关键点的时候，对这些点按照他们的 $dfn[u]$ 值进行排序，然后从 $dfn$ 值较小的开始扫描，结合栈中保存的树链信息就可以将这棵树构建出来。


- 假设我们当前扫到的关键点为 $u$ ，栈指针为 $top$ ，栈为 $stk$。

    1. 如果栈为空，或者栈中只有一个元素，那么应该 $top \leftarrow top + 1,\  stk[top]=u$；
    2. 取 $lca = (LCA(u, stk[top]))$，如果 $lca = stk[top]$，则说明 $u$ 点应该接着 $stk[top]$ 点延长当前的树链，进行操作 $top \leftarrow top +1,\ stk[top] = u$。
    3. 如果 $lca \ne stk[top]$ ，则说明 $u$ 与 $stk[top]$ 分属 $lca$ 的两棵子树，而且包含 $stk[top]$ 的这棵子树应该已经构建完成了，我们需要做的是：将 $lca$ 包含的 $stk[top]$ 子树的那部分退栈，并将这部分建边形成虚树。如果 $lca$ 不在栈中，那么要把 $lca$ 也加入栈中，保证虚树的结构不出现问题，随后将 $u$ 加入栈中，以表延长树链。


```cpp
//实现逐个将关键点插入形成一颗虚树
void insert(int u){
    if(top <= 1) {
        stk[++top] = u;
        return;
    }
    int lca = LCA(u,stk[top]);
    if(lca == stk[top]) {
        stk[++top] = u;
        return;
    }
    while(top > 1 && dfn[lca] <= stk[top-1]) {
        addedge(stk[top-1],stk[top]);
        --top;
    }
    if(lca != stk[top]) {
        stk[++top] = lca;
    }
    stk[++top] = u;
}
```



[P2495 [SDOI2011] 消耗战](https://www.luogu.com.cn/problem/P2495)

【题意】

给 $n$ 个点的树，有边权，以 $1$ 为根。 $q$ 次询问，每次询问给出 $k$ 个特殊点，求：删除若干条边，使得任何一个特殊点都无法到达根节点，输出删除边的点权和的最小值。

$n \le 2.5 \times 10^5$，$q \le 5\times 10^5$，$\sum k_i \le 5\times 10^5$。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector adj(n + 1, std::vector<std::array<int, 2>>());
    for (int i = 1; i < n; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    /***************************************************************/

    const int M = 22;
    std::vector<int> in(n + 1), dep(n + 1), minv(n + 1, 1e9);
    std::vector<std::array<int, M + 1>> fa(n + 1);
    int cur = 0;

    auto dfs1 = [&](auto self, int u, int pa) -> void {
        in[u] = ++cur;
        for (auto [v, w] : adj[u]) {
            if (v == pa) {
                continue;
            }
            dep[v] = dep[u] + 1;
            fa[v][0] = u;
            for (int i = 1; i <= M; i++) {
                fa[v][i] = fa[fa[v][i - 1]][i - 1];
            }
            minv[v] = std::min(minv[u], w);
            self(self, v, u);
        }
    };

    dfs1(dfs1, 1, 0);

    auto lca = [&](int u, int v) -> int {
        if (dep[u] < dep[v]) {
            std::swap(u, v);
        }
        int d = dep[u] - dep[v];
        for (int i = 0; i <= M; i++) {
            if (d & (1 << i)) {
                u = fa[u][i];
            }
        }
        for (int i = M; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        return u == v ? u : fa[u][0];
    };

    /***************************************************************/

    std::vector vtree(n + 1, std::vector<std::array<int, 2>>());
    std::vector<int> special(n + 1);

    int q;
    std::cin >> q;

    while (q--) {
        int k;
        std::cin >> k;
        std::vector<int> h(k + 1);
        h[0] = 1;
        special[h[1]] = true;
        for (int i = 1; i <= k; i++) {
            std::cin >> h[i];
            special[h[i]] = true;
        }

        std::sort(h.begin(), h.end(), [&](int x, int y) {
            return in[x] < in[y];
        });
        for (int i = 0; i < k; i++) {
            h.push_back(lca(h[i], h[i + 1]));
        }
        std::sort(h.begin(), h.end(), [&](int x, int y) {
            return in[x] < in[y];
        });
        h.erase(std::unique(h.begin(), h.end()), h.end());
        for (int x : h) {
            vtree[x].clear();
        }
        for (int i = 0; i < h.size() - 1; i++) {
            int u = lca(h[i], h[i + 1]);
            int v = h[i + 1];
            int w = minv[v];
            vtree[u].push_back({v, w});
            vtree[v].push_back({u, w});
        }

        auto dfs2 = [&](auto self, int u, int pa) -> i64 {
            i64 ans = 0;
            for (auto [v, w] : vtree[u]) {
                if (v == pa) {
                    continue;
                }
                if (special[v]) {
                    ans += w;
                    continue;
                }
                ans += std::min(1LL * w, self(self, v, u));
            }
            return ans;
        };

        std::cout << dfs2(dfs2, 1, 0) << "\n";

        for (int x : h) {
            special[x] = false;
        }
    }

    return 0;
}
```

