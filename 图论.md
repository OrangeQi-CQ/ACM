[TOC]



# Dijkstra 相关

## Dijkstra 算法

[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

要求无负环，复杂度 $(n + m)\log n$

```c++
    using PII = std::pair<i64, int>;

    auto Dijkstra = [&](int s) -> std::vector<i64> {
        std::vector<i64> dis(n + 1, INF);
        dis[s] = 0;
        std::priority_queue<PII, std::vector<PII>, std::greater<>> heap;
        heap.push({0LL, s});

        while (!heap.empty()) {
            auto [d, u] = heap.top();
            heap.pop();
            if (d > dis[u]) {
                continue;
            }
            for (auto [v, w] : adj[u]) {
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    heap.push({dis[v], v});
                }
            }
        }

        return dis;
    };
```

 dijkstra 的精髓在于：松弛操作。在松弛的时候可以做很多事情。

- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  求起点到每个点的最短路的数量。

```cpp
    if (dis[v] > dis[u] + 1) {
        dis[v] = dis[u] + 1;
        cnt[v] = cnt[u];
    } else if (dis[v] == dis[u] + 1) {
        cnt[v] += cnt[u];
    }
```

- 记录具体的最短路径（即 `vector<int> from(n + 1)`），进而构造出最短路树。

- [P2865 [USACO06NOV]Roadblocks G](https://www.luogu.com.cn/problem/P2865) 给无向图，求 $(1,n)$ 间的次短路。

```cpp
    if (dis[v][1] > d + w) {
        dis[v][1] = d + w;
        heap.push({dis[v][1], v});
    }
    if (dis[v][0] > dis[v][1]) {
        std::swap(dis[v][0], dis[v][1]);
    }
```

补充一道例题。[P1875 佳佳的魔法药水](https://www.luogu.com.cn/problem/P1875) 这道题有助于加深对 dijkstra 思想的理解。



## Johnson 算法

[P5905 【模板】Johnson 全源最短路](https://www.luogu.com.cn/problem/P5905)

有向图，边权可能为负。求任意两点最短路

其实就是从 $n$ 个点分别跑一次 Dijkstra，关键点是预处理给每个边权重新赋值。复杂度 $O(nm\log m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int INF = 1e9;
int n, m;
vector<vector<PII>> g;
vector<vector<int>> dis;

bool spfa(int s, vector<int> &dist) {
    vector<int> inq(n + 1, 0), cnt(n + 1, 0);
    queue<int> q;
    dist.assign(n + 1, INF);
    dist[s] = 0;
    q.push(s);
    inq[s] = 1;

    while (q.size()) {
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = 1;
                }
                if (cnt[v] > n) {
                    return false; // 会从s进入负环
                }
            }
        }
    }
    return true; //不会从 s 进入负环
}

void dijkstra(int s, vector<int> &dist) {
    dist.assign(n + 1, INF);
    dist[s] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, s});
    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dist[u]) {
            continue;
        }
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                heap.push({dist[v], v});
            }
        }
    }
}

void SolveTest() {
    cin >> n >> m;
    n++; // 新增一个虚拟节点
    g.assign(n + 1, {});
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
    }
    for (int i = 1; i < n; i++) {
        g[n].push_back({i, 0});
    }
    dis.assign(n + 1, vector<int>(n + 1));

    if (!spfa(n, dis[n])) {
        puts("-1");
        return;
    }
    // 重置边权
    for (int u = 1; u < n; u++) {
        for (auto &[v, w] : g[u]) {
            w += dis[n][u] - dis[n][v];
        }
    }
    for (int i = 1; i < n; i++) {
        dijkstra(i, dis[i]);
    }
    // 改回边权
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            if (dis[i][j] != INF) { // 特判两点是否可达
                dis[i][j] -= dis[n][i] - dis[n][j];
            }
        }
    }
    // 这里的 dis[i][j] 已经是任意两点距离了
    n--;
    for (int i = 1; i <= n; i++) {
        int ans = 0;
        for (int j = 1; j <= n; j++) {
            ans += 1ll * j * dis[i][j];
        }
        cout << ans << endl;
    }
}
/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}

```



## 同余最短路（不会）

[P3403 跳楼机](https://www.luogu.com.cn/problem/P3403) 

给定 $x,y,z,h$，对于 $k\in[1,h]$，求又多少个 $k$ 满足 $ax + by + cz = k$。（$a,b,c \ge 0$，$1\le x,y,z\le 10^5$，$h< 2^{63}$）。



# Bellman-Ford 算法

## 不超过 $k$ 条边的最短路

[Acwing 853. 有边数限制的最短路](https://www.acwing.com/problem/content/855/)

【题意】给一个有向图，可能有重边/自环/负环。求从 $1$ 号点到 $n$ 号点最多经过 $k$ 条边的最短路。

```cpp
#include <bits/stdc++.h>

using i64 = long long;
const int INF = 1e9;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m, k;
    std::cin >> n >> m >> k;
    std::vector<std::array<int, 3>> edge(m);
    for (int i = 0; i < m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        edge[i] = {u, v, w};
    }

    // dis[k][i] 表示经过不超过 k 条边从 1 到达 i 的最短路
    std::vector dis(k + 1, std::vector<int>(n + 1, INF));
    dis[0][1] = 0;

    for (int i = 1; i <= k; i++) {
        dis[i] = dis[i - 1];
        for (auto [u, v, w] : edge) {
            dis[i][v] = std::min(dis[i][v], dis[i - 1][u] + w);
        }
    }

    if (dis[k][n] > INF / 2) {
        std::cout << "impossible";
    } else {
        std::cout << dis[k][n];
    }

    return 0;
}
```



# 负环

## SPFA

[P3385 负环模板题](https://www.luogu.com.cn/problem/P3385)

判断能否从点 $s$ 进入负环。如果想判断全图负环，可以从一个超级源点向所有点连一条边权为 $0$ 的边。

```c++
    // 判断能否从 s 出发进入负环
    auto SPFA = [&](int s) -> bool {
        std::vector<i64> dis(n + 1, INF), cnt(n + 1);
        std::vector<bool> inq(n + 1);
        std::queue<int> que;

        dis[s] = 0;
        que.push(s);
        inq[s] = true;

        while (!que.empty()) {
            int u = que.front();
            que.pop();
            inq[u] = false;
            for (auto [v, w] : adj[u]) {
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    que.push(v);
                    inq[v] = true;
                }
                if (cnt[v] > n) {
                    return true;    // 会从 s 进入负环
                }
            }
        }
        return false;               // 不会从 s 进入负环
    };
```



## $01$ 分数规划

[P2868 [USACO07DEC]Sightseeing Cows G](https://www.luogu.com.cn/problem/P2868) 

【题意】给一张有点权 $f$ 有边权 $g$ 的有向图。对于图中一个环 $C$，定义它的价值为**环上点权和与环上边权和之比**。求图中所有环的最大价值。

【做法】二分答案 $mid$，将每条边的边权修改为 $mid\times f[v] - g$。如果图中存在负环，那么说明这个 $mid$ 是可以取到的。用 SPFA 判断负环。

```cpp
#include <bits/stdc++.h>

const int INF = 1e9;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector adj(n + 1, std::vector<std::pair<int, double>>());
    std::vector<double> f(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> f[i];
    }

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
    }

    auto check = [&](double x) -> bool {
        std::vector<int> inq(n + 1, 0), cnt(n + 1, 0);
        std::vector<double> dis(n + 1, INF);
        std::queue<int> q;

        for (int i = 1; i <= n; i++) {
            q.push(i);
            dis[i] = 0;
            inq[i] = 1;
        }

        while (q.size()) {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (auto [v, w] : adj[u]) {
                w = x * w - f[v];
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    if (!inq[v]) {
                        q.push(v);
                        inq[v] = 1;
                    }
                    if (cnt[v] > n) {
                        return true; // 会从s进入负环
                    }
                }
            }
        }
        return false; //不会从 s 进入负环
    };

    double l = 0, r = 1e9;
    while (r - l > 0.0001) {
        double mid = (l + r) / 2;
        if (check(mid)) {
            l = mid;
        } else {
            r = mid;
        }
    }

    std::cout << std::fixed << std::setprecision(2) << l;
    return 0;
}
```



## 	差分约束

将每个变量的值看成数轴上到 $0$ 的距离。

1. $x_a - x_b \le c$：连边 `add(b, a, c)`
2. $x_a - x_b \ge c \iff x_b-x_a \le -c$：连边 `add(a, b, -c)`
3. $x_a = x_b$：连边 `add(a, b, 0), add(b, a, 0);`

[P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960) 

【题意】给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：
$$
\begin{cases} x_{c_1}-x_{c'_1}\leq y_1 \\x_{c_2}-x_{c'_2} \leq y_2 \\ \cdots\\ x_{c_m} - x_{c'_m}\leq y_m\end{cases}
$$
的不等式组，求任意一组满足这个不等式组的解。如果有多组解输出任意一组，无解输出 `NO`。

【做法】建立一个超级源点 $s$，从超级源点向每个节点连一条边权为 $0$ 的边。从超级源点跑最短路，最后每个点的距离就是所求的未知量的一个解。如果有负环说明该不等式组无解。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

const i64 INF = 1e18;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    int s = ++n;
    std::vector adj(n + 1, std::vector<std::array<int, 2>>());

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[v].push_back({u, w});
    }
    for (int i = 1; i <= n; i++) {
        adj[s].push_back({i, 0});
    }

    // 判断能否从 s 出发进入负环
    auto SPFA = [&](int s, std::vector<i64> &dis) -> bool {
        dis.assign(n + 1, INF);
        std::vector<i64> cnt(n + 1);
        std::vector<bool> inq(n + 1);
        std::queue<int> que;

        dis[s] = 0;
        que.push(s);
        inq[s] = true;

        while (!que.empty()) {
            int u = que.front();
            que.pop();
            inq[u] = false;
            for (auto [v, w] : adj[u]) {
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    cnt[v] = cnt[u] + 1;
                    que.push(v);
                    inq[v] = true;
                }
                if (cnt[v] > n) {
                    return true;    // 会从 s 进入负环
                }
            }
        }
        return false;               // 不会从 s 进入负环
    };

    std::vector<i64> dis;
    if (SPFA(s, dis)) {
        std::cout << "NO";
    } else {
        for (int i = 1; i < n; i++) {
            std::cout << dis[i] << " ";
        }
    }
    return 0;
}
```





# Floyd 相关

## 全源最短路及计数

[P2047 [NOI2007] 社交网络](https://www.luogu.com.cn/problem/P2047) 

【题意】给定无向图（$n\le 100$），定义 $C_{s,t}$ 为 $(s,t)$ 间最短路数量，定义 $C_{s,t}(v)$ 为 $(s,t)$ 间经过 $v$ 的最短路数量。现在需要对所有点 $v$ 求出 $\sum_{v\ne s, v\ne t}\dfrac{C_{s,t}(v)}{C_{s,t}}$。

【思路】首先可以用 Floyd 算法求出两点间距离以及最短路数量，见代码中的 $dis$ 和 $cnt$。至于 $(s,t)$ 之间经过点 $v$ 的最短路数目，答案就是 $cnt[s][v] \times cnt[v][t]$。

所以本题实质上是求任意两点间最短路的距离，以及最短路的数量。

```cpp
    // 核心部分，用 floyd 算法求两点间最短路以及最短路的数量
    for (int k = 1; k <= n; k++) {
        for (int i = 1;i <= n; i++) {
            for (int j = 1;j <= n; j++) {
                if (dis[i][k] == INF && dis[k][j] == INF) {
                    continue;
                }
                if (dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    cnt[i][j] = cnt[i][k] * cnt[k][j];
                } else if (dis[i][j] == dis[i][k] + dis[k][j]) {
                    cnt[i][j] += cnt[i][k] * cnt[k][j];
                }
            }
        }
    }
```



## 传递闭包

传递所有点的可达性。

[B3611 【模板】传递闭包](https://www.luogu.com.cn/problem/B3611) 

【题意】给一个图的邻接矩阵，输出任意两点是否可达。

```c++
    int n;
    vector<bitset<N>> f(n + 1);

    for (int j = 1; j <= n; j++) {
        for (int i = 1; i <= n; i++) {
            if (f[i][j]) {
                f[i] |= f[j];
            }
        }
    }
```

补充例题：[P2419 [USACO08JAN]Cow Contest S](https://www.luogu.com.cn/problem/P2419) $n$ 个元素，给出 $m$ 组两个元素的严格大小关系。判断有多少个数字的排名是确定的。

思路是通过传递闭包，我们可以得到对于每一个元素，有 $x$ 个元素比他大，以及有 $y$ 个元素比他小。若 $x + y = n - 1$ 那么该元素的排名就确定了。



## 恰好 $k$ 条边的最短路

[P2886 [USACO07NOV]Cow Relays G](https://www.luogu.com.cn/problem/P2886) 

【题意】无向连通图 $(n \le 200)$，求两点间经过恰好 $k$（$k\le 10^6$）条边的最短路。

【思路】假设矩阵 $F_x[i][j]$ 储存从 $i$ 到 $j$ 经过 $x$ 条边的最短路。而原始的邻接矩阵 $g[i][j]$ 即为 $F_1[i][j]$。那么有 $F_{x + y}[i][j] = \min(F_{x+y}[i][j], F_x[i][k] + F_y[k][j])$。这个过程可以矩阵加速。

```cpp
#include <bits/stdc++.h>

using i64 = long long;
const int INF = 1e9;
const int N = 205;
using Matrix = std::array<std::array<int, N + 1>, N + 1>;

Matrix operator* (Matrix lhs, Matrix rhs) {
    Matrix res = {};
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            res[i][j] = INF;
        }
    }
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            for (int k = 1; k <= N; k++) {
                res[i][j] = std::min(res[i][j], lhs[i][k] + rhs[k][j]);
            }
        }
    }
    return res;
}

Matrix qpow(Matrix x, int k) {
    auto res = x;
    k--;
    while (k) {
        if (k % 2) {
            res = res * x;
        }
        k /= 2;
        x = x * x;
    }
    return res;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m, k, s, t;

    std::map<int, int> mp;
    auto getid = [&](int x) {   // 本题需要对点编号离散化
        if (mp[x] == 0) {
            mp[x] = ++n;
        }
        return mp[x];
    };
    
    std::cin >> k >> m >> s >> t;
    s = getid(s), t = getid(t);
    
    Matrix dis;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            dis[i][j]=  INF;
        }
    }
    
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> w >> u >> v;
        u = getid(u);
        v = getid(v);
        dis[u][v] = dis[v][u] = w;
    }

    auto res = qpow(dis, k);
    std::cout << res[s][t];

    return 0;
}
```



# 最小环

[P6175 无向图的最小环问题](https://www.luogu.com.cn/problem/P6175) 

【题意】给无向图，求最小环。

## Floyd：稠密图最小环

复杂度 $O(n^3)$

```c++
#include <bits/stdc++.h>

using i64 = long long;
const i64 INF = 1e18;

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector g(n + 1, std::vector<i64>(n + 1, INF));
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        g[u][v] = g[v][u] = std::min(g[u][v], 1LL * w);
    }
    for (int i = 1; i <= n; i++) {
        g[i][i] = 0;
    }

    auto Floyd = [&]() -> i64{
        auto dis = g;
        i64 res = INF;
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i < k; i++) {
                for (int j = 1; j < i; j++) {
                    res = std::min(res, dis[i][j] + g[i][k] + g[k][j]);
                }
            }
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }
        return res;
    };

    i64 ans = Floyd();

    if (ans == INF) {
        std::cout << "No solution.";
    } else {
        std::cout << ans;
    }

    return 0;
}
```



## Dijkstra：稀疏图最小环

枚举每条边 $(u,v)$ ，删掉它之后在图上从 $u$ 到 $v$ 的最短路距离。复杂度 $O(m(m+n)\log n)$

```cpp
#include <bits/stdc++.h>

using i64 = long long;
const i64 INF = 1e18;

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<std::array<int, 2>>> adj(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    i64 ans = INF;

    auto Dijkstra = [&](int s, int t) -> i64 {
        std::vector<i64> dis(n + 1, INF);
        dis[s] = 0;
        using PII = std::pair<i64, int>;
        std::priority_queue<PII, std::vector<PII>, std::greater<>> heap;
        heap.push({0, s});

        while (!heap.empty()) {
            auto [d, u] = heap.top();
            heap.pop();
            if (d > dis[u]) {
                continue;
            }
            for (auto [v, w] : adj[u]) {
                if (u == s && v == t) {
                    continue;
                }
                if (dis[u] + w < dis[v]) {
                    dis[v] = dis[u] + w;
                    heap.push({dis[v], v});
                }
            }
        }

        return dis[t];
    };

    for (int u = 1; u <= n; u++) {
        for (auto [v, w] : adj[u]) {
            ans = std::min(ans, w + Dijkstra(u, v));
        }
    }

    if (ans == INF) {
        std::cout << "No solution.";
    } else {
        std::cout << ans;
    }

    return 0;
}
```



## BFS：无权图最小环

[CF1817B. Fish Graph](https://codeforces.com/contest/1817/problem/B)

【题意】定义一个无向图是 `Fish Graph`：存在一个环，环上某点连向两个不在环上的点。给一个无向图，判断是否为 `Fish Graph`。$n,m\le 2000$，没有重边和自环。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

void solve() {
    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<int>> adj(n + 1);

    for (int i = 1; i <= m; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    for (int s = 1; s <= n; s++) {
        if (adj[s].size() < 4) {
            continue;
        }
        std::vector<std::array<int, 2>> edge;

        auto bfs = [&]() -> bool {
            std::vector<int> from(n + 1), tag(n + 1);
            std::vector<bool> vis(n + 1), incircle(n + 1);
            std::queue<int> que;
            que.push(s);
            incircle[s] = 1;
            vis[s] = 1;

            for (int i = 0; i < adj[s].size(); i++) {
                int v = adj[s][i];
                tag[v] = i + 1;
            }

            while (!que.empty()) {
                int u = que.front();
                que.pop();
                for (int v : adj[u]) {
                    if (v == from[u]) {
                        continue;
                    }
                    if (vis[v] && tag[v] != tag[u]) {
                        edge.push_back({u, v});
                        int cur = u;
                        while (cur != s) {
                            edge.push_back({from[cur], cur});
                            incircle[cur] = 1;
                            cur = from[cur];
                        }
                        cur = v;
                        while (cur != s) {
                            edge.push_back({from[cur], cur});
                            incircle[cur] = 1;
                            cur = from[cur];
                        }
                        std::set<int> tmp;
                        for (int x : adj[s]) {
                            if (!incircle[x]) {
                                tmp.insert(x);
                            }
                            if (tmp.size() == 2) {
                                break;
                            }
                        }
                        for (int x : tmp) {
                            edge.push_back({s, x});
                        }
                        return true;

                    } else if (!from[v]) {
                        vis[v] = 1;
                        from[v] = u;
                        if (u != s) {
                            tag[v] = tag[u];
                        }
                        que.push(v);
                    }
                }
            }

            return false;
        };

        if (bfs()) {
            std::cout << "YES\n" << edge.size() << "\n";
            if (edge.size()) {
                for (auto [u, v] : edge) {
                    std::cout << u << " " << v << "\n";
                }
            }
            return;
        }
    }

    std::cout << "NO\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```



# 最小生成树

[P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)

## Prim 算法

比较适合稠密图，复杂度 $O(n^2 +m)$

```c++
#include <bits/stdc++.h>

using i64 = long long;
int INF = 1e9;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<std::array<int, 2>>> adj(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }
    
    auto Prim = [&]() -> i64 {
        std::vector<int> dis(n + 1, 1e9);
        std::vector<bool> vis(n + 1);
        dis[1] = 0;
        i64 res = 0;

        for (int i = 1; i <= n; i++) {
            int u = std::min_element(dis.begin() + 1, dis.end()) - dis.begin();
            if (dis[u] == INF) {
                return -1;
            }
            res += dis[u];
            for (auto [v, w] : adj[u]) {
                if (!vis[v]) {
                    dis[v] = std::min(dis[v], w);
                }
            }
            dis[u] = INF;
            vis[u] = true;
        }
        return res;
    };

    int ans = Prim();
    if (ans == -1) {
        std::cout << "orz";
    } else {
        std::cout << ans;
    }

    return 0;
}
```



## Kruscal 算法

适用于稀疏图，复杂度 $O(m\log m)$。

```c++
#include <bits/stdc++.h>

using i64 = long long;

struct DSU {
    int n;
    std::vector<int> fa, siz;
    DSU(int _n) : n(_n), fa(n + 1), siz(n + 1, 1) {
        std::iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    bool merge(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) {
            return false;
        }
        fa[x] = y;
        siz[y] += siz[x];
        return true;
    }
    int size(int x) {
        return siz[find(x)];
    }
};

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::array<int, 3>> edge;

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        edge.push_back({w, u, v});
    }

    auto Kruscal = [&]() -> i64 {
        std::sort(edge.begin(), edge.end());
        i64 res = 0;
        DSU dsu(n + 1);
        for (auto [w, u, v] : edge) {
            if (dsu.merge(u, v)) {
                res += w;
            }
        }
        if (dsu.size(1) < n) {
            return -1;
        }
        return res;
    };

    int res = Kruscal();
    if (res == -1) {
        std::cout << "orz";
    } else {
        std::cout << res;
    }

    return 0;
}
```



## Watering Hole 模型

自己乱起的名字，源自于这一道题 [P1550 [USACO08OCT]Watering Hole G](https://www.luogu.com.cn/problem/P1550) 。题意是 $n$ 个点，将一个点设为水井的花费是 $W_i$ ，将两个点相连的花费是 $g[i][j]$。现在需要保证任何一个点都能通过若干条路径到达一个水井，求最小花费。

做法是新建一个超级源点，想象为水源。从这个超级源点向所有点连一条边，边权为在该点打通水井的花费。然后跑最小生成树。

更典型的是这一道题 [1245D. Shichikuji and Power Grid](https://codeforces.com/contest/1245/problem/D) 。题意类似，但是需要输出挑选了哪些点和哪些边构成最后的图。只需要在Prim 的时候记录每条个点是最后是被哪一个点松弛的。

```cpp
int ans = 0;
std::vector<int> dis(n + 1, INF), vis(n + 1), from(n + 1);
dis[n] = 0;

std::vector<int> ans1;
std::vector<std::pair<int, int>> ans2;
for (int i = 1; i <= n; i++) {
    int u = -1;
    for (int j = 1; j <= n; j++) {
        if (!vis[j] && (u == -1 || dis[u] > dis[j])) {
            u = j;
        }
    }
    if (u != n) { // 本题中 n 是超级源点
        if (from[u] == n) { // 这个点是单独挑选出来的
            ans1.push_back(u);
        } else { // 记录图中的边
            ans2.push_back({from[u], u});
        }
    }
    ans += dis[u];
    vis[u] = 1;
    for (int j = 1; j <= n; j++) {
        if (g[u][j] < dis[j]) {
            dis[j] = g[u][j];
            from[j] = u;
        }
    }
}
```



## 瓶颈生成树 / 最小瓶颈路

【概念】：瓶颈生成树

无向图 $G$ 的瓶颈生成树满足：它的**最大边的权值在 $G$ 的所有生成树当中最小。**

- 最小生成树 是 瓶颈生成树 的充分不必要条件。

【概念】：最小瓶颈路

无向图 $G$ 中从 $x$ 到 $y$ 的最小瓶颈路满足：这条路径上最大的边权在从 $x$ 到 $y$ 中的所有路径中是最小的。

- 无向图 $G$ 中**从 $x$ 到 $y$ 的最小瓶颈路上的最大边权 $=$ $G$的最小生树上从 $x$ 到 $y$ 的路径的最大边权**


类似的，以 [P1967 [NOIP2013 提高组] 货车运输](https://www.luogu.com.cn/problem/P1967) 为例，题目要求**任意两点间路径最小边权的最大值**。那么就求最大生成树，用树上倍增求树上两点间路径边权最小值。



## 次小生成树

次小生成树：枚举每一条不在最小生成树当中的边 $(u,v,w)$。查找最小生成树当中路径 $(u,v)$ 当中**最大边权 $t$**。用 $w$ 替换 $t$ 更新答案。可以用树上倍增求路径最大边权。

严格次小生成树：枚举每一条不在最小生成树当中的边 $(u,v,w)$。查找最小生成树当中路径 $(u,v)$ 当中**严格次大边权 $t$**。用 $w$ 替换 $t$ 更新答案。

树上路径的严格次大边权也可以用树上倍增解决。

[P4180 [BJWC2010] 严格次小生成树](https://www.luogu.com.cn/problem/P4180)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define all(a) a.begin(),a.end()
#define endl "\n"

int Testnum = 1;
/**********************  Core code begins  **********************/

const int M = 25, INF = 1e18;
int n, m;

struct DSU {
    int n;
    vector<int> fa, siz;
    DSU(int _n) : n(_n), fa(n + 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return;
        }
        fa[x] = y;
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
};


struct Tree {
    int n;
    vector<vector<PII>> g;
    vector<int> dep, val;
    vector<array<int, M>> fa, max1, max2;
    Tree(int _n) :
        n(_n), g(n + 1), dep(n + 1), val(n + 1),
        fa(n + 1), max1(n + 1), max2(n + 1) {
    }

    void add(int u, int v, int w) {
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }

    void dfs1(int u, int pa) {
        dep[u] = dep[pa] + 1;
        fa[u][0] = pa;
        max1[u][0] = val[u];
        max2[u][0] = -INF;
        for (int i = 1; i < M; i++) {
            fa[u][i] = fa[fa[u][i - 1]][i - 1];
            int tmp[4] = {max1[u][i - 1], max1[fa[u][i - 1]][i - 1],
                          max2[u][i - 1], max2[fa[u][i - 1]][i - 1]};
            sort(tmp, tmp + 4);
            max1[u][i] = tmp[3];
            int p = 2;
            while (p >= 0 && tmp[p] == tmp[3]) {
                p--;
            }
            max2[u][i] = (p == -1 ? INF : tmp[p]);
        }

        for (auto [v, w] : g[u]) {
            if (v == pa) {
                continue;
            }
            val[v] = w;
            dfs1(v, u);
        }
    }

    // 查询 (u, v) 路径上严格小于 value 的最大边权
    int query(int u, int v, int value) {
        if (dep[u] < dep[v]) {
            swap(u, v);
        }

        auto get = [&](int x, int i)->int {
            return (max1[x][i] == value) ? max2[x][i] : max1[x][i];
        };

        int ans = -INF;
        int t = dep[u] - dep[v];
        for (int i = 0; i < M; i++) {
            if (t & (1 << i)) {
                ans = max(ans, get(u, i));
                u = fa[u][i];
            }
        }
        if (u == v) {
            return ans;
        }
        for (int i = M - 1; i >= 0; i--) {
            if (fa[u][i] != fa[v][i]) {
                ans = max({ans, get(u, i), get(v, i)});
                u = fa[u][i];
                v = fa[v][i];
            }
        }
        ans = max({ans, max1[u][0], max1[v][0]});
        return ans;
    }
};

void SolveTest() {
    cin >> n >> m;
    vector<tuple<int, int, int>> edge(m);
    vector<int> used(m);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edge[i - 1] = {u, v, w};
    }

    sort(edge.begin(), edge.end(), [&](auto x, auto y) {
        return get<2>(x) < get<2>(y);
    });

    DSU dsu(n);
    Tree tr(n);

    int ans = 0;
    for (int i = 0; i < m; i++) {
        auto [u, v, w] = edge[i];
        if (dsu.same(u, v)) {
            continue;
        }
        ans += w;
        dsu.merge(u, v);
        used[i] = 1;
        tr.add(u, v, w);
    }

    tr.dfs1(1, 0);
    int res = INF;

    for (int i = 0; i < m; i++) {
        if (used[i]) {
            continue;
        }
        auto [u, v, w] = edge[i];
        int tmp = tr.query(u, v, w); // 查询路径 (u, v) 上严格小于 w 的最大边权
        if (tmp != -INF) {
            res = min(res, ans + w - tmp);
        }
    }
    cout << res << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // cin >> Testnum;
    for (int i = 1; i <= Testnum; i++) {
        SolveTest();
    }
    return 0;
}
```



## Kruscal 重构树

性质：原图上 $(u, v)$ 的瓶颈路最大边 $=$ Kruscal 重构树 $LCA(u, v)$ 的点权

[#137. 最小瓶颈路（加强版）](https://loj.ac/p/137) kruscal 重构树模板题。给定 $n$ 个点 $m$ 条边的无向连通图，可能有重边，有正边权 。$m$ 次询问，求从 $u$ 到 $v$ 的路径上边权的最大值最小。

```cpp
#include <bits/stdc++.h>
#define int long long
#define PII pair<int, int>

struct DSU {
    int n;
    std::vector<int> fa;
    DSU(int _n) : n(_n), fa(n + 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            fa[x] = y;
        }
    }
};

// 特化的 ST 表
struct RMQ {
    int n;
    std::vector<std::vector<int>> f;

    // 要求 init 的下标从 1开始，把 init[0] 空出来
    void init(const std::vector<int> &init) {
        n = init.size() - 1;
        int lg = std::__lg(n);
        f.assign(n + 1, std::vector<int>(lg + 1));
        for (int i = 1; i <= n; i++) {
            f[i][0] = init[i];
        }
        for (int j = 1; j <= lg; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                f[i][j] = std::min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
            }
        }
    }

    int rangeQuery(int l, int r) {
        int s = std::__lg(r - l + 1);
        return std::min(f[l][s], f[r - (1 << s) + 1][s]);
    }
};

struct Tree {
    int n, dfncnt = 0;
    std::vector<int> val, Eu, pos, dep;
    std::vector<std::vector<int>> adj;
    RMQ rmq;
    Tree(int _n) : n(_n) {
        val.assign(n * 2 + 1, 0);
        Eu = pos = dep = val;
        adj.assign(n + 1, {});
    }
    void add(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    void pre() {
        dfs1(n, 0, 1);
        std::vector<int> tmp = pos;
        for (int i = 1; i <= dfncnt; i++) {
            tmp[i] = pos[Eu[i]];
        }
        rmq.init(tmp);
    }
    void dfs1(int u, int pa, int depth) {
        Eu[++dfncnt] = u;
        pos[u] = dfncnt;
        dep[dfncnt] = depth; // 将 dfn 映射为深度
        for (int v : adj[u]) {
            if (v == pa) {
                continue;
            }
            dfs1(v, u, depth + 1);
            Eu[++dfncnt] = u;
            dep[dfncnt] = depth;
        }
    }
    int lca(int u, int v) {
        int l = pos[u], r = pos[v];
        if (l > r) {
            std::swap(l, r);
        }
        return Eu[rmq.rangeQuery(l, r)];
    }
};


signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::array<int, 3>> edge(m);
    for (int i = 0; i < m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        edge[i] = {u, v, w};
    }
    sort(edge.begin(), edge.end(), [&](auto x, auto y) {
        return x[2] < y[2];
    });

    // 下面是 kruscal 重构树的建树过程
    DSU dsu(4 * n); // 并查集一定要开大，因为 n 只是二叉树的叶子个数
    Tree tr(4 * n);
    tr.n = n;
    for (int i = 0; i < m; i++) {
        auto [u, v, w] = edge[i];
        u = dsu.find(u);
        v = dsu.find(v);
        if (u == v) {
            continue;
        }
        int tmp = ++tr.n;
        tr.val[tmp] = w;
        tr.add(u, tmp);
        tr.add(v, tmp);

        dsu.merge(u, tmp); // 这里合并的方向一定不能反，否则是错的
        dsu.merge(v, tmp);
    }

    tr.pre(); // 预处理

    int q, A, B, C, P, res = 0, MOD = 1e9 + 7;
    std::cin >> q >> A >> B >> C >> P;

    while (q--) {
        auto rnd = [&]() {
            return A = (A * B + C) % P;
        };
        int u = rnd() % n + 1, v = rnd() % n + 1;
        if (u == v) {
            continue;
        }
        int ans = tr.val[tr.lca(u, v)];
        res = (res + ans) % MOD;
    }
    std::cout << res << "\n";

    return 0;
}
```





# 拓扑排序 / DAG判定

## Kahn 算法

- 能拓扑排序 $\iff$ 图是 DAG


- Kahn 算法：复杂度 $O(n + m)$

如果需要求字典序最大/最小的拓扑排序，则把队列换为堆。

```c++
vector<int> topo;

bool toposort() {
    vector<int> tmp = ind; // ind 是节点的入度
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (tmp[i] == 0) {
            q.push(i);
        }
    }
    while (q.size()) {
        int u = q.front();
        topo.push_back(u);
        q.pop();
        for (int v : g[u]) {
            if (--tmp[v] == 0) {
                q.push(v);
            }
        }
    }
    return topo.size() == n;
};
```





# 连通性

概念：

有向图
- 强连通：内部的任意点**互相**可达。
- 弱连通：将该图中所有边替换为无向边，将得到一张连通图

无向图
- 割点：如果删除一个点，图中连通块数量增加，则该点为割点。
- 点双连通：没有割点的连通图。
- 桥：对于某条边，如果删除它后图中连通块数量增加，则该边为桥。
- 边双连通：没有桥的连通图。对于一个边双连通分量，任意两点间至少有两条没有公共边的路径。

注意：任何一个桥的两边都不一定是割点，任何一个割点相邻的边也不一定是桥。二者没有任何本质关系。

## 强连通分量 + 缩点

这是一种模型，常见的套路是：tarjan 强连通分量 + 缩点 + 拓扑排序 + DP 。

注意：**tarjan 缩点后自带拓扑序，所以不需要重新拓扑排序。**

```cpp
using Graph = std::vector<std::vector<int>>;

int tarjan(const Graph &adj, std::vector<int> &bel) {
    int cur = 0, scccnt = 0, n = adj.size() - 1;
    bel.assign(n + 1, 0);
    std::vector<int> dfn(n + 1), low(n + 1), stk;

    auto dfs = [&](auto self, int u) -> void {
        dfn[u] = low[u] = ++cur;
        stk.push_back(u);
        for (int v : adj[u]) {
            if (dfn[v] == 0) {
                self(self, v);
                low[u] = std::min(low[u], low[v]);
            } else if (bel[v] == 0) {
                low[u] = std::min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            scccnt++;
            int v;
            do {
                v = stk.back();
                stk.pop_back();
                bel[v] = scccnt;
            } while (u != v);
        }

    };

    for (int i = 1; i <= n; i++) {
        if (dfn[i] == 0) {
            dfs(dfs, i);
        }
    }
    return scccnt;
}
```



例题：[P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

【题意】给有向图，求一条路径，使得经过点权和最大。每个点可重复经过，但是只计算一次权值。输出该最大值。

```c++
#include <bits/stdc++.h>

using i64 = long long;
using Graph = std::vector<std::vector<int>>;

int tarjan(const Graph &adj, std::vector<int> &bel) {
    int cur = 0, scccnt = 0, n = adj.size() - 1;
    bel.assign(n + 1, 0);
    std::vector<int> dfn(n + 1), low(n + 1), stk;

    auto dfs = [&](auto self, int u) -> void {
        dfn[u] = low[u] = ++cur;
        stk.push_back(u);
        for (int v : adj[u]) {
            if (dfn[v] == 0) {
                self(self, v);
                low[u] = std::min(low[u], low[v]);
            } else if (bel[v] == 0) {
                low[u] = std::min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            scccnt++;
            int v;
            do {
                v = stk.back();
                stk.pop_back();
                bel[v] = scccnt;
            } while (u != v);
        }

    };

    for (int i = 1; i <= n; i++) {
        if (dfn[i] == 0) {
            dfs(dfs, i);
        }
    }
    return scccnt;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;
    std::vector<i64> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }
    Graph g1(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v;
        std::cin >> u >> v;
        g1[u].push_back(v);
    }

    std::vector<int> bel;
    int tot = tarjan(g1, bel);
    Graph g2(tot + 1);
    std::vector<i64> val(tot + 1);

    for (int i = 1; i <= n; i++) {
        val[bel[i]] += a[i];
        for (int j : g1[i]) {
            if (bel[i] != bel[j]) {
                g2[bel[i]].push_back(bel[j]);
            }
        }
    }

    std::vector<i64> dp(tot + 1);
    for (int u = 1; u <= tot; u++) {
        dp[u] = val[u];
        for (int v : g2[u]) {
            dp[u] = std::max(dp[u], dp[v] + val[u]);
        }
    }
    std::cout << *std::max_element(dp.begin() + 1, dp.end());

    return 0;
}
```

典型题目

- [P2835 刻录光盘](https://www.luogu.com.cn/problem/P2835)
- [P1073 [NOIP2009 提高组] 最优贸易](https://www.luogu.com.cn/problem/P1073) 是该思想的典型例题。



## 点双连通分量 + 求割点

概念：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。

[P3388 【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)给无向图，求割点个数，并输出所有割点。

结论：割点的两种情形

- 是 dfs 树的根节点，并且有至少两个子树
- 不是 dfs 树的根节点，能回溯到的最小 `dfn` 值大于它自身的 `dfn` 值

```c++
#include <bits/stdc++.h>

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<int>> adj(n + 1);
    for (int i = 1; i <= m; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    std::vector<int> dfn(n + 1), low(n + 1), cut;
    std::vector<bool> iscut(n + 1);
    int cur = 0;

    std::function<void(int, int)> dfs = [&](int u, int root) {
        dfn[u] = low[u] = ++cur;
        int child = 0;
        for (int v : adj[u]) {
            if (!dfn[v]) {
                dfs(v, u);
                low[u] = std::min(low[u], low[v]);
                if (u == root) {
                    child++;
                } else if (u != root && low[v] >= dfn[u]) {
                    iscut[u] = 1;
                }
            } else {
                low[u] = std::min(low[u], dfn[v]);
            }
        }
        if (u == root && child >= 2) {
            iscut[u] = 1;
        }
        if (iscut[u]) {
            cut.push_back(u);
        }
    };

    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            dfs(i, i);
        }
    }

    std::cout << cut.size() << "\n";
    std::sort(cut.begin(), cut.end());
    for (int x : cut) {
        std::cout << x << " ";
    }

    return 0;
}
```



## 边双连通分量 + 求桥 + 缩点

求边双连通分量和求强连通分量基本一样。保证每条边（包括反向边）都只走一遍。

特别的，一个无向图进行边双连通分量缩点之后，是一个无向无环图——就是一棵树，称为**桥树**。

[P2860 [USACO06JAN]Redundant Paths G](https://www.luogu.com.cn/problem/P2860)

题意：给定一个无向连通图（$n\le 5000$），至少添加几条边可以满足图中任意两点之间都至少有两条没有公共边的路径。

做法：求边双连通分量并缩点，找缩点之后度数为 $1$ 的点个数除以 $2$。


```c++
#include <bits/stdc++.h>

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<int>> adj(n + 1);
    std::vector<int> e;

    auto addEdge = [&](int u, int v) {
        adj[u].push_back(e.size());
        e.push_back(v);
    };

    for (int i = 1; i <= m; i++) {
        int u, v;
        std::cin >> u >> v;
        addEdge(u, v);
        addEdge(v, u);
    }

    int dfncnt = 0, dcccnt = 0;
    std::vector<int> dfn(n + 1), low(n + 1), bel(n + 1);
    std::vector<int> isbridge(e.size() + 1), vis(e.size() + 1);
    std::stack<int> stk;

    std::function<void(int)> dfs = [&](int u) {
        dfn[u] = low[u] = ++dfncnt;
        stk.push(u);
        for (int i : adj[u]) {
            if (vis[i]) {
                continue;
            }
            vis[i] = vis[i ^ 1] = 1;
            int v = e[i];
            if (dfn[v] == 0) {
                dfs(v);
                low[u] = std::min(low[u], low[v]);
                if (dfn[u] < low[v]) {
                    isbridge[i] = isbridge[i ^ 1] = 1;
                }
            } else if (bel[v] == 0) {
                low[u] = std::min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            dcccnt++;
            int v;
            do {
                v = stk.top();
                stk.pop();
                bel[v] = dcccnt;
            } while (u != v);
        }
    };

    dfs(1); // 本题保证了连通

    std::vector<int> deg(dcccnt + 1);   // 记录缩点后每个 dcc 的度数

    std::function<void(int)> dfs2 = [&](int u) {
        for (int i : adj[u]) {
            if (vis[i] == 1) {
                continue;
            }
            vis[i] = vis[i ^ 1] = 1;
            int v = e[i];
            if (bel[u] != bel[v]) {
                deg[bel[u]]++;
                deg[bel[v]]++;
            }
            dfs2(v);
        }
    };

    vis.assign(e.size() + 1, 0);
    dfs2(1); // 本题保证了连通

    int ans = count_if(deg.begin(), deg.end(), [](int x) {
        return x == 1;
    });
    std::cout << (ans + 1) / 2;
    return 0;
}
```



## 圆方树（不会）



## 2-SAT

[P4782 【模板】2-SAT 问题](https://www.luogu.com.cn/problem/P4782) 

【题意】对于 $n$ 个布尔变量，给出 $m$ 组约束。每一组约束的形式是 “$x= v_x \or y=v_y$”。 其中 $v$ 的取值是 $0/1$。试将每一个变量赋值，满足所有约束。

另一种常见的表述是 $x\  \& \ y=flase$。这其实等价于 $x=0 \or y=0$。

$Solution:$

将每个点拆开，点 $x$ 表示 $x=1$ ，点 $x+n$ 表示 $x=0$。

对于一组约束，假设 $x=1 \or y=1$ ，连两条边边 $(x+n,y)$，$(x,y+n)$。意思是如果 $x=0$ 则 $y=1$，如果 $y=0$ 则 $x=1$。类似地可以得出其他情形的连边方法。

这里可以通过位运算简化代码，将四种情况一起建图：

```cpp
for (int i = 1; i <= m; i++) {
    int x, vx, y, vy;
    cin >> x >> vx >> y >> vy;
    g[x + n * (vx & 1)].push_back(y + n * (vy ^ 1));
    g[y + n * (vy & 1)].push_back(x + n * (vx ^ 1));
}
```

如果某个变量 $x$ 必须为 $1$，那么就连边 $(x+n,x)$。连边的含义是推导的过程，如果从 $x=1$ 推导出 $x=0$，那么说明 $x$ 只能为 $0$。而如果从 $x$ 走到 $x+n$，又从 $x+n$ 走到 $x$，那么就会造成矛盾。

所以我们进行 Tarjan 缩点。同一个强连通分量里面的变量一定相等。所以对于某个变量 $x$ ，如果点 $x$ 和 $x+n$ 在同一个强连通分量内，那么这个图就是无解的。反之一定有解。因为在 tarjan 缩点的时候，**$id$ 序列已经是所点之后的图的拓扑序的逆序**，所以如果 $id[x] < id[x + n]$ 则让该变量为 $1$。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, m;
    std::cin >> n >> m;

    std::vector adj(n * 2 + 1, std::vector<int>());
    for (int i = 1; i <= m; i++) {
        int x, vx, y, vy;
        std::cin >> x >> vx >> y >> vy;
        adj[x + n * (vx & 1)].push_back(y + n * (vy ^ 1));
        adj[y + n * (vy & 1)].push_back(x + n * (vx ^ 1));
    }

    int cur = 0, scc = 0;
    std::vector<int> in(n * 2 + 1), low(n * 2 + 1), id(n * 2 + 1);
    std::stack<int> stk;
    std::vector<bool> instk(n * 2 + 1);

    auto dfs = [&](auto self, int u) -> void {
        in[u] = low[u] = ++cur;
        stk.push(u);
        instk[u] = true;
        for (int v : adj[u]) {
            if (!in[v]) {
                self(self, v);
                low[u] = std::min(low[v], low[u]);
            } else if (instk[v]) {
                low[u] = std::min(low[u], in[v]);
            }
        }
        if (low[u] == in[u]) {
            ++scc;
            while (1) {
                int v = stk.top();
                stk.pop();
                instk[v] = false;
                id[v] = scc;
                if (v == u) {
                    break;
                }
            }
        }
    };

    for (int i = 1; i <= n * 2; i++) {
        if (!in[i]) {
            dfs(dfs, i);
        }
    }

    for (int i = 1; i <= n; i++) {
        if (id[i] == id[i + n]) {
            std::cout << "IMPOSSIBLE";
            return 0;
        }
    }
    std::cout << "POSSIBLE\n";
    for (int i = 1; i <= n; i++) {
        std::cout << (id[i] < id[i + n]) << " ";
    }

    return 0;
}
```



# 欧拉图

一般出现在构造题当中。

## 有向图欧拉路径

有向图存在**欧拉路径**的充要条件（二选一）：

- 所有点的出度 $=$ 出度；
- 只有两个点的入度 $\ne$ 出度：一个满足出度比入度多 $1$（起点），另一个满足入度比出度多 $1$（终点）。

存在**欧拉回路**的充要条件

- 所有点的出度等于入度。

[P7771 【模板】欧拉路径](https://www.luogu.com.cn/problem/P7771) 给有向图，求字典序最小的欧拉路径。

需要理解为什么要后序填入答案并倒序输出。

```cpp
#include <bits/stdc++.h>
#define int long long

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<int>> adj(n + 1);
    std::vector<int> ind(n + 1), oud(n + 1);

    for (int i = 1; i <= m; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        ind[v]++;
        oud[u]++;
    }

    for (int i = 1; i <= n; i++) {
        std::sort(adj[i].begin(), adj[i].end());
    }

    int s = 0, t = 0;

    for (int i = 1; i <= n; i++) {
        if (ind[i] == oud[i]) {
            continue;
        }
        if (oud[i] - ind[i] == 1) {
            if (s > 0) {
                std::cout << "No\n";
                return 0;
            }
            s = i;
        } else if (ind[i] - oud[i] == 1) {
            if (t > 0) {
                std::cout << "No\n";
                return 0;
            }
            t = i;
        } else {
            std::cout << "No\n";
            return 0;
        }
    }

    if (s == 0) {
        s = 1;
    }

    std::vector<int> path, cur(n + 1);

    std::function<void(int)> dfs = [&](int u) {
        for (int i = cur[u]; i < adj[u].size(); i = cur[u]) {
            cur[u]++;
            dfs(adj[u][i]);
        }
        path.push_back(u);
    };

    dfs(s);
    
    std::reverse(path.begin(), path.end());
    for (int x : path) {
        std::cout << x << " ";
    }

    return 0;
}
```



## 无向图欧拉路径

无向图存在**欧拉路径**的充要条件（二选一）：

- 所有点的度数都是偶数；
- 恰好有两个点度数是奇数，其余全是偶数。

存在**欧拉回路**的充要条件：

- 所有点的度数都是偶数。



[P1341 无序字母对](https://www.luogu.com.cn/problem/P1341) 

【题意】给 $n$ 个字母对（区分大小写，顺序可以颠倒）。需要构造一个长度为 $n+1$ 的字符串，使得每个字母对都在这个字符串中出现，或报告不可能。

【思路】建无向图，每个点代表一个字符。每给一个字母对就在无向图中连一条边。最后求字典序最小的欧拉回路径，就是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int, int>
#define endl "\n"
/**********************  Core code begins  **********************/

int get(char x) {	// 将字符映射到数字，方便建图
    if (isupper(x)) {
        return x - 'A' + 1;
    } else {
        return 26 + x - 'a' + 1;
    }
};

char f(int x) {		// 将数字映射到字符，以便输出
    if (x <= 26) {
        return 'A' + x - 1;
    } else {
        return 'a' + x - 27;
    }
};

void SolveTest() {
    int n, N = 52;
    cin >> n;

    vector<vector<int>> g(N + 1);	// 存与点相连的边编号，以便找到反向边
    vector<int> e;					// 存边编号对应的边终点
    vector<int> deg(N + 1);			// 无向图度数

    auto addEdge = [&](int u, int v) {
        g[u].push_back(e.size());
        e.push_back(v);
        deg[u]++;
    };

    for (int i = 1; i <= n; i++) {
        string s;
        cin >> s;
        int u = get(s[0]), v = get(s[1]);
        addEdge(u, v);
        addEdge(v, u);
    }

    vector<int> tmp;				// 存度数为奇数的点
    for (int i = 1; i <= N; i++) {
        if (deg[i] % 2 == 1) {
            tmp.push_back(i);
        }
    }
    if (tmp.size() != 0 && tmp.size() != 2) {
        cout << "No Solution" << endl;
        return;
    }

    // 本题需要字典序最小，所以还是将边按照终点从小到大排序
    for (int i = 1; i <= N; i++) {
        sort(g[i].begin(), g[i].end(), [&](int x, int y) {
            return e[x] < e[y];
        });
    }
    
    vector<int> ans, cur(N + 1), vis(e.size() * 2);
    
    function<void(int)> dfs = [&](int u) {
        if (cur[u] >= g[u].size()) {
            return;
        }
        for (int i = cur[u]; i < g[u].size(); i = cur[u]) {
            int id = g[u][i], v = e[id];
            cur[u]++;
            if (vis[id] || vis[id ^ 1]) {
                continue;
            }
            vis[id] = vis[id ^ 1] = 1;
            dfs(v);
        }
        ans.push_back(u);
    };

    if (tmp.size()) {
        dfs(tmp[0]);
    }
    for (int i = 1; i <= N; i++) {
        dfs(i);
    }
    reverse(ans.begin(), ans.end());
    
    for (int x : ans) {
        cout << f(x);
    }
    cout << endl;
}

/**********************  Core code ends  ***********************/
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int T = 1;
    // cin >> T;
    for (int i = 1; i <= T; i++) {
        SolveTest();
    }
    return 0;
}
```



# 哈密顿图

[最短Hamilton路径](https://ac.nowcoder.com/acm/problem/50909)

【题意】给定一张 $n$ 个点的带权无向图，点从 $0\sim n-1$  标号，求起点 $0$ 到终点 $n-1$ 的最短 Hamilton 路径。Hamilton 路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。

【做法】状态压缩 dp。

已经走过的点集合设为 $S$；设当前停在第 $i$ 个点。转移时枚举 $i$ 是从哪个点走过来的。

```cpp
#include <bits/stdc++.h>
#define int long long

const int INF = 1e18;

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;

    std::vector g(n + 1, std::vector<int>(n + 1));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> g[i][j];
        }
    }

    std::vector dp(1 << n, std::vector<int>(n, INF));
    dp[1][0] = 0;

    for (int state = 0; state < (1 << n); state++) {
        for (int i = 0; i < n; i++) {
            if ((state & (1 << i)) == 0) {
                continue;
            } 
            for (int j = 0; j < n; j++) {
                if (state & (1 << j)) {
                    dp[state][i] = std::min(dp[state][i], dp[state - (1 << i)][j] + g[j][i]);
                }
            }
        }
    }

    std::cout << dp[(1 << n) - 1][n - 1];
    return 0;
}
```



# 基环树

[P8943 Deception Point](https://www.luogu.com.cn/problem/P8943)

题意：给一棵基环树，边权是 $1$，保证没有小于 $4$ 的环。给出两个人的起始点，两人移动速度相同，问后者能否追上前者（在点或边上相遇）。

分析：无向基环树板子题。需要求：

- 环的长度，以及哪些点在环上 
- 每个点的树根（最早抵达环的点）
- 任意两点距离

```cpp
#include <bits/stdc++.h>
#define int long long

struct CircleTree {
    int n, len = 0;
    std::vector<std::vector<int>> adj;
    std::vector<bool> circle, vis;
    std::vector<int> root, dis, circleDis, from;

    void init(int n_ = 0) {
        n = n_;
        adj.assign(n + 1, {});
        circle.assign(n + 1, 0);
        vis = circle;
        root.assign(n + 1, 0);
        from = dis = circleDis = root;
    }

    CircleTree(int n_ = 0) {
        init(n_);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    void dfs1(int u) {
        vis[u] = 1;
        for (int v : adj[u]) {
            if (v == from[u] || circle[v]) {
                continue;
            }
            if (vis[v]) {
                circle[v] = true;
                len = 1;
                int cur = u;
                while (cur != v) {
                    circle[cur] = true;
                    len++;
                    circleDis[cur] = len - 1;
                    cur = from[cur];
                }
            } else {
                from[v] = u;
                dfs1(v);
            }
        }
    }

    void dfs2(int u) {
        for (int v : adj[u]) {
            if (dis[v] || circle[v]) {
                continue;
            }
            dis[v] = dis[u] + 1;
            root[v] = root[u];
            dfs2(v);
        }
    }

    void work() {
        // 更新 circle 和 circleDis     
        dfs1(1);
        // 更新 dis 和 root
        for (int i = 1; i <= n; i++) {
            if (!circle[i]) {
                continue;
            }
            root[i] = i;
            for (int v : adj[i]) {
                if (circle[v]) {
                    continue;
                }
                root[v] = i;
                dis[v] = 1;
                dfs2(v);
            }

        }
    }

    int getDis(int x, int y) {
        int d1 = dis[x] + dis[y];
        x = root[x], y = root[y];
        int d2 = (circleDis[x] - circleDis[y] + len) % len;
        d2 = std::min(d2, len - d2);
        return d1 + d2;
    }
};


signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, q;
    std::cin >> n >> q;

    CircleTree tr(n);

    for (int i = 1; i <= n; i++) {
        int u, v;
        std::cin >> u >> v;
        tr.addEdge(u, v);
    }

    tr.work();
    auto &circle = tr.circle;
    auto &root = tr.root;

    while (q--) {
        int x, y;
        std::cin >> x >> y;
        if (x == y) {
            std::cout << "Deception\n";
        } else if (circle[x]) {
            std::cout << "Survive\n";
        } else if (tr.getDis(x, root[x]) >= tr.getDis(y, root[x])) {
            std::cout << "Deception\n";
        } else {
            std::cout << "Survive\n";
        }
    }

    return 0;
}
```





# 最小树形图

相当于最小生成树的有向图版本。不会写，抄的洛谷板子

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define il inline
#define ri register
#define Size 100050
using namespace std;
int fa[Size],cnt,is[Size];
il int find(int);
il void read(int&),Union(int,int);
struct leftist{
	struct point{
		int l,r,d,v,t,to;
	}a[Size]={{0,0,-1,0,0,0}};
	int r[Size];
	il void merge(int&x,int&y){
		if(!x||!y){x^=y;return;}
		if(a[x].v>a[y].v)x^=y^=x^=y;
		a[y].t-=a[x].t,a[y].v-=a[x].t;
		merge(a[x].r,y);
		if(a[a[x].l].d<a[a[x].r].d)
			a[x].l^=a[x].r^=a[x].l^=a[x].r;
		a[x].d=a[a[x].r].d+1;
	}
	il void spread(int&p){
		a[a[p].l].t+=a[p].t,a[a[p].r].t+=a[p].t;
		a[a[p].l].v+=a[p].t,a[a[p].r].v+=a[p].t;
		a[p].t=0;
	}
	il void pop(int&x){
		spread(x),merge(a[x].l,a[x].r),x=a[x].l;
	}
	il point*top(int&x){
		while(r[x]&&!(find(a[r[x]].to)^x))pop(r[x]);
		if(!r[x])puts("-1"),exit(0);
		a[r[x]].to=find(a[r[x]].to);
		return &a[r[x]];
	}
}L;
int pre[Size];
int main(){
	int n,m,r,ans(0);leftist::point*temp;
	read(n),read(m),read(r),cnt=n,is[r]=r;
	for(int i(1),u,v,w;i<=m;++i)
		read(u),read(v),read(w),
			L.a[i]={0,0,0,w,0,u},
			L.merge(L.r[v],u=i);
	for(int i(1);i<=n<<1;++i)fa[i]=i;
	for(int i(1),j(i);i<=n;j=++i)
		while(!is[j]){
			while(!is[j])
				is[j]=i,j=(temp=L.top(j))->to,
					ans+=temp->v;if(is[j]^i)break;
			while(~is[j])
				is[j]=-1,j=pre[j]=(temp=L.top(j))->to,
					temp->t-=temp->v,temp->v=0;++cnt;
			while(is[j]^i)is[j]=i,Union(j,cnt),j=pre[j];
			j=cnt;
		}return printf("%d",ans),0;
}
il void Union(int u,int v){
	if((u=find(u))^(v=find(v)))
		L.merge(L.r[v],L.r[u]),fa[u]=v;
}
il int find(int x){
	return x^fa[x]?fa[x]=find(fa[x]):x;
}
il void read(int&x){
	x^=x;ri char c;while(c=getchar(),c<'0'||c>'9');
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
```



# 斯坦纳树

[P6192 【模板】最小斯坦纳树](https://www.luogu.com.cn/problem/P6192)

【题意】

给定一个 $n$ 个点 $m$ 条边的带边权的无向连通图 $G=(V,E)$。再给定 $k$ 个特殊点，需要选出 $G$ 的一个子图，要求：

- 包含这 $k$ 个特殊点；
- 连通；
- 所选边权和最小；

输出这个最小的边权和

$1\le n\le 100$，$1\le m\le 500$，$1\le k\le 10$。

【做法】

状态表示 $dp(i,S)$：

- 已经包含了哪些关键点。状态压缩 $k$ 位二进制数 $S$；
- 斯坦纳树根为 $i$（不一定是特殊点）；
- 性质：最小边权和；

状态转移时，考虑 $dp(i,S)$ 最优的斯坦纳树中，$i$ 是否只有一棵子树：

- 若最优解中 $i$ 至少有 $2$ 棵子树。枚举 $S$ 的子集 $T$，$dp(i,S)\leftarrow \max \{dp(i,T) + dp(i,S-T) \}$ 。想想会知道一定可以枚举到最优解的状态。
- 若最优解中 $i$ 只有 $1$ 棵子树，此时上面的式子无法处理这种情况。这时枚举与 $i$ 的儿子节点是 $j$。$dp(i,S)\leftarrow \max\left\{ dp(i,S),dp(j,S)+w(i,j) \right\}$。它的含义其实是 $dp(i,S) \le dp(j,S) + w(i,j)$，类似 dijkstra 的三角不等式，可以用 Dijkstra 算法在 $S$ 固定的时候松弛所有的 $dp(i,S)$。

复杂度 $O(n\times3^{k} + m\log m\times 2^{k})$。

```cpp
#include <bits/stdc++.h>
#define int long long
using PII = std::pair<int, int>;
const int INF = 1e18;

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, m, k;
    std::cin >> n >> m >> k;

    std::vector<std::vector<std::array<int, 2>>> adj(n + 1);
    std::vector dp(n + 1, std::vector<int>(1 << (k + 1), INF));

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    std::vector<int> h(k + 1);
    for (int i = 0; i < k; i++) {
        std::cin >> h[i];
        dp[h[i]][1 << i] = 0;
    }

    std::priority_queue<PII> heap;

    auto dijkstra = [&](int state) {
        std::vector<int> vis(n + 1);
        while (!heap.empty()) {
            auto [d, u] = heap.top();
            heap.pop();
            if (vis[u]) {
                continue;
            }
            vis[u] = 1;
            for (auto [v, w] : adj[u]) {
                if (dp[v][state] > dp[u][state] + w) {
                    dp[v][state] = dp[u][state] + w;
                    heap.push({-dp[v][state], v});
                }
            }
        }
    };

    for (int s = 1; s < (1 << k); s++) {
        for (int i = 1; i <= n; i++) {
            for (int t = s & (s - 1); t; t = s & (t - 1)) {
                dp[i][s] = std::min(dp[i][s], dp[i][t] + dp[i][s ^ t]);
            }
            if (dp[i][s] != INF) {
                heap.push({-dp[i][s], i});
            }
        }
        dijkstra(s);
    }

    std::cout << dp[h[1]][(1 << k) - 1];
    return 0;
}
```



# 线段树优化建图

[CF786B. Legacy](https://codeforces.com/problemset/problem/786/B)

【题意】给定 $n$ 个点，$m$ 次操作。（$1\le n,m\le 10^5$）。每次操作为以下三种之一：

1. 给出 $u,v,w$ ，加有向边 $u\rightarrow v$，边权为 $w$；
2. 给出  $u,l,r,w$，对区间 $[l,r]$ 的所有点 $v$，加有向边 $u\rightarrow v$，边权为 $w$；
3. 给出 $v,l,r,w$ ，对区间 $[l,r]$ 的所有点 $u$，加有向边 $u\rightarrow v$，边权为 $w$；

最终求从$s$ 出发到所有点的最短路。

【代码】

```cpp
#include <bits/stdc++.h>
#define int long long
using PII = std::pair<int, int>;
const int INF = 1e18;

#define id(p) (p ? p->id : 0)
#define ls(p) (p ? p->ls : nullptr)
#define rs(p) (p ? p->rs : nullptr)

struct SegTreeGraph {
    struct Node {
        int id;
        Node *ls, *rs;
    };

    int nodecnt, leafcnt;
    std::vector<std::array<int, 3>> edge;
    Node *outTree, *inTree; // outTree 儿子指向父亲，outtree 父亲指向儿子

    SegTreeGraph(int n) {
        leafcnt = nodecnt = n;
        outTree = build(1, leafcnt, 0);
        inTree = build(1, leafcnt, 1);
    }

    // type == 0/1：建立 out/in 树
    Node *build(int l, int r, int type) {
        Node *p = new Node();
        if (l == r) {
            p->id = l;
            return p;
        }
        int mid = (l + r) / 2;
        p->id = ++nodecnt;
        p->ls = build(l, mid, type);
        p->rs = build(mid + 1, r, type);
        if (type == 0) {    // 建立 out 树
            edge.push_back({id(p->ls), id(p), 0});
            edge.push_back({id(p->rs), id(p), 0});
        } else {            // 建立 in 树
            edge.push_back({id(p), id(p->ls), 0});
            edge.push_back({id(p), id(p->rs), 0});
        }
        return p;
    }

    // 求区间 [l,r] 是由线段树上哪些点组
    void rangeQuery(Node *p, int l, int r, int x, int y, std::vector<int> &res) {
        if (p == nullptr) {
            return;
        }
        if (l >= x && r <= y) {
            return res.push_back(id(p));
        }
        int mid = (l + r) / 2;
        if (x <= mid) {
            rangeQuery(ls(p), l, mid, x, y, res);
        }
        if (y > mid) {
            rangeQuery(rs(p), mid + 1, r, x, y, res);
        }
    }

    // u->v 连边，边权为 w
    void addEdge(int u, int v, int w) {
        edge.push_back({u, v, w});
    }

    // 区间 [l, r] 的点都向 v 连一条边权为 w 的边
    void rangeOut(int l, int r, int v, int w) {
        std::vector<int> res;
        rangeQuery(outTree, 1, leafcnt, l, r, res);
        for (int u : res) {
            edge.push_back({u, v, w});
        }
    }

    // 点 u 向区间 [l, r] 的点都连一条边权为 w 的边
    void rangeIn(int u, int l, int r, int w) {
        std::vector<int> res;
        rangeQuery(inTree, 1, leafcnt, l, r, res);
        for (int v : res) {
            edge.push_back({u, v, w});
        }
    }
};

struct Edge {
    int to, w;
};

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n, q, s;
    std::cin >> n >> q >> s;

    SegTreeGraph g(n);

    while (q--) {
        int op, u, v, l, r, w;
        std::cin >> op;
        if (op == 1) {
            std::cin >> u >> v >> w;
            g.rangeIn(u, v, v, w);
        } else if (op == 2) {
            std::cin >> u >> l >> r >> w;
            g.rangeIn(u, l, r, w);
        } else {
            std::cin >> v >> l >> r >> w;
            g.rangeOut(l, r, v, w);
        }
    }

    int totcnt = g.nodecnt;
    std::vector<std::vector<Edge>> adj(totcnt + 1);
    for (auto [u, v, w] : g.edge) {
        adj[u].push_back({v, w});
    }

    std::vector<int> dis;
    std::priority_queue<PII, std::vector<PII>, std::greater<PII>> heap;
    dis.assign(totcnt + 1, INF);
    dis[s] = 0;
    heap.push({0, s});

    while (heap.size()) {
        auto [d, u] = heap.top();
        heap.pop();
        if (d > dis[u]) {
            continue;
        }
        for (auto [v, w] : adj[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                heap.push({dis[v], v});
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        std::cout << (dis[i] == INF ? -1 : dis[i]) << " ";
    }

    return 0;
}
```

典型题目：

- [P5025 [SNOI2017] 炸弹](https://www.luogu.com.cn/problem/P5025) 线段树建图 + SCC
- [P3588 [POI2015] PUS](https://www.luogu.com.cn/problem/P3588)
- [2023牛客暑假多校2B. Link with Railway Company](https://ac.nowcoder.com/acm/contest/57356/B) 树剖线段树建图 + 最大权闭合子图



# 支配树（不会）

支配树概念：对于一张有向图，确定一个起点 $S$。对于一个点 $u$ ，称 $x$ 为其支配点当且仅当，删去点 $x$ 后，$S$ 无法到达 $u$。即 $S$ 所有到达 $k$ 的路径都必须通过 $x$。

一个点的支配点可能不止一个。如果我们将每个点向它最近的支配点连边，那么会形成一个树形结构，即支配树。利用 Lengeuar-Tarjan 算法可以在 $O(n\log n)$ 时间复杂度内求解支配树。





[P5180 【模板】支配树](https://www.luogu.com.cn/problem/P5180)

题意：给一张有向图，求从 $1$ 号点出发，每个点能支配的点的个数（包含自己）。

支配的定义：





# 竞赛图
