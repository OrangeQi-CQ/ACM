[TOC]



# 整除相关

整除:理解整除一定需要多重集的思想。

性质

- 若 $x, y$ 互质，那么 $x + y$ 与 $xy$ 互质。

证明：假设 $x + y$ 和 $xy$ 有共同的质因数 $t$。那么 $t$ 要么为 $x$ 的质因数，要么为 $y$ 的质因数，假设为前者。所以有 $t | x$，又因为 $t|(x + y)$ ，所以必然有 $t|y$，因此 $t$ 是 $x,y$ 的公因数，与题设矛盾。



## 素数

【性质】

1. 素数分布

相邻素数的间隔任意大，即：存在任意长的一段连续数，其中的所有数都是合数。

$N$ 以内的素数个数随着 $N$ 的增大趋近于 $lnN$。

2. 切比雪夫定理

对于 $x>1$，在 $(x,2x)$ 之间必存在至少一个素数。

对于 $x>3$，在 $(x,2x-2)$ 中至少有一个质数。



【素数判定】

1. 试除法，复杂度 $O(\sqrt{n})$

```c++
bool isprime(int x) {
    if (x == 1) {
        return 0;
    }
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            return 0;
        }
    }
    return 1;
}
```



2. Miller-Rabin判定

用于大素数判定，复杂度 $O(n^{\frac{1}{4}})$

```c++
int Rand() {
    static int x = (srand(int)time(0), rand());
    x += 1e6 + 3;
    if (x > 1e9 + 7) {
        x -= 1e9 + 7;
    }
    return x;
}

bool Witness(int a, int n) {
    int t = 0, u = n - 1;
    while (!(u & 1)) {
        u /= 2;
        ++t;
    }
    int x = qpow(a, u, n), y;
    while (t--) {
        y = x * x % n;

        if (y == 1 && x != 1 && x != n - 1) {
            return 1;
        }

        x = y;
    }
    return x != 1;
}

bool MillerRabin(int n, int s) {
    if (n == 2 || n == 3 || n == 5) {
        return 1;
    }
    if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) {
        return 0;
    }
    while (s--) {
        if (Witness(Rand() % (n - 1) + 1, n)) {
            return 0;
        }
    }
    return 1;
}
```



【素数筛法】

1. 埃氏筛

思想：找到一个素数就把它的所有倍数都筛掉。

复杂度 $O(nlogn)$。

```c++
int pcnt = 0, primes[N];
bool vis[N];

void getprimes(int n) {
    for (int i = 2; i <= n; i++) {
        if (vis[i]) {
            primes[++pcnt] = i;
        } else {
            for (int j = i * 2; i <= n; j += i) {
                vis[j] = 1;
            }
        }
    }
}
```



2. 线性筛

思想：每个数都只被自己最小的质因数筛掉。

复杂度 $O(n)$。

```c++
std::vector<int> minp, primes;

void sieve(int n) {
    minp.assign(n + 1, 0);
    primes.clear();
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            primes.push_back(i);
        }
        for (int p : primes) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                break;
            }
        }
    }
}

//100以内素数：2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```



3. 类素数筛

在 $O(nm)$ 复杂度打表，使得对于所有 $1\le i\le n,1\le j\le m$，有 $a[i][j]=lcm(i,j)$

```c++
void work() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j]) {
                continue;
            }
            for (int k = 1; k * i <= n && k * j <= m; k++) {
                a[i * k][j * k] = i * j * k;
            }
        }
    }
}
```



4. 二次筛

思想：先筛一部分素数，再用这些素数筛比较大的区间。

用来解决求区间 $[l,r]$ 内的素数，特点是 $r$ 很大但是 $r-l$ 较小。

[牛客 - 二次筛模板题](https://ac.nowcoder.com/acm/problem/228910)

【题意】

给出 $L,U$，求其中最近和最远的两个素数。本题 $L$ 和 $U$ 的范围较大，但 $U-L$ 不超过$1e6$。

【思路】

若 $r$ 为合数，则必有 $[1,\sqrt r]$ 以内的质因数。因此预处理 $[1,\sqrt r]$ 以内的素数，再用这些素数类似埃氏筛法筛掉 $[l,r]$ 的合数。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6;
bool vis[N], st[N];
int primes[N], ans[N];
int pcnt = 0, tot, L, U;

void getprimes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            primes[++pcnt] = i;
        }

        for (int j = 1; j <= pcnt && primes[j]*i <= n; j++) {
            vis[primes[j]*i] = 1;

            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

void SolveTest() {
    memset(st, 0, sizeof st);
    for (int i = 1; i <= pcnt; i++) {
        int p = primes[i];

        for (int j = max(p * 2, (L + p - 1) / p * p); j <= U; j += p) {
            st[j - L] = 1;
        }
    }
    tot = 0;
    memset(ans, 0, sizeof ans);
    for (int i = 0; i <= U - L; i++) {
        if (!st[i] && i + L >= 2) { //这里很重要，i+L可能为1
            ans[++tot] = i + L;
        }
    }
    if (tot < 2) {
        printf("There are no adjacent primes.\n");
    } else {
        int minp = 1, maxp = 1;

        for (int i = 1; i < tot; i++) {
            int d = ans[i + 1] - ans[i];

            if (d < ans[minp + 1] - ans[minp]) {
                minp = i;
            }

            if (d > ans[maxp + 1] - ans[maxp]) {
                maxp = i;
            }
        }
        printf("%d,%d are closest, %d,%d are most distant.\n",
               ans[minp], ans[minp + 1],
               ans[maxp], ans[maxp + 1]);
    }
}

signed main() {
    getprimes(100000);
    while (cin >> L >> U) {
        SolveTest();
    }
}
```



【反素数】

[牛客 - 反素数模板题](https://ac.nowcoder.com/acm/problem/50747)

定义：不超过 $n$ 的因子数量最多的数字。

【分析】

- 答案一定是从 $2$ 开始的连续的质因子；
- 质因子的次数递减

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
int pr[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
int ans, num;

void dfs(int u, int last, int p, int res) {
    if (res > ans || (res == ans && num > p)) {
        ans = res;
        num = p;
    }
    if (u == 9) {
        return ;
    }
    for (int i = 1; i <= last; i++) {
        if ((ll)p * pr[u] > n) {
            break;
        }
        p = p * pr[u];
        dfs(u + 1, i, p, res * (i + 1));
    }
}

int main() {
    scanf("%d", &n);
    dfs(0, 30, 1, 1);
    printf("%d\n", num);
    return 0;
}
```



[反素数模板题2](https://codeforces.com/contest/27/problem/E)

​	



## 约数

【分解质因数】

1. 试除法

复杂度$O(\sqrt{n})$

```c++
std::vector<std::pair<int, int>> decompose(int x) {
    std::vector<std::pair<int, int>> ans; 
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int c = 0;
            while (x % i == 0) {
                c++;
                x /= i;
            }
            ans.push_back({i, c});
        }
    }
    if (x > 1) {
        ans.push_back({x, 1});
    }
    std::sort(ans.begin(), ans.end());
    return ans;
}
```



2. Pollard Rho

作用：大数分解质因数。

https://www.luogu.com.cn/problem/P4718

对于每个数字检验是否是质数，是质数就输出 `Prime`；如果不是质数，输出它最大的质因子是哪个。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define RP(i,a,b) for(register int i=a;i<=b;++i)
#define DRP(i,a,b) for(register int i=a;i>=b;--i)
#define fre(z) freopen(z".in","r",stdin),freopen(z".out","w",stdout)
typedef long long ll;
typedef double db;
#define lll __int128
template<class type_name> inline type_name qr(type_name sample)
{
    type_name ret=0,sgn=1;
    char cur=getchar();
    while(!isdigit(cur))
        sgn=(cur=='-'?-1:1),cur=getchar();
    while(isdigit(cur))
        ret=(ret<<1)+(ret<<3)+cur-'0',cur=getchar();
    return sgn==-1?-ret:ret;
}

ll max_factor;

inline ll gcd(ll a,ll b)
{
    if(b==0)
        return a;
    return gcd(b,a%b);
}

inline ll qp(ll x,ll p,ll mod)
{
    ll ans=1;
    while(p)
    {
        if(p&1)
            ans=(lll)ans*x%mod;
        x=(lll)x*x%mod;
        p>>=1;
    }
    return ans;
}

inline bool mr(ll x,ll b)
{
    ll k=x-1;
    while(k)
    {
        ll cur=qp(b,k,x);
        if(cur!=1 && cur!=x-1)
            return false;
        if((k&1)==1 || cur==x-1)
            return true;
        k>>=1;
    }
    return true;
}

inline bool prime(ll x)
{
    if(x==46856248255981ll || x<2)
        return false;
    if(x==2 || x==3 || x==7 || x==61 || x==24251)
        return true;
    return mr(x,2)&&mr(x,61);
}

inline ll f(ll x,ll c,ll n)
{
    return ((lll)x*x+c)%n;
}

inline ll PR(ll x)
{
    ll s=0,t=0,c=1ll*rand()%(x-1)+1;
    int stp=0,goal=1;
    ll val=1;
    for(goal=1;;goal<<=1,s=t,val=1)
    {
        for(stp=1;stp<=goal;++stp)
        {
            t=f(t,c,x);
            val=(lll)val*abs(t-s)%x;
            if((stp%127)==0)
            {
                ll d=gcd(val,x);
                if(d>1)
                    return d;
            }
        }
        ll d=gcd(val,x);
        if(d>1)
            return d;
    }
}

inline void fac(ll x)
{
    if(x<=max_factor || x<2)
        return;
    if(prime(x))
    {
        max_factor=max_factor>x?max_factor:x;
        return;		
    }
    ll p=x;
    while(p>=x)
        p=PR(x);
    while((x%p)==0)
        x/=p;
    fac(x),fac(p);
}

int main()
{
    int T=qr(1);
    while(T--)
    {
        srand((unsigned)time(NULL));
        ll n=qr(1ll);
        max_factor=0;
        fac(n);
            if(max_factor==n)
                puts("Prime");
            else
                printf("%lld\n",max_factor);
    }
    return 0;
}
```



3. [阶乘分解](https://ac.nowcoder.com/acm/problem/51043)

给定整数 $N\in[1,1e6]$，把 $N!$ 分解质因数。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
const int N = 2e6;
int primes[N], cnt = 0, c[N];
bool vis[N];

void getprimes(int n) {
    for (re int i = 2; i <= n; i++) {
        if (!vis[i]) {
            primes[++cnt] = i;
        }
        for (re int j = 1; j <= cnt && primes[j]*i <= n; j++) {
            vis[primes[j]*i] = 1;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

signed main() {
    int n;
    cin >> n;
    getprimes(n);
    for (int i = 1; i <= cnt; i++) {
        for (int j = primes[i]; j <= n; j *= primes[i]) {
            c[i] += n / j;
        }
    }
    for (int i = 1; i <= cnt; i++) {
        if (c[i]) {
            printf("%d %d\n", primes[i], c[i]);
        }
    }
}
```



4. n! 的因子的因子的个数和

https://codeforces.com/gym/102040 C题，

先将 $n!$ 进行唯一分解：$n!=\prod_{i=1}^{k}p_i^{\alpha _i}$

则答案为 $\prod_{i=1}^{k}(1+2+...+\alpha+1  )=\prod_{i=1}^{k} \frac{(\alpha+1)(\alpha+2)}{2}$





【约数&算数基本定理】

对于 $N=\prod_{i=1}^{k}p_i^{c_i}$

- 约数个数 $=\prod_{i=1}^{k}(p_i+1)$


- 约数和 $=\prod_{i=1}^{k}(\sum_{j=0}^{c_i}p_i^j )$


- 随机数据下，约数个数的期望是 $O ( \ln ⁡n )$




1. 试除法

求 $n$ 的所有约数

若不排序，复杂度$O(\sqrt{n})$

```c++
void solve(int n, vector<int> &factor) {
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            factor.push_back(i);
            if (i != n / i) {
                factor.push_back(n / i);
            }
        }
    }

    //sort(factor.begin(),factor.end());
}
```



2. 埃氏筛

求 $1 \dots n$ 的正约数集合

```c++
std::vector<std::vector<int>> divs;

void init(int n) {
    divs.assign(n + 1, {});
    for (int i = 2; i <= n; i++) {
        for (int j = i; j <= n; j += i) {
            divs[j].push_back(i);
        }
    }
}
```

推论：$1 ∼ n$ 中每个数的约数的总和大概为 $n\log n$



3. 二次筛

作用：大数分解质因数。

先预处理 $\sqrt n$ 的素数，再用这些素数去对 $N$ 进行质因数分解，再枚举每个质因子的次数。



4. [约数和的前缀和](https://lightoj.com/problem/a-new-function)

```c++
#define int long long 
int n, m, s, t, k, ans, a[N], kcase;

void solve(){
 	ans = 0;
	scanf("%lld", &n); 
	for (int l = 2, r; l <= n; l = r + 1) {
		r = n / (n / l);
		ans += (l + r) * (r - l + 1) / 2 * (n / l - 1);
	}
	cout << ans << endl;
}

signed main(){
	scanf("%lld", &t);
	while(t -- ) {
		printf("Case %lld: ", ++ kcase);
		solve();
	}
	return 0;
}

```



【GCD 和 LCA】

1. 性质和结论

【性质】

$gcd(a,b)\times lca(a,b)=ab$



【性质】

更相减损：若 $a < b$ ，$gcd(a,b)=gcd(a-b,b)$

> 假设 $\gcd(a, b) = g$，则有 $a = k_1 g$，$b = k_2 g$，其中 $\gcd(k_1, k_2) = 1$。
> 由于 $k_1$ 与 $k_2$ 互质，所以 $k_1 - k_2$ 与 $k_2$ 互质。
> 所以 $a - b = g(k_1 - k_2)$ 与 $b = gk_2$ 的最大公因数仍为 $g$。



【重要性质】

辗转相除：$gcd(a,b)=gcd(a \bmod b,\ b)$。

> 假设 $\gcd(a, b) = g$，则有 $a = k_1 g$，$b = k_2 g$，其中 $\gcd(k_1, k_2) = 1$。
> 由于 $k_1$ 与 $k_2$ 互质，所以 $k_1 \bmod k_2$ 与 $k_2$ 互质。
> 所以 $a \bmod b = g(k_1 \bmod k_2)$ 与 $b = gk_2$ 的最大公因数仍为 $g$。



【性质】

$gcd(a,b,c)=gcd(gcd(a,b),c)$

$gcd(ka,kb)=k\times gcd(a,b)$

$gcd(a,bc)=1\Rightarrow \left\{\begin{matrix}
gcd(a,b)=1
 \\
gcd(a,c)=1\end{matrix}\right.$

$F为斐波那契数列，gcd(F_n,F_m)=F_{gcd(n,m)}$

$gcd(a^m-1,a^n-1)=a^{gcd(n,m)}-1$

$gcd(a,b)=1 \Rightarrow gcd(a^n,b^m)=1$

$gcd(a,b)=1\Rightarrow gcd(a^m-b^m,a^n-b^n)=a^{gcd(n,m)}-b^{gcd(n,m)}$

$(a+b) | ab\Rightarrow gcd(a,b)\ne1$

$设G=gcd(C_n^1,C_n^2,...,C_n^{n-1})，则G=\begin{cases}
n，n为素数\\
p，n为合数且有唯一质因子p\\
1，n有多个质因子
\end{cases}$

$\sum_{i=1}^{n}gcd(i,n)=\sum_{d|n}d\varphi(\frac{n}{d})$



2. 辗转相除法

```c++
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int lca(int a, int b) {
    return a / gcd(a, b) * b;
}
```



3. Stein

作用：求大数 $\gcd$。

```c++
int stein(int a, int b) {
    int k = 1;
    while ((!(a & 1)) && (!(b & 1))) {
        k *= 2;
        a /= 2;
        b /= 2;
    }
    while (!(a & 1)) {
        a /= 2;
    }
    while (!(b & 1)) {
        b /= 2;
    }
    if (a < b) {
        swap(a, b);
    }
    while (a != b) {
        a -= b;
        if (a < b) {
            swap(a, b);
        }
    }
    return k * a
}
```





【斐波那契数列】

性质和结论

1. $\sum_{i=1}^{n}f_i=f_{n+2}-1$

2. $\sum_{i=1}^{n}f_{2i-1}=f_{2n}$

3. $\sum_{i=1}^{n}f_{2i}=f_{2n+1}-1$

4. $\sum_{i=1}^{n}f_i^2=f_nf_{n+1}$

5. $f_{n+m}=f_{n-1}f_{m-1}+f_nf_m$

6. $f_n^2=(-1)^{(n-1)}+f_{n-1}f_{n+1}$

7. $f_{2n-1}=f_n^2-f_{n-2}^2$

8. $f_n=\frac{f_{n+2}+f_{n-2}}{3}$



快速求斐波那契数列第n项

```c++
int f(int n) {
    if (a[n] != 0) {
        return a[n];
    }
    int t = n;
    n /= 2;
    if (t % 2) {
        return a[t] = f(n) * f(n) % p + f(n + 1) * f(n + 1) % p;
    }
    else {
        return a[t] = (2 * f(n - 1) % p + f(n) % p) * f(n) % p;
    }
}
```



# 同余定理

【性质】

若 $a\le b$， 则 $a \bmod\ b=0$；若 $a > b$，则 $a \bmod b < \dfrac{a}{2}$。

$x \bmod  y=x-y \left \lfloor \dfrac{x}{y} \right \rfloor$。



## 欧拉定理

1. 欧拉定理

若 $\gcd(a,n)=1$，那么 $a^{\varphi(n) } \equiv 1 \pmod n$。

> 证明
> 设 $x_1, \dots , x_{\varphi(n)}$ 是一个以 $n$ 为模的简化剩余系。则$ax_1, \dots, ax_{\varphi(n)}$ 也是一个以 $n$ 为模的简化剩余系。
>
> 所以有 $\prod\limits_{i = 1}^{\varphi(n)} x_i \equiv \prod\limits_{i = 1}^{\varphi(n)}ax_i \pmod n$。
>
> 得到 $a^{\varphi(n)} \equiv 1 \pmod n$



2. 欧拉定理推论

$\exist x\in \mathbb{N}^*, a_x \equiv 1 \pmod n  \iff \gcd(a, n) = 1$



3. 扩展欧拉定理

这个定理的主要作用都是降幂。

$$
a^x \equiv 

\left \{ \begin{align} 

& a^{x \mod \varphi(n)}, &\gcd(a, n) = 1\\

& a^x, 		&\gcd(x, n)>1 \and x < \varphi(m)\\

& a^{x \mod \varphi(m)+\varphi (m) } ,  &\gcd(x, n)>1 \and x\ge \varphi(m)

\end{align} \right.

\pmod n
$$

例如 [P5091 【模板】扩展欧拉定理](https://www.luogu.com.cn/problem/P5091)，给定 $a,m,b$ 求 $a^b \bmod m$。



## 费马小定理

设 $p$ 为质数，如果 $\gcd(a, p) = 1$，那么 $a^{p-1} \equiv 1\pmod  p$。

另一种形式是 $a^p \equiv a \pmod p$。

> 证明：
>
> 由欧拉定理带入 $\varphi(p) = p - 1$ 直接得出。
>
> 下面给出另一种基于归纳法证明。
>
> 对于给定的质数 $p$，显然 $1^p \equiv 1\pmod p$。
>
> 假设 $a^p \equiv a \pmod{p}$ 成立，下面尝试证明 $(a + 1)^p \equiv a + 1 \pmod{p}$ 成立。
>
> 由二项式定理，$(a+1)^p = a^p + {p \choose 1}a^{p - 1} + {p \choose 2}a^{p-2} + \dots + 1$。
>
> 注意到 ${p \choose k} = \dfrac{p (p - 1) \dots (p - k + 1)}{k!}$ 在模$p$ 的意义下一定为 $0$。
>
> 所以上式 $(a + 1)^p \equiv a^p + 1$，带入 $a^p \equiv a\pmod p$，得到 $(a + 1)^p \equiv a + 1$。证毕。



## 威尔逊定理

1. 威尔逊定理

    如果 $p$ 为质数有

$$
\begin{align}
&(p - 1)! \equiv p - 1 \equiv -1 &\pmod{p}\\

\iff &(p - 2)! \equiv 1 &\pmod{p}
\end{align}
$$
​	另一种表述：若 $p$ 是质数，则 $(p - 1)! + 1$ 能够被 $p$ 整除。



2. 逆命题

    若一个数 $p$，满足条件 $p \mid (p - 1)! + 1$，那么 $p$ 是素数。

    综上 ：

$$
p \mid (p - 1)! + 1 \iff p \in primes
$$



## 裴蜀定理

1. 裴蜀定理

​	对任意两个不全为零的整数 $a,b$，存在两个整数 $x,y$，使得 $ax+by=\gcd(a,b)$。

> 证明：
>
> $a,b$ 其中之一为零的情形很显然成立。下面考虑 $a,b$ 都不为零的情况。
>
> 假设 $\gcd(a, b) = d$，可以将方程两遍同除以 $d$ 。
>
> 我们只需证明：存在两个整数 $x, y$，使得 $a_1x + b_1y = 1$，其中 $a_1, b_1$ 互质。
>
> 我们把辗转相除法中的运算展开，做成带余数的除法：
> $$
> \begin{aligned}
> a_1 &= q_1b_1+r_1 &(0\leq r_1<b_1) \\
> 
> b_1 &= q_2r_1+r_2 &(0\leq r_2<r_1) \\
> 
> r_1 &= q_3r_2+r_3 &(0\leq r_3<r_2) \\ 
> 
> &\cdots \\ 
> 
> r_{n-3} &= q_{n-1}r_{n-2}+r_{n-1} \\ 
> 
> r_{n-2} &= q_nr_{n-1}+r_n \\ 
> 
> r_{n-1} &= q_{n+1}r_n
> \end{aligned}
> $$
> 出于方便把所有的 $q$ 都换成$x$。不妨令辗转相除法在除到互质的时候退出，则 $r_n = 1$ 所以有 ：
> $$
> r_{n - 2} = x_nx_{n - 1}  + 1
> $$
>
> 即：$1 = r_{n - 2} - x_nr_{n - 1}$。
>
> 将倒数第三个式子带入，得 $1 = (1 + x_nx_{n - 1})r_{n - 2} - x_nr_{n - 3}$。
>
> 然后用同样的方法把 $r_{n - 2}, \dots, r_1$ 逐个消去。最终可得到 $1 = a_1x + b_1y$。



2. 裴蜀定理推论

$$
\gcd(a,b)∣c \iff ∃x,y∈Z,ax+by=c
$$

​	方程 $ax + by = \gcd(a, b)$ 称为丢番图方程。



3. 重要推论

对于两个给定的数 $a , b$，若存在整数 $x, y, n$，使得 $ax + by = n$，则称 $a,b$ 能表示出 $n$。

若 $a, b$ 互质，设 $C = ab - a - b$，则有如下结论：

- 对于 $n > C$， $n$ 一定能被 $a, b$ 表示；
- 对于 $0 \le n \le C$， $n$ 和 $C - n$ 只有一个能被 $a, b$ 表示；
- 由于 $C$ 能被 $a, b$ 表示，所以 $a, b$ 表示不出的最大的数为 $ab-a-b$；
- 对于 $n < 0$，无法被表示；

> 证明：
>
> 不妨设 $a < b$，答案为 $x$。设 $x\equiv ma \pmod {b}$，其中 $1 \le m \le b -1$。
>





# 同余方程

## 二元模线性方程

【定理】

- $\gcd(a,b)$ 是 $ax+by$ 可以表示出来的最小正整数。
- 方程 $ax+by=c$ 有解的充要条件是$\gcd(a,b)\mid c$。

【定理】

- 方程 $a x + b y  = \gcd ⁡ ( a , b )$ 的所有解为：

$$
\left\{\begin{matrix}
x=x_0+ k \cdot\dfrac{b}{\gcd(a,b)}
 \\
y=y_0- k \cdot\dfrac{b}{\gcd(a,b)}
\end{matrix}\right.
$$
- 其中 $x_0, y_0$ 是原方程的一组特解，可以通过 exgcd 求出。$ k\in \Z$。

【定理】

方程 $ax+by=c,\gcd(a,b)\mid c$ 的所有解为：
$$
\left\{\begin{matrix}
x=x_0\cdot \dfrac{c}{\gcd(a,b)}+k\cdot \dfrac{b}{\gcd(a,b)} \\

y=y_0\cdot \dfrac{c}{\gcd(a,b)}-k\cdot \dfrac{a}{\gcd(a,b)}

\end{matrix}\right.
$$

- 其中 $x_0, y_0$ 是方程 $a x + b y = \gcd(a , b)$ 的一组特解，可以通过 exgcd 求出。$ k\in \Z$。


【扩展欧几里得（exGCD）】

给出 $ax+by=\gcd(a,b)$ 的一组特解。

```c++
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}
```



[P5656 【模板】二元一次不定方程 (exgcd)](https://www.luogu.com.cn/problem/P5656)

题意：给定不定方程

$$
ax+by=c
$$

- 若该方程无整数解，输出 $-1$。 
- 若该方程有整数解，且有正整数解，则输出：
    - 其**正整数**解的数量；
    - 所有**正整数**解中 $x$ 的最小值；
    - 所有**正整数**解中 $y$ 的最小值；
    - 所有**正整数**解中 $x$ 的最大值；
    - 所有**正整数**解中 $y$ 的最大值。  
- 若方程有整数解，但没有正整数解，输出：
    - 所有**整数解**中 $x$ 的最小正整数值；
    -  $y$ 的最小正整数值。

$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

```cpp
#include <bits/stdc++.h>

using i64 = long long;

i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    i64 g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}

void solve() {
    i64 a, b, c;
    std::cin >> a >> b >> c;
    i64 x, y, g = exgcd(a, b, x, y);
    if (c % g != 0) {
        std::cout << "-1\n";
        return;
    }

    // x,y 是一组特解。
    x *= c / g;
    y *= c / g;

    // 对任意的 k, (x + k * p, y - k * q) 都是一组解
    i64 p = b / g;
    i64 q = a / g;

    // 得到 x 为正且最小的一组解。
    if (x < 0) {
        i64 k = (-x + p) / p;
        x += p * k;
        y -= q * k;
    } else {
        i64 k = (x - 1) / p;
        x -= k * p;
        y += q * k;
    }

    if (y > 0) {    // 此时存在 x,y 均为正的解
        std::cout << (y - 1) / q + 1 << " ";        // 正整数解的组数
        std::cout << x << " ";                      // x 的最小正整数解（y 必然为正）
        std::cout << (y - 1) % q + 1 << " ";        // y 的最小正整数解（x 必然为正）
        std::cout << x + (y - 1) / q * p << " ";    // x,y 均为正整数时，x 的最大值
        std::cout << y << " ";                      // x,y 均为正整数时，y 的最大值
    } else {        // 此时 x,y 不可能同为正
        std::cout << x << " ";                      // x 的最小正整数解（y 只能为负）        
        std::cout << y + q * ((-y + q) / q) << " "; // y 的最小正整数解（x 只能为负）
    }
    std::cout << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```



## 逆元

==注意，逆元存在的前提一定是模数为质数==。

1. 费马小定理求逆元

原理

> 利用 $x^{P - 1} \equiv 1 \pmod{p}$。
>
> 所以 $x$ 的逆元为 $x^{P - 2}$。

代码如下

```c++
int qpow(int a, int b, int MOD) {
    int res = 1;
    while (b) {
        if (b & 1) {
            res = res * a % MOD;
        }
        a = a * a % MOD;
        b /= 2;
    }
    return res;
}

int inv(int x, int mod) {
    return qpow(x, mod - 2, mod);
}
```



2. 扩展欧几里得求逆元

扩展欧几里得的好处是不需要保证模数为质数。

给定 $a,b$,求满足 $ax\equiv 1 \pmod b$ 的最小 $x$。不保证 $a,b$ 一定互质。

```c++
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}

void solve() {
    int a, b, x, y;
    cin >> a >> b;

    if (exgcd(a, b, x, y) != 1) {
        cout << -1 << "\n";
        return;
    }

    cout << ((x % b) + b) % b << "\n";
}
```



3. 线性递推求逆元

核心代码 `inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;`

原理如下

>显然 $1^{-1}=1$。
>
>对于 $x>1$，设 $kx+r \equiv 0 \pmod{p}$，那么 $x^{-1} \equiv-kr^{-1}(\bmod p)\equiv-\lfloor \dfrac{p}{x}  \rfloor \times(p \bmod\ x)^{-1} \pmod{p}$。

 [【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)。

预处理 $1 \sim n$ 中所有数的逆元，以及阶乘逆元。

```c++
int inv[N], fac[N], invfac[N];
void solve() {
    inv[1] = 1;
    fac[0] = fac[1] = 1;
    invfac[0] = invfac[1] = 1;

    for (int i = 2; i <= n; i++) {
        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
        fac[i] = fac[i - 1] * i % MOD;
        invfac[i] = invfac[i - 1] * inv[i] % MOD;
    }
}
```





## 线性同余方程组

【中国剩余定理（CRT）】

设 $m_1,m_2,...,m_k$ 是**两两互质**的 $k$ 个正整数，则同余方程组$
\left\{\begin{matrix}
x\equiv a_1(mod\ m_1)
 \\x\equiv a_2(mod\ m_2)
 \\ ...
 \\x\equiv a_k(mod\ m_k)
\end{matrix}\right.$ 的解为: 
$$
x= \left(\sum_{i=1}^{k} a_i\cdot M_i \cdot M_i^{-1} \right) \bmod M
$$

其中：

- $M=m_1m_2..m_k$；
- 对于第 $i$ 个方程，$M_i=\dfrac{M}{m_i}$，$M_i^{-1}$ 是 $M_i$ 在模 $m_i$ 意义下的逆元。

```cpp
#include <bits/stdc++.h>
#define int long long

int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}

int CRT(std::vector<int> m, std::vector<int> a) { //下标从 0 开始
    assert(m.size() == a.size());
    int n = m.size(), M = 1, res = 0;
    for (int i = 0; i < n; i++) {
        M *= m[i];
    }
    for (int i = 0; i < n; i++) {
        int Mi = M / m[i];
        int u, v, d = exgcd(Mi, m[i], u, v);
        u = (u % m[i] + m[i]) % m[i];
        res += a[i] * u * Mi;
    }
    return res % M;
}

signed main() {
   int n;
    std::cin >> n;
    std::vector<int> m(n), a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> m[i] >> a[i];
    }
    std::cout << CRT(m, a) << "\n";
    return 0;
}
```



【扩展中国剩余定理（EXCRT）】

还是上一道题，不保证 $m$ 之间互质了。

对于两个方程
$$
\begin{cases}
x\equiv a_1 \pmod{m_1} \\
x\equiv a_2 \pmod{m_2} 
\end{cases}
$$
转换为不定方程 $x=m_1p+a_1=m_2q+a_2$。则 
$$
m_1p-m_2q=a_2-a_1
$$
由裴蜀定理，当且仅当 $\gcd(m_1,m_2) \nmid (r_2-r_1)$ 时无解。因此由扩欧算法得到方程的一组特解 $(p_0,q_0)$ 。通解为：
$$
\begin{cases}
p = p_0+\dfrac{m_2}{\gcd(m_1,m_2)}\cdot k \\
q = q_0-\dfrac{m_1}{\gcd(m_1,m_2)}\cdot k

\end{cases}
$$


所以 $x=m_1p+a_1=\dfrac{m_1m_2}{\gcd(m_1,m_2)} \cdot k + m_1p+a_1=\operatorname{lcm}(m_1,m_2)\cdot k+m_1p+a_1$。

即：
$$
x\equiv m_1p_0+a_1 \pmod{\operatorname{lcm}(m_1,m_2)}
$$
这样就把两个方程合并为了一个方程。

[EXCRT 模板题](https://www.luogu.com.cn/problem/P4777#submit)

```c++
#include <bits/stdc++.h>
#define int long long

int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}

int exCRT(std::vector<int> m, std::vector<int> a) { // 下标从 0 开始
    assert(m.size() == a.size());
    auto merge = [&](int &m1, int &a1, int m2, int a2) {
        int u, v;
        int g = exgcd(m1, m2, u, v);
        int m = m1 / g * m2;
        if ((a2 - a1) % g != 0) {
            return false;
        }
        int d = (a2 - a1) / g;
        int x = (__int128(u) * m1 * d + a1) % m;
        if (x < 0) {
            x += m;
        }
        m1 = m, a1 = x;
        return true;
    };
    int n = m.size(), mm = m[0], res = a[0];
    for (int i = 1; i < n; i++) {
        if (!merge(mm, res, m[i], a[i])) {
            return -1;
        }
    }
    return res;
}

signed main() {
    int n;
    std::cin >> n;
    std::vector<int> m(n), a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> m[i] >> a[i];
    }
    std::cout << exCRT(m, a) << "\n";
    return 0;
}
```



## 高次同余方程（同余对数）

【BSGS】

[P3846 [TJOI2007] 可爱的质数/【模板】BSGS](https://www.luogu.com.cn/problem/P3846)

题意：给定 $a,b,p$，**保证 $a,p$ 互质**，求最小的 $x$，满足 $a^x \equiv b \pmod{p}$。或者报告无解。

$2 \le a,b,p\le 2^{31}$。

思路：首先根据费马小定理，答案一定在 $[0,p - 1]$ 范围内。

BSGS 的思想是根号分块，设答案 $x=i\cdot k-j$，其中 $k= \lceil \sqrt{p} \rceil$，$i,j\in[1,k]$。我们发现这样 $i,j,k$ 其实就足够表示 $[0,p]$ 的所有整数了。

把 $x$ 代回去有 $(a^k)^i\equiv b\times a^j \pmod{p}$。

因为 $i,j$ 都是 $\sqrt{p}$ 的规模，所以先枚举 $j$，把 $b_j$ 的值存进哈希表，然后再枚举 $i$ 去比配。$j$ 要尽可能地大，$i$ 要尽可能地小。

```cpp
int BSGS(int a, int b, int MOD) {
    a %= MOD;
    b %= MOD;
    if (b == 1) {
        return 0;
    }
    int k = sqrt(MOD) + 1;
    unordered_map<int, int> hash;
    for (int i = 0, j = b; i < k; i++) {
        hash[j] = i;
        j = j * a % MOD;
    }
    int ak = 1;
    for (int i = 0; i < k; i++) {
        ak = ak * a % MOD;
    }
    for (int i = 1, j = ak; i <= k; i++) {
        if (hash.count(j)) {
            return i * k - hash[j];
        }
        j = j * ak % MOD;
    }
    return -1;
}
```



【exBSGS】

[P4195 【模板】扩展 BSGS/exBSGS](https://www.luogu.com.cn/problem/P4195)

题意：给定 $a,b,p$，**不保证 $a,p$ 互质**，求最小的 $x$，满足 $a^x \equiv b \pmod{p}$。或者报告无解。

$a,b,p \le 10^9$

思路：若 $b=0$，则 $p=1$ 时有解，否则无解。

若 $b=1$，则 $x=0$。

否则，设 $d=\gcd(a, p)$。若 $d \not\mid b$ 则无解，否则两边同时除以 $d$，得到
$$
(\frac{a}{d})a^{x-1} \equiv \frac{b}{d} \pmod{\frac{p}{d}}
$$
因为 $\gcd(\dfrac{a}{d},\dfrac{p}{d})=1$，所以
$$
a^{x-1}\equiv (\frac{a}{d})^{-1}(\frac{b}{d}) \pmod{\frac{p}{d}}
$$
多次执行上面的过程，知道 $a,p$ 互质，然后使用 BSGS。

```cpp
#include <bits/stdc++.h>
#define int long long

int qpow(int x, int k, int MOD) {
    int res = 1;
    while (k) {
        if (k % 2) {
            res = res * x % MOD;
        }
        k /= 2;
        x = x * x % MOD;
    }
    return res;
}

void exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return;
    }
    int t;
    exgcd(b, a % b, x, y);
    t = x;
    x = y;
    y = t - a / b * y;
}

int inv(int a, int b) {
    int x, y;
    exgcd(a, b, x, y);
    return (x % b + b) % b;
}

int BSGS(int a, int b, int MOD) {
    a %= MOD;
    b %= MOD;
    if (b == 1) {
        return 0;
    }
    int k = sqrt(MOD) + 1;
    std::unordered_map<int, int> hash;
    for (int i = 0, j = b; i < k; i++) {
        hash[j] = i;
        j = j * a % MOD;
    }
    int ak = 1;
    for (int i = 0; i < k; i++) {
        ak = ak * a % MOD;
    }
    for (int i = 1, j = ak; i <= k; i++) {
        if (hash.count(j)) {
            return i * k - hash[j];
        }
        j = j * ak % MOD;
    }
    return -1;
}

int exBSGS(int a, int b, int MOD) {
    if (MOD == 1) {
        return 0;
    }
    a %= MOD;
    b %= MOD;
    if (b == 1) {
        return 0;
    }
    int x = 0, t, res;
    int y = 1;
    while ((t = std::gcd(a, MOD)) != 1) {
        if (b % t != 0) {
            return -1;
        }
        b /= t;
        MOD /= t;
        x++;
        y = y * (a / t) % MOD;
        if (b == y) {
            return x;
        }
    }
    res = BSGS(a, b * inv(y, MOD) % MOD, MOD);
    if (res == -1) {
        return -1;
    }
    return res + x;
}

int a, b, MOD;

void solve() {
    std::cin >> a >> MOD >> b;
    if (a == 0 && b == 0 && MOD == 0) {
        exit(0);
    }
    int res = exBSGS(a, b, MOD);
    if (res == -1) {
        std::cout << "No Solution\n";
    } else {
        std::cout << res << "\n";
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    while (1) {
        solve();
    }
    return 0;
}
```



## 二次剩余（同余开方）（不会）

[P5491 【模板】二次剩余](https://www.luogu.com.cn/problem/P5491)

题意：给出 $n,p$，求解方程 $x^2\equiv n \pmod{p}$。其中 $p$ 是奇素数。

在洛谷抄了一份板子。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll read() {
	ll x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();}
	return x*f;
}

struct num {
	ll x;// 实部
	ll y;// 虚部(即虚数单位√w的系数)
};

ll t,w,n,p;

num mul(num a,num b,ll p) {// 复数乘法 
	num res;
	res.x=( (a.x*b.x%p+a.y*b.y%p*w%p) %p+p)%p;// x = a.x*b.x + a.y*b.y*w
	res.y=( (a.x*b.y%p+a.y*b.x%p) %p+p)%p;// y = a.x*b.y + a.y*b.x
	return res;
}
ll qpow_r(ll a,ll b,ll p) {// 实数快速幂 
	ll res=1;
	while(b) {
		if(b&1) res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}
ll qpow_i(num a,ll b,ll p) {// 复数快速幂  
	num res={1,0};
	while(b) {
		if(b&1) res=mul(res,a,p);
		a=mul(a,a,p);
		b>>=1;
	}
	return res.x%p;// 只用返回实数部分，因为虚数部分没了 
}
ll cipolla(ll n,ll p) {
	n%=p;
	if(qpow_r(n,(p-1)/2,p)==-1+p) return -1;// 据欧拉准则判定是否有解 
	
	ll a;
	while(1) {// 找出一个符合条件的a
		a=rand()%p;
		w=( ((a*a)%p-n) %p+p)%p;// w = a^2 - n，虚数单位的平方
		if(qpow_r(w,(p-1)/2,p)==-1+p) break;
	}
	
	num x={a,1};
	return qpow_i(x,(p+1)/2,p);
}
int main() {
	srand(time(0));
	t=read();
	while(t--) {
		n=read(); p=read();
		if(!n) {
			printf("0\n");
			continue;
		}
		
		ll ans1=cipolla(n,p),ans2=-ans1+p;// 另一个解就是其相反数 
		if(ans1==-1) printf("Hola!\n");
		else {
			if(ans1>ans2) swap(ans1,ans2);
			if(ans1==ans2) printf("%lld\n",ans1);
			else printf("%lld %lld\n",ans1,ans2);
		}
	}

	return 0;
}

```



# 数论分块

**问题**：

- 对所有的 $i\in[1,n]$，统计 $\left\lfloor\dfrac{n}{g(i)} \right\rfloor$ 的影响。



**处理方法**：

- 将 $[1,n]$ 分为连续的若干段，每一段 $[L,R]$ 当中的任意数字 $i\in[L,R]$ 都有 $\left\lfloor\dfrac{n}{g(i)} \right\rfloor$ 相等。$L$ 从 $1$ 开始，当前段右端点 $R$ 需要解一个不等式：

$$
\dfrac{n}{g(i)} \ge \left\lfloor \dfrac{n}{g(L)}\right\rfloor\iff g(i) \le \frac{n}{\left\lfloor\dfrac{n}{g(L)} \right\rfloor}
$$

​		解出最大的 $i$ 就是当前需要的 $R$。

- 最简单的例子 $\left\lfloor \dfrac{n}{i} \right\rfloor$，对于当前块的左端点 $L$，右端点为 $\dfrac{n}{\left\lfloor \dfrac{n}{L} \right\rfloor}$。

- 如果是二维/更高维数论分块，对每一维分别计算右端点，去最小值作为当前块右端点即可。



**（应用）计算和式：**

- 一般形式为 $\displaystyle \sum_{i=1}^{n}f(i)\left\lfloor\dfrac{n}{g(i)} \right\rfloor $。每一块内答案为 $\displaystyle g(L)\cdot \sum_{i=L}^{R}f(i)$。

```cpp
for(int L = 1, R; L <= n; L = R + 1) {
    R = ...		// 根据 L 计算分块的右端点
    ans += ...;	// 对将块内贡献累加到总答案
}
```

- 例如：计算和式 $\displaystyle \sum_{i=1}^{n} \left\lfloor \frac{n}{i} \right \rfloor$。此时 $g(i)=i$，对于确定的 $L$，右端点为 $\dfrac{n}{\left\lfloor\dfrac{n}{L}\right\rfloor}$，一个块内的贡献为 $(R -L) \cdot \dfrac{n}{L}$。



**（应用）维护数据结构**：

[CF1538F. A Heap of Heaps](https://www.luogu.com.cn/problem/CF538F) 

【题意】给一个序列形式的小根堆，对于所有的 $k\in[1,n-1]$，求当这个堆是一个 $k$ 叉堆时，有多少个点值非法（小于它的父亲）。

【做法】对于 $k$ 叉树，点 $i$ 的父亲为 $\left\lfloor\dfrac{i-2}{k}\right\rfloor+1$。所以对于每个节点，批量统计 $k$ 在哪些范围时它不合法。对 $k\le i-2$ 使用整除分块， 对 $k>i-2$ 直接判断 $a[i]$ 与 $a[1]$ 的大小关系。 用差分维护区间加。

```cpp
#include <bits/stdc++.h>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }
    
    std::vector<int> ans(n + 1);    // ans 的差分数组，方便区间加
    for (int i = 1; i <= n; i++) {
        for (int L = 1, R; L <= i - 2; L = R + 1) {
            // L 叉树的父节点编号
            int f = (i - 2) / L + 1;
            R = std::min(n, (i - 2) / ((i - 2) / L));
            if (a[f] > a[i]) {
                ans[R + 1] -= 1;
                ans[L] += 1;
            }
        }
        if (a[i] < a[1]) {
            ans[i - 1] += 1;
            ans[n] -= 1;
        }
    }

    for (int i = 1; i < n; i++) {
        ans[i] += ans[i - 1];
        std::cout << ans[i] << " ";
    }

    return 0;
}
```



**（应用）解不等式：**

[1789E. Josuke and Complete Graph](https://codeforces.com/contest/1780/problem/E)

【题意】给定区间 $[l,r]$，从中任取两个数字 $a,b$，问 $\gcd(a,b)$ 有多少种不同的取值。$10^9 \le l,r \le10^{18}$。

【做法】对于整数 $x$，存在两个数字 $a,b\in[l,r]$ 使得 $\gcd(a,b)=x$，那么充要条件是：$[l,r]$ 中存在 $x$ 的两个相邻倍数。

- 如果 $x\ge l$，那么只需要 $2x \le r$ 即可；
- 如果 $x < l$，那么需要满足 $x\cdot (\left\lceil \dfrac{l}{x} \right\rceil + 1) \le r$。把上取整换成下取整 $x \cdot (\left\lfloor \dfrac{l - 1}{x}\right\rfloor + 2) \le r$。可以进行整除分块，每个块分别求解，对于当前块的左边界 $L$，$x$ 只需要满足 $x\le \dfrac{2}{\left\lfloor \dfrac{l - 1}{L}\right\rfloor + 2}$ 。把每个块内满足要求的 $x$ 的个数加起来就是答案。



# 欧拉函数 & 欧拉反演

## 欧拉函数

欧拉函数 $\phi(n)$ 表示 $[1,n]$ 中与 $n$ 互质的数字个数：
$$
\phi(n) = \sum_{i=1}^{n} [\gcd(i,n)=1] \tag{定义式}
$$

计算方法

1. 计算通式：设 $n$ 的质因数分解式 $n = \displaystyle\sum\limits_{i = 1}^{k} p_i ^{c_i}$，欧拉函数表达式如下：

$$
\varphi(n)=n\prod_{i=1}^{k}\frac{p_i-1}{p_i} \tag{计算式}
$$

推导（容斥原理）

> $$
> \begin{aligned}
> 
> \varphi(n) &=  n -  \sum\limits_{1 \le i \le k} \dfrac{n}{p_i} + \sum\limits_{1 \le i < j \le k} \dfrac{n}{p_ip_j} - \dots \\
> 
> &= n \prod\limits_{i = 1}^{k} \left( 1 - \dfrac{1}{p_i} \right) 
> 
> = n\prod\limits_{i = 1}^{k}\dfrac{p_i - 1}{p_i}
> 
> \end{aligned}
> $$

推导（积性函数）

> $$
> \begin{aligned}
> 
> \varphi(n) &= \varphi(\prod\limits_{i = 1}^{k}p_i^{c_i})
> 
> = \prod\limits_{i = 1}^k \varphi(p_i ^{c_i})
> 
> = \prod\limits_{i = 1}^k p_i^{c_i} (1 - \dfrac{1}{p_i}) 
> 
> = n \prod\limits_{i = 1}^{k}\dfrac{p_i - 1}{p_i}
> 
> \end{aligned}
> $$
> 

公式法求欧拉函数，时间复杂度为 $\dfrac {\sqrt n} {\log n} $


```c++
int phi(int x) {
    int res = x;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            res = res / i * (i - 1);
            while (x % i == 0) {
                x /= i;
            }
        }
    }
    if (x > 1) {
        res = res / x * (x - 1);
    }
    return res;
}
```



2. 对于素数 $p$ :

$$
\begin{align}
\varphi (p) &= p - 1 \tag{1}\\

\varphi (p^k) &= p^k - p^{k - 1} \tag{2}

\end{align}
$$

> 对于(1)：小于 $p$ 的所有整数都与 $p$ 互质
>
> 对于(2)：不超过 $p$ 的数字中，只有 $p$ 的倍数与 $p^k$ 不互质。



3. 若 $x,y$ 不互质，则 $\varphi(xy)=\dfrac{\varphi(x)\times\varphi(y)\times \gcd(x,y)}{\varphi(\gcd(x,y))}$。

> 证明未知。



线性筛欧拉函数：原理如下

> 1. 若 $x$ 为质数，则有 $\varphi(x) = x - 1$
> 2. 若 $x$ 为合数，则 $\varphi(x)$ 一定在之前被求出。
> 3. 然后枚举素数 $p$ 进行线性筛。由于线性筛的特点， $p$ 一定是  $p\cdot x$ 最小的质因子。
>
> $$
> \varphi(px) = 
> \begin{cases}
> p \cdot \varphi(x), &p \mid x\\
> \varphi(p) \cdot \varphi(x), & p\nmid x
> \end{cases}
> $$

代码如下

```c++
int primes[N], pcnt = 0, phi[N];
bool vis[N];

void init(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (vis[i] == 0) {
            primes[++pcnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= pcnt && primes[j] * i <= n; j++) {
            int x = i * primes[j];
            vis[x] = 1;

            if (i % primes[j] == 0) {
                phi[x] = phi[i] * primes[j];
                break;
            } else {
                phi[x] = phi[i] * (primes[j] - 1);
            }
        }
    }
}
```



性质

1. $n>2$ 时，$ \varphi(n)$ 是偶数。进而可以得出：$[1,n]$ 中与 $n$ 互质的数的和：

$$
\sum\limits_{i=1}^{n}i[\gcd(i,n)=1]= \dfrac{n\varphi(n)+[n=1]}{2}
$$


> Proof：
>
> 由于更相减损术，$gcd(n,m)=gcd(n,n-m)$。所以每一个与 $n$ 互质的数字 $m$ 都对应一个 $n-m$ 与 $n$ 互质。
>

> 若 $n = 1$，则答案显然为 1。
>
> 对于 $n > 1$，与 $n$ 互质的数字总是成对出现，总共有 $\dfrac{\varphi(n)}{2}$ 对，每一对的和都为 $n$。所以答案为 $\dfrac{n\varphi(n)}{2}$。



2. 欧拉函数的卷积性质：

$$
\sum_{d|n}^{}\varphi(d)=n
$$

或者简写为：
$$
\varphi*1=id
$$


> Proof：
>
> 如果我们设 $f(x)$ 表示有多少个整数 $k$ 满足 $\gcd(k, n) = x$，那么 $n = \sum_{i = 1}^n{f(i)}$。（显然包含 $1\sim n$ 中所有的数）
>
> 由于 $\gcd(k,n) = x \iff \gcd(\dfrac{k}{x}, \dfrac{n}{x}) = 1$，所以 $f(x)$ 等价于与 $\dfrac{n}{x}$ 互质的数字个数，即 $f(x) = \varphi(\dfrac{n}{x})$。
>
> 从而 $n = \sum_{d \mid n}\varphi(\dfrac{n}{d})$，因为约数 $d$ 和 $\dfrac{n}{d} $ 具有对称性，所以上式化为 $n = \sum_{d \mid n}\varphi(d)$



3. 小结论：满足 $x+y=k(k>1)$，且 $\gcd(x,y)=1$ 的数对 $(x,y)$ 的数量 $=\varphi(k)$：

$$
\sum\limits_{x = 1}^{k}[\gcd(x, k - x) = 1] =\sum\limits_{x = 1}^{k}[\gcd(x, k) = 1]= \varphi(k)
$$



4. [[SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158)

在 $[1, n]$ 范围内，求互质的数对 $(i, j)$ 的数量：
$$
\sum\limits_{i=1}^n\sum\limits_{j=1}^n[\gcd(i,j)=1]=2\sum_{i=1}^n\varphi(i)-1
$$

> Proof：
>
> 我们假设 $1 \le i \le j$，将结果乘以 $2$ 即可。当$i = j > 1$ 时，$\gcd(i, j) = i \ne 1$，所以仅有 $i = j = 1$ 的情况被重复计算，所以最后答案减 $1$。
>
> 对于给定的 $i$，$\sum\limits_{j = 1}^{i} [\gcd(i, j) = 1]$ 就等于 $\varphi(i)$。
>
> 所以自然的答案为 $2\sum\limits_{i = 1}^{n} \varphi(i) - 1$。



5. [[SDOI2012] Longge 的问题](https://www.luogu.com.cn/problem/P2303)

求 $[1,n]$ 内每个数字与 $n$ 的 $\gcd$ 之和（$1 \le n \le 10^9$）：
$$
\sum_{i=1}^n\gcd(i,n)=\sum_{d|n}d \cdot \varphi(\frac{n}{d})
$$

> Proof：
>
> 我们设 $t(x)$ 为 $1\sim n$ 中与 $n$ 的 $\gcd$ 为 $x$ 的数的个数，即：
> $$
> t(x) = \sum_{i = 1} ^ {n} [\gcd(i, n) = x] = \sum_{i = 1}^{\left \lfloor \frac{n}{x}  \right \rfloor} [\gcd(\dfrac{i}{x}, \dfrac{n}{x}) = 1] = \varphi(\left \lfloor \frac{n}{x}  \right \rfloor)
> $$
> 所以原式可化简为：
> $$
> \sum_{i = 1}^n \gcd(i, n) = \sum_{d|n} d\cdot c(d) = \sum_{d|n}d \cdot \varphi(\dfrac{n}{d})
> $$



## 欧拉反演

利用 
$$
id = \phi * 1
$$
把 $n$ 拆成 $\sum_{d\mid n} \phi(d)$ 的形式。



1. 

$$
    \gcd(i, j)= \sum_{x\mid i,x\mid j} \varphi(x)
$$

  

2. 

$$
    \begin{aligned}
    \sum_{i=1}^{n}\sum_{j=1}^{m} \gcd(i,j)
    &= \sum_{i=1}^{n}\sum_{j=1}^{m} \sum_{x\mid i,x\mid j} \varphi(x)\\
    &= \sum_{x=1}^{n}\varphi(x) \sum_{i=1}^{n}\sum_{j=1}^{n} [x\mid i][x \mid j] \\
    &= \sum_{x=1}^{n}\varphi(x) \left\lfloor \dfrac{n}{x}  \right\rfloor
    \left\lfloor \dfrac{m}{x}  \right\rfloor
    \end{aligned}
$$

​    

# 莫比乌斯函数 & 莫比乌斯反演

## 莫比乌斯函数

【定义和计算】

设 $n$ 的质因数分解为 $n = \prod \limits_{i = 1} ^ {k} p_i^{c_i}$，定义莫比乌斯函数如下：
$$
\mu(n)=
\begin{cases}
0  & \exist i \in [1, k], \  c_i>1\\
(-1)^k  & \forall i \in [1, k], \  c_i = 1
\end{cases}
$$

公式法求莫比乌斯函数，复杂度 $O(\dfrac{\sqrt n }{\log n})$

```cpp
int mu(int x) {
	int cnt = 0;
	for (int i = 2; i * i <= x; i++) {
		if (x % i == 0) {
			x /= i;
			if (x % i == 0) {
				return 0;
			}
			cnt++;
		}
	}
	if (x != 1) {
		cnt++;
	}
	return (cnt & 1) ? -1 : 1;
}
```

【性质】

莫比乌斯函数的卷积性质：
$$
\sum_{d\mid n} \mu(d) = \varepsilon(n) = \begin{cases}

1, &n = 1\\
0, &n > 1

\end{cases}
$$
卷积形式为：
$$
\mu * 1 = \varepsilon
$$

> 证明：
>
> 只需考虑 $n > 1$ 的情形，此时显然 $k > 0$。
>
> 设 $n = \prod\limits_{i = 1}^{k} p_i^{c_i}$，$n' = \prod\limits_{i = 1}^{k} p_i$。
>
> 那么由于莫比乌斯函数的定义，结合二项式定理，有：
>
> $$
> \begin{align}
> \sum\limits_{d \mid n} \mu(d) & = \sum\limits_{d \mid n'} \mu(d)\\
> 
> & = \sum\limits_{i = 0}^{k} {k \choose i} \cdot (-1)^{i} \\
> & = (1 + (-1))^k \\
> & = 0
> 
> \end{align}
> $$

【线性筛】

原理如下

>对于素数 $p$，有 $\mu(p)=-1$。
>
>若素数 $p$ 小于 $x$ 的最小质因子，那么 $\mu(px)=-\mu(p)$。
>
>若素数 $p$ 是 $x$ 的最小质因子，那么 $\mu(px)=0$。

代码如下

```c++
int pcnt = 0, mu[N], primes[N], pre[N];
bool vis[N];

void getmu(int n) {
    pcnt = 0;
    mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            primes[++pcnt] = i;
            mu[i] = -1;
        }
        for (int j = 1; j <= pcnt && primes[j] * i <= n; j++) {
            int x = primes[j];
            vis[x * i] = 1;
            if (i % x == 0) {
                mu[i * x] = 0;
                break;
            } 
            mu[i * x] = -mu[i];
        }
    }
    for (int i = 1; i <= n; i++) {
        pre[i] = pre[i - 1] + mu[i];
    }
}
```



## 莫比乌斯反演

【形式1】

如果 $F(n)=\sum_{d|n}f(d)$，则有 
$$
f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})
$$

【形式2】

如果 $F(n)=\sum_{n|d}f(d)$，那么有
$$
f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)
$$

简而言之：若 $F=f*1$，则 $f=\mu*F$。

【推论】

1. 

$$
[\gcd(i, j)=1] = \sum_{d\mid i, d\mid j}\mu(d)
$$

2. 

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j) = k] = \sum_{d=1}^{\lfloor \frac{n}{k} \rfloor} \mu(d) \lfloor\frac{n}{dk}\rfloor \lfloor\frac{m}{dk}\rfloor
$$

3. 

$$
\sum_{i=1}^{n}\sum_{j=1}^{m} \operatorname{lcm}(i,j) = \sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^2 \mu(x) 
\frac{(1 + \lfloor\frac{n}{dx}\rfloor)\lfloor\frac{n}{dx}\rfloor}{2} \dfrac{(1 + \lfloor\frac{m}{dx}\rfloor) \lfloor\frac{m}{dx}\rfloor}{2}
$$



# 积性函数与卷积总结

## 约数个数函数

【定义】

$d(n)$ 表示 $n$ 的约数个数。

$$
d(n)=\sum_{i|n}1
$$

【计算式】

设 $n$ 的唯一分解为 $n=\prod\limits_{i=1}^{k}p_i^{c_i}$，则：

$$
d(n)=\prod\limits_{i=1}^{k}(c_i+1)
$$

【性质】

[[SDOI2015]约数个数和](https://www.luogu.com.cn/problem/P3327) 当中需要的一个结论
$$
d(xy)=\sum_{i|x}\sum_{j|y}[\gcd(i,j)=1]
$$

> 证明：
>
> 思路是把 $x\cdot y$ 的每一个因子 $k$ 一一映射为一个数对 $(i,j)$ 。
>
> 对于 $xy$ 的某一个因子 $k$，假设 $k$ 中的某一个质因子 $p$ 出现了 $c$ 次。
>
> 那么假设 $x,y$ 中分别包含了质因子 $p$ 的 $a, b$ 次方，一定有 $a + b > c$。我们规定：
>
> - 如果 $c < a$，那么就只在 $x$ 中选择 $p^c$；
> - 否则，在 $y$ 中选择 $p^{c - a}$ 。
>
> 通过这种方法选出的数字 $i, j$ 一定互质。

【线性筛】

线性筛约数个数函数的原理如下。

> - $d(x)$ 为 $x$ 的约数个数；
>- $g(x)$ 为 $x$ 的最小质因子出现的次数。
> 
> 对于素数 $p$，有 $g(p)=1$，$d(p)=2$。
>
> 若素数 $p$ 小于 $x$ 的最小质因子，那么 $g(px)=1$，$d(px)=d(p)\cdot d(x)=2\cdot d(x)$。
>
> 若素数 $p$ 是 $x$ 的最小质因子，那么 $g(px)=g(x)+1$，$d(px)=\dfrac{d(x)\cdot(g(px)+1)}{g(px)}$。

```c++
/*
d[i]是i的约数个数
g[i]是i的最小质因子出现次数
*/

void getdg(int n) {
    d[1] = 1;

    for (int i = 2; i <= n; ++i) {
        if (vis[i] == 0) {
            vis[i] = 1;
            primes[ ++ pcnt] = i;
            d[i] = 2;
            g[i] = 1;
        }

        for (int j = 1; j <= pcnt && i * primes[j] <= n; ++ j) {
            vis[primes[j] * i] = 1;

            if (i % primes[j] == 0) {
                //这里的primes[j]一定是i的最小质因子
                g[i * primes[j]] = g[i] + 1;
                d[i * primes[j]] = d[i] / g[i * primes[j]] * (g[i * primes[j]] + 1);
                break;
            } else {
                g[i * primes[j]] = 1;
                d[i * primes[j]] = d[i] * 2;
            }
        }
    }

}
```



## 约数和函数

【定义】

$\sigma(n)$ 表示 $n$ 的所有约数的和。

$$
\sigma(n)=\sum_{d|n}d
$$

【计算】

设 $n$ 的质因数分解为 $n=\prod_{i=1}^{k}p_i^{c_i}$，则：
$$
\begin{align}

\sigma(n)

&=(1 + p_1 + \dots + p_1^{c_1}) \times \dots \times(1 + p_k + \dots +  p_k^{c_k}) \\

&= \prod_{1=1}^k(\sum_{j=0}^{c_i}p_i^j) 

\end{align}
$$

> 把第一行的式子展开成多项式，$n$ 的每一个因数的质因子选择情况都包含在内。

【线性筛】

> - $f(x)$ 为 $x$ 的约数和；
>
>
> - $g(x)$ 为辅助函数，设 $x$ 的最小质因子为 $p$，$x$ 中包含 $p$ 的 $k$ 次幂，则 $g(x) = 1 + p + p ^ 2 + \dots + p^{k}$。
>
> 对于素数 $p$，有 $g(x)=x+1$，$f(x)=x+1$。
>
> 若素数 $p$ 小于 $x$ 的最小质因子，那么 $g(px)=p+1$，$f(px)=f(p)\cdot f(x)$。
>
> 若素数 $p$ 是 $x$ 的最小质因子，那么 $g(px)=p\cdot g(x)+1$，$f(px)=\dfrac{f(x)\cdot g(px)}{g(x)}$。

```c++
void get_divisor_sum() {
    g[1] = f[1] = 1;

    for (int i = 2; i <= n; ++ i) {
        if (vis[i] == 0) {
            vis[i] = 1;
            primes[++pcnt] = i;
            g[i] = i + 1;
            f[i] = i + 1;
        }

        for (int j = 1; j <= pcnt && i * primes[j] <= n; ++ j) {
            v[i * primes[j]] = 1;

            if (i % primes[j] == 0) {
                g[i * primes[j]] = g[i] * primes[j] + 1;
                f[i * primes[j]] = f[i] / g[i] * g[i * primes[j]];
                break;
            } else {
                f[i * primes[j]] = f[i] * f[primes[j]];
                g[i * primes[j]] = primes[j] + 1;
            }
        }
    }

    // 原题需要求一下前缀和
    for (int i = 1; i <= n; ++ i) {
        f[i] = (f[i - 1] + f[i]) % MOD;
    }
}

```



## 重要卷积关系总结

常用积性函数函数

- 单位元函数：$\varepsilon(n)=[n=1]$

- 
    单位函数：$\mathrm{id}(n)=n$，完全积性函数

- 幂函数： $\mathrm{id}^k(n)=n^k$，完全积性函数

- 恒等函数： $1(n) = 1$

- 欧拉函数： $\varphi(n)=\sum\limits_{i=1}^{n}[\gcd(n,i)=1]$

- 约数和函数：$\sigma(n)=\sum\limits_{d|n}{}d$

- 约数个数函数：$\mathrm{d}(n)=\sum\limits_{d|n}{}1$

- 莫比乌斯函数：$\mu(n)=
    \begin{cases}
    0  & \exist i \in [1, k], \  c_i>1\\
    (-1)^k  & \forall i \in [1, k], \  c_i = 1
    \end{cases}$



1. 卷积的单位元

 $\varepsilon$ 是卷积的单位元。对任意数论函数 $f$：
$$
f*\varepsilon=f
$$

> 证明：
>
> 显然有 $f*\varepsilon(n) = \sum\limits_{d \mid n}f(d) \varepsilon(\dfrac{n}{d}) = \sum\limits_{d \mid n} f(d) [\dfrac{n}{d} = 1] = f(n)$。





2. 与 $1$ 卷积的含义

$f * 1(n)$ 的含义就是：对于 $n$ 的所有正因数 $d$，把 $f(d)$ 的函数值累加得到的结果。





3. 莫比乌斯函数的卷积关系（卷积逆元）

这个性质是莫比乌斯反演的根基：$\mu$ 和 $1$ 互为卷积逆元：
$$
1*\mu= \varepsilon
$$

> 已经在莫比乌斯函数的性质那部分证明过。





4.  欧拉函数的卷积关系

$$
\mathrm{id}*\mu=\varphi \\
\varphi*1=\mathrm{id}
$$

> 只需证明 $\varphi * 1 = id$。这个式子在欧拉函数的性质那部分证明过。





5. 约数和函数的卷积关系

$$
\mathrm{id} * 1 =\sigma
$$

> 证明：
>
> 显然有  $\begin{align}
> \mathrm{id}(n) * 1= & \sum\limits_{d \mid n}  \mathrm{id}(d) \times1(\dfrac{n}{d}) = \sum\limits_{d \mid n}d = \sigma(n)
> \end{align}$。





6. 约数个数函数的卷积关系

$$
1*1= \mathrm{d}
$$

> 证明：
>
> 显然 $\begin{align}
> 1 * 1(n) &= \sum\limits_{d \mid n}1(n) \times 1(n) = \sum\limits_{d \mid n} 1= d(n)
> \end{align} $。





7. 总结

$$
\mu \overset{*1}{\Rightarrow }  \varepsilon \overset{*1}{\Rightarrow } 1 \overset{*1}{\Rightarrow } \mathrm{d} \\
\varphi \overset{*1}{\Rightarrow } \mathrm{id} \overset{*1}{\Rightarrow } \sigma
$$



8. 卷积的预处理：$O(n \log n)$ 预处理卷积

若已知数论函数 $f, g$，可以将枚举约数转换成枚举倍数，以调和级数 $O(n\log n)$ 的复杂度求出 $f * g$ 的前 $n$ 项 ：

```cpp
for (int i = 1; i <= n; ++ i) {
    for (int j = i; j <= n; j += i) {
        h[j] = (h[j] + f[i] * g[j / i]) % MOD;
    }
}
```





## Dilichelet 前缀和





## 一般积性函数的线性筛法





# 高级筛法

## 杜教筛





## 洲阁筛





## min25筛



