# 整除相关

## 整除

理解整除一定需要多重集的思想。

性质

- 若 $x, y$ 互质，那么 $x + y$ 与 $xy$ 互质。

证明：假设 $x + y$ 和 $xy$ 有共同的质因数 $t$。那么 $t$ 要么为 $x$ 的质因数，要么为 $y$ 的质因数，假设为前者。所以有 $t | x$，又因为 $t|(x + y)$ ，所以必然有 $t|y$，因此 $t$ 是 $x,y$ 的公因数，与题设矛盾。



## 素数

性质

1. 素数分布

相邻素数的间隔任意大，即：存在任意长的一段连续数，其中的所有数都是合数。

$N$ 以内的素数个数随着 $N$ 的增大趋近于 $lnN$。

2. 切比雪夫定理

对于 $x>1$，在 $(x,2x)$ 之间必存在至少一个素数。

对于 $x>3$，在 $(x,2x-2)$ 中至少有一个质数。



### 素数判定

1. 试除法，复杂度 $O(\sqrt{n})$

```c++
bool isprime(int x) {
    if (x == 1) {
        return 0;
    }
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            return 0;
        }
    }
    return 1;
}
```



2. Miller-Rabin判定

用于大素数判定，复杂度 $O(n^{\frac{1}{4}})$

```c++
int Rand() {
    static int x = (srand(int)time(0), rand());
    x += 1e6 + 3;
    if (x > 1e9 + 7) {
        x -= 1e9 + 7;
    }
    return x;
}

bool Witness(int a, int n) {
    int t = 0, u = n - 1;
    while (!(u & 1)) {
        u /= 2;
        ++t;
    }
    int x = qpow(a, u, n), y;
    while (t--) {
        y = x * x % n;

        if (y == 1 && x != 1 && x != n - 1) {
            return 1;
        }

        x = y;
    }
    return x != 1;
}

bool MillerRabin(int n, int s) {
    if (n == 2 || n == 3 || n == 5) {
        return 1;
    }
    if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n == 1) {
        return 0;
    }
    while (s--) {
        if (Witness(Rand() % (n - 1) + 1, n)) {
            return 0;
        }
    }
    return 1;
}
```



### 素数筛法

1. 埃氏筛

思想：找到一个素数就把它的所有倍数都筛掉。

复杂度 $O(nlogn)$。

```c++
int pcnt = 0, primes[N];
bool vis[N];

void getprimes(int n) {
    for (int i = 2; i <= n; i++) {
        if (vis[i]) {
            primes[++pcnt] = i;
        } else {
            for (int j = i * 2; i <= n; j += i) {
                vis[j] = 1;
            }
        }
    }
}
```



2. 线性筛

思想：每个数都只被自己最小的质因数筛掉。

复杂度 $O(n)$。

```c++
const int MAXN = 2e5 + 7;
int pcnt = 0, primes[MAXN + 10];
std::bitset<MAXN + 10> isp;

void init() {
    isp.set();
    pcnt = isp[0] = isp[1] = 0;
    for (int i = 2; i <= MAXN; i++) {
        if (isp[i]) {
            primes[++pcnt] = i;
        }
        for (int j = 1; j <= pcnt && i * primes[j] <= MAXN; j++) {
            int x = primes[j];
            isp[i * x] = 0;
            if (i % x == 0) {
                break;
            }
        }
    }
}
 
//100以内素数：2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
//把 vis 数组 01 翻转就是isprime数组，再取前缀和就是素数分布函数
```



3. 类素数筛

在 $O(nm)$ 复杂度打表，使得对于所有 $1\le i\le n,1\le j\le m$，有 $a[i][j]=lcm(i,j)$

```c++
void work() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j]) {
                continue;
            }
            for (int k = 1; k * i <= n && k * j <= m; k++) {
                a[i * k][j * k] = i * j * k;
            }
        }
    }
}
```



4. 二次筛

思想：先筛一部分素数，再用这些素数筛比较大的区间。

用来解决求区间 $[l,r]$ 内的素数，特点是 $r$ 很大但是 $r-l$ 较小。

[牛客 - 二次筛模板题](https://ac.nowcoder.com/acm/problem/228910)

【题意】

给出 $L,U$，求其中最近和最远的两个素数。本题 $L$ 和 $U$ 的范围较大，但 $U-L$ 不超过$1e6$。

【思路】

若 $r$ 为合数，则必有 $[1,\sqrt r]$ 以内的质因数。因此预处理 $[1,\sqrt r]$ 以内的素数，再用这些素数类似埃氏筛法筛掉 $[l,r]$ 的合数。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6;
bool vis[N], st[N];
int primes[N], ans[N];
int pcnt = 0, tot, L, U;

void getprimes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            primes[++pcnt] = i;
        }

        for (int j = 1; j <= pcnt && primes[j]*i <= n; j++) {
            vis[primes[j]*i] = 1;

            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

void SolveTest() {
    memset(st, 0, sizeof st);
    for (int i = 1; i <= pcnt; i++) {
        int p = primes[i];

        for (int j = max(p * 2, (L + p - 1) / p * p); j <= U; j += p) {
            st[j - L] = 1;
        }
    }
    tot = 0;
    memset(ans, 0, sizeof ans);
    for (int i = 0; i <= U - L; i++) {
        if (!st[i] && i + L >= 2) { //这里很重要，i+L可能为1
            ans[++tot] = i + L;
        }
    }
    if (tot < 2) {
        printf("There are no adjacent primes.\n");
    } else {
        int minp = 1, maxp = 1;

        for (int i = 1; i < tot; i++) {
            int d = ans[i + 1] - ans[i];

            if (d < ans[minp + 1] - ans[minp]) {
                minp = i;
            }

            if (d > ans[maxp + 1] - ans[maxp]) {
                maxp = i;
            }
        }
        printf("%d,%d are closest, %d,%d are most distant.\n",
               ans[minp], ans[minp + 1],
               ans[maxp], ans[maxp + 1]);
    }
}

signed main() {
    getprimes(100000);
    while (cin >> L >> U) {
        SolveTest();
    }
}
```



### 反素数

[牛客 - 反素数模板题](https://ac.nowcoder.com/acm/problem/50747)

定义：不超过 $n$ 的因子数量最多的数字。

【分析】

- 答案一定是从 $2$ 开始的连续的质因子；
- 质因子的次数递减

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
int pr[9] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
int ans, num;

void dfs(int u, int last, int p, int res) {
    if (res > ans || (res == ans && num > p)) {
        ans = res;
        num = p;
    }
    if (u == 9) {
        return ;
    }
    for (int i = 1; i <= last; i++) {
        if ((ll)p * pr[u] > n) {
            break;
        }
        p = p * pr[u];
        dfs(u + 1, i, p, res * (i + 1));
    }
}

int main() {
    scanf("%d", &n);
    dfs(0, 30, 1, 1);
    printf("%d\n", num);
    return 0;
}
```



[反素数模板题2](https://codeforces.com/contest/27/problem/E)

​	



## 约数

### 分解质因数

1. 试除法

复杂度$O(\sqrt{n})$

```c++
struct Prime {
    int num, cnt;
};

void work(int x, vector<Prime> &p) {
    p.clear();
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int c = 0;
            while (x % i == 0) {
                c++;
                x /= i;
            }
            p.push_back({i, c});
        }
    }
    if (x > 1) {
        p.push_back({x, 1});
    }
}
```



2. Pollard Rho

作用：大数分解质因数。

https://www.luogu.com.cn/problem/P4718



3. [阶乘分解](https://ac.nowcoder.com/acm/problem/51043)

给定整数 $N\in[1,1e6]$，把 $N!$ 分解质因数。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
const int N = 2e6;
int primes[N], cnt = 0, c[N];
bool vis[N];

void getprimes(int n) {
    for (re int i = 2; i <= n; i++) {
        if (!vis[i]) {
            primes[++cnt] = i;
        }
        for (re int j = 1; j <= cnt && primes[j]*i <= n; j++) {
            vis[primes[j]*i] = 1;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

signed main() {
    int n;
    cin >> n;
    getprimes(n);
    for (int i = 1; i <= cnt; i++) {
        for (int j = primes[i]; j <= n; j *= primes[i]) {
            c[i] += n / j;
        }
    }
    for (int i = 1; i <= cnt; i++) {
        if (c[i]) {
            printf("%d %d\n", primes[i], c[i]);
        }
    }
}
```



4. n! 的因子的因子的个数和

https://codeforces.com/gym/102040 C题，

先将 $n!$ 进行唯一分解：$n!=\prod_{i=1}^{k}p_i^{\alpha _i}$

则答案为 $\prod_{i=1}^{k}(1+2+...+\alpha+1  )=\prod_{i=1}^{k} \frac{(\alpha+1)(\alpha+2)}{2}$





### 约数&算数基本定理

对于 $N=\prod_{i=1}^{k}p_i^{c_i}$

- 约数个数 $=\prod_{i=1}^{k}(p_i+1)$


- 约数和 $=\prod_{i=1}^{k}(\sum_{j=0}^{c_i}p_i^j )$


- 随机数据下，约数个数的期望是 $O ( \ln ⁡n )$




1. 试除法

求 $n$ 的所有约数

若不排序，复杂度$O(\sqrt{n})$

```c++
void solve(int n, vector<int> &factor) {
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            factor.push_back(i);
            if (i != n / i) {
                factor.push_back(n / i);
            }
        }
    }

    //sort(factor.begin(),factor.end());
}
```



2. 埃氏筛

求 $1 \dots n$ 的正约数集合

```c++
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; ++ i){
        for(int j = 1 ;j * i <= n; ++ j){
            factor[i * j].push_back(j);
        }
    }
    for(int i = 1; i <= n; ++ i){
        cout << i << ": ";
        for(int j = 0; j < factor[i].size(); ++ j)
            printf("%d ", factor[i][j]);
        puts("");
    }
    return 0;
}
```

推论：$1 ∼ n$ 中每个数的约数的总和大概为 $n\log n$



3. 二次筛

作用：大数分解质因数。

先预处理 $\sqrt n$ 的素数，再用这些素数去对 $N$ 进行质因数分解，再枚举每个质因子的次数。



4. [约数和的前缀和](https://lightoj.com/problem/a-new-function)

```c++
#define int long long 
int n, m, s, t, k, ans, a[N], kcase;

void solve(){
 	ans = 0;
	scanf("%lld", &n); 
	for (int l = 2, r; l <= n; l = r + 1) {
		r = n / (n / l);
		ans += (l + r) * (r - l + 1) / 2 * (n / l - 1);
	}
	cout << ans << endl;
}

signed main(){
	scanf("%lld", &t);
	while(t -- ) {
		printf("Case %lld: ", ++ kcase);
		solve();
	}
	return 0;
}

```



### GCD和LCA

1. 性质和结论

【性质】

$gcd(a,b)\times lca(a,b)=ab$



【性质】

更相减损：若 $a < b$ ，$gcd(a,b)=gcd(a-b,b)$

> 假设 $\gcd(a, b) = g$，则有 $a = k_1 g$，$b = k_2 g$，其中 $\gcd(k_1, k_2) = 1$。
> 由于 $k_1$ 与 $k_2$ 互质，所以 $k_1 - k_2$ 与 $k_2$ 互质。
> 所以 $a - b = g(k_1 - k_2)$ 与 $b = gk_2$ 的最大公因数仍为 $g$。



【重要性质】

辗转相除：$gcd(a,b)=gcd(a \bmod b,\ b)$。

> 假设 $\gcd(a, b) = g$，则有 $a = k_1 g$，$b = k_2 g$，其中 $\gcd(k_1, k_2) = 1$。
> 由于 $k_1$ 与 $k_2$ 互质，所以 $k_1 \bmod k_2$ 与 $k_2$ 互质。
> 所以 $a \bmod b = g(k_1 \bmod k_2)$ 与 $b = gk_2$ 的最大公因数仍为 $g$。



【性质】

$gcd(a,b,c)=gcd(gcd(a,b),c)$

$gcd(ka,kb)=k\times gcd(a,b)$

$gcd(a,bc)=1\Rightarrow \left\{\begin{matrix}
gcd(a,b)=1
 \\
gcd(a,c)=1\end{matrix}\right.$

$F为斐波那契数列，gcd(F_n,F_m)=F_{gcd(n,m)}$

$gcd(a^m-1,a^n-1)=a^{gcd(n,m)}-1$

$gcd(a,b)=1 \Rightarrow gcd(a^n,b^m)=1$

$gcd(a,b)=1\Rightarrow gcd(a^m-b^m,a^n-b^n)=a^{gcd(n,m)}-b^{gcd(n,m)}$

$(a+b) | ab\Rightarrow gcd(a,b)\ne1$

$设G=gcd(C_n^1,C_n^2,...,C_n^{n-1})，则G=\begin{cases}
n，n为素数\\
p，n为合数且有唯一质因子p\\
1，n有多个质因子
\end{cases}$

$\sum_{i=1}^{n}gcd(i,n)=\sum_{d|n}d\varphi(\frac{n}{d})$



2. 辗转相除法

```c++
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int lca(int a, int b) {
    return a / gcd(a, b) * b;
}
```



3. Stein

作用：求大数 $\gcd$。

```c++
int stein(int a, int b) {
    int k = 1;
    while ((!(a & 1)) && (!(b & 1))) {
        k *= 2;
        a /= 2;
        b /= 2;
    }
    while (!(a & 1)) {
        a /= 2;
    }
    while (!(b & 1)) {
        b /= 2;
    }
    if (a < b) {
        swap(a, b);
    }
    while (a != b) {
        a -= b;
        if (a < b) {
            swap(a, b);
        }
    }
    return k * a
}
```





### 斐波那契数列

性质和结论

1. $\sum_{i=1}^{n}f_i=f_{n+2}-1$

2. $\sum_{i=1}^{n}f_{2i-1}=f_{2n}$

3. $\sum_{i=1}^{n}f_{2i}=f_{2n+1}-1$

4. $\sum_{i=1}^{n}f_i^2=f_nf_{n+1}$

5. $f_{n+m}=f_{n-1}f_{m-1}+f_nf_m$

6. $f_n^2=(-1)^{(n-1)}+f_{n-1}f_{n+1}$

7. $f_{2n-1}=f_n^2-f_{n-2}^2$

8. $f_n=\frac{f_{n+2}+f_{n-2}}{3}$



快速求斐波那契数列第n项

```c++
int f(int n) {
    if (a[n] != 0) {
        return a[n];
    }
    int t = n;
    n /= 2;
    if (t % 2) {
        return a[t] = f(n) * f(n) % p + f(n + 1) * f(n + 1) % p;
    }
    else {
        return a[t] = (2 * f(n - 1) % p + f(n) % p) * f(n) % p;
    }
}
```



# 同余定理

## 性质

1. 若 $a\le b$， 则 $a \bmod\ b=0$；
2. 若 $a > b$，则 $a \bmod b < \dfrac{a}{2}$。
3. $x \bmod  y=x-y \left \lfloor \dfrac{x}{y} \right \rfloor$



## 欧拉定理 & 扩展欧拉定理

1. 欧拉定理

若 $\gcd(a,n)=1$，那么 $a^{\varphi(n) } \equiv 1 \pmod n$。

> 证明
> 设 $x_1, \dots , x_{\varphi(n)}$ 是一个以 $n$ 为模的简化剩余系。则$ax_1, \dots, ax_{\varphi(n)}$ 也是一个以 $n$ 为模的简化剩余系。
>
> 所以有 $\prod\limits_{i = 1}^{\varphi(n)} x_i \equiv \prod\limits_{i = 1}^{\varphi(n)}ax_i \pmod n$。
>
> 得到 $a^{\varphi(n)} \equiv 1 \pmod n$



2. 欧拉定理推论

$\exist x\in \mathbb{N}^*, a_x \equiv 1 \pmod n  \iff \gcd(a, n) = 1$



3. 扩展欧拉定理

这个定理的主要作用都是降幂。

$$
a^x \equiv 

\left \{ \begin{align} 

& a^{x \mod \varphi(n)}, & \gcd(a, n) = 1\\

& a^x, 		& \gcd(x, n)>1 \and x < \varphi(m)\\

& a^{x \mod \varphi(m)+\varphi (m) } ,  &\gcd(x, n)>1 \and x\ge \varphi(m)

\end{align} \right.

\pmod n
$$

例如 [P5091 【模板】扩展欧拉定理](https://www.luogu.com.cn/problem/P5091)，给定 $a,m,b$ 求 $a^b \bmod m$。



## 费马小定理

设 $p$ 为质数，如果 $\gcd(a, p) = 1$，那么 $a^{p-1} \equiv 1\pmod  p$。

另一种形式是 $a^p \equiv a \pmod p$。

> 证明：
>
> 由欧拉定理带入 $\varphi(p) = p - 1$ 直接得出。
>
> 下面给出另一种基于归纳法证明。
>
> 对于给定的质数 $p$，显然 $1^p \equiv 1\pmod p$。
>
> 假设 $a^p \equiv a \pmod{p}$ 成立，下面尝试证明 $(a + 1)^p \equiv a + 1 \pmod{p}$ 成立。
>
> 由二项式定理，$(a+1)^p = a^p + {p \choose 1}a^{p - 1} + {p \choose 2}a^{p-2} + \dots + 1$。
>
> 注意到 ${p \choose k} = \dfrac{p (p - 1) \dots (p - k + 1)}{k!}$ 在模$p$ 的意义下一定为 $0$。
>
> 所以上式 $(a + 1)^p \equiv a^p + 1$，带入 $a^p \equiv a\pmod p$，得到 $(a + 1)^p \equiv a + 1$。证毕。



## 威尔逊定理

1. 威尔逊定理

    如果 $p$ 为质数有

$$
\begin{align}
&(p - 1)! \equiv p - 1 \equiv -1 &\pmod{p}\\

\iff &(p - 2)! \equiv 1 &\pmod{p}
\end{align}
$$
​	另一种表述：若 $p$ 是质数，则 $(p - 1)! + 1$ 能够被 $p$ 整除。



2. 逆命题

    若一个数 $p$，满足条件 $p \mid (p - 1)! + 1$，那么 $p$ 是素数。

    综上 ：

$$
p \mid (p - 1)! + 1 \iff p \in primes
$$




## 裴蜀定理

1. 裴蜀定理

​	对任意两个不全为零的整数 $a,b$，存在两个整数 $x,y$，使得 $ax+by=\gcd(a,b)$。

> 证明：
>
> $a,b$ 其中之一为零的情形很显然成立。下面考虑 $a,b$ 都不为零的情况。
>
> 假设 $\gcd(a, b) = d$，可以将方程两遍同除以 $d$ 。
>
> 我们只需证明：存在两个整数 $x, y$，使得 $a_1x + b_1y = 1$，其中 $a_1, b_1$ 互质。
>
> 我们把辗转相除法中的运算展开，做成带余数的除法：
> $$
> \begin{aligned}
> a_1 &= q_1b_1+r_1 &(0\leq r_1<b_1) \\
> 
> b_1 &= q_2r_1+r_2 &(0\leq r_2<r_1) \\
> 
> r_1 &= q_3r_2+r_3 &(0\leq r_3<r_2) \\ 
> 
> &\cdots \\ 
> 
> r_{n-3} &= q_{n-1}r_{n-2}+r_{n-1} \\ 
> 
> r_{n-2} &= q_nr_{n-1}+r_n \\ 
> 
> r_{n-1} &= q_{n+1}r_n
> \end{aligned}
> $$
> 出于方便把所有的 $q$ 都换成$x$。不妨令辗转相除法在除到互质的时候退出，则 $r_n = 1$ 所以有 ：
> $$
> r_{n - 2} = x_nx_{n - 1}  + 1
> $$
>
> 即：$1 = r_{n - 2} - x_nr_{n - 1}$。
>
> 将倒数第三个式子带入，得 $1 = (1 + x_nx_{n - 1})r_{n - 2} - x_nr_{n - 3}$。
>
> 然后用同样的方法把 $r_{n - 2}, \dots, r_1$ 逐个消去。最终可得到 $1 = a_1x + b_1y$。



2. 裴蜀定理推论

$$
\gcd(a,b)∣c \iff ∃x,y∈Z,ax+by=c
$$

​	方程 $ax + by = \gcd(a, b)$ 称为丢番图方程。



3. 重要推论

对于两个给定的数 $a , b$，若存在整数 $x, y, n$，使得 $ax + by = n$，则称 $a,b$ 能表示出 $n$。

若 $a, b$ 互质，设 $C = ab - a - b$，则有如下结论：

- 对于 $n > C$， $n$ 一定能被 $a, b$ 表示；
- 对于 $0 \le n \le C$， $n$ 和 $C - n$ 只有一个能被 $a, b$ 表示；
- 由于 $C$ 能被 $a, b$ 表示，所以 $a, b$ 表示不出的最大的数为 $ab-a-b$；
- 对于 $n < 0$，无法被表示；

> 证明：
>
> 不妨设 $a < b$，答案为 $x$。设 $x\equiv ma \pmod {b}$，其中 $1 \le m \le b -1$。
>





# 同余方程

## 线性同余方程

### 二元模线性方程

【定理】

方程 $ax+by=c$ 有解的充要条件是$\gcd(a,b)\mid c$。

即 $\gcd(a,b)$ 是 $ax+by$ 可以表示出来的最小正整数。



【定理】

方程$\left \{ \begin{align} &a x + b y = d \\ &d = \gcd ⁡ ( a , b )  \end{align} \right .$ 的所有解为：
$$
\left\{\begin{matrix}
x=x_0+k\dfrac{b}{d}
 \\
y=y_0-k\dfrac{a}{d}

\end{matrix}\right.
$$
其中 $x_0, y_0$ 是原方程的一组特解，$ k\in \Z$。

如果需要求 $x$ 的最小正整数解，只需要用扩展欧几里得求出一个 $x_0$，然后 $x \bmod \dfrac{b}{d}$ 即为答案。



【定理】

方程 $ax+by=c,\gcd(a,b)\mid c$ 的所有解为：
$$
\left\{\begin{matrix}
x=x_0\dfrac{c}{d}+k\dfrac{b}{d}
 \\
y=y_0\dfrac{c}{d}-k\dfrac{a}{d}

\end{matrix}\right.
$$

其中 $x_0, y_0$ 是方程 $\left \{ \begin{align} &a x + b y = d \\ &d = \gcd ⁡ ( a , b )  \end{align} \right .$ 的一组特解，$ k\in \Z$。



### 扩展欧几里得（exGCD）

求出 $ax+by=\gcd(a,b)$的一组特解，返回的是 $\gcd(a,b)$。

> 原理：
>
> 首先构造两个方程：
> $$
> \begin{align}
> ax_1 + by_1 &= \gcd(a, b)\\
> 
> bx_2 + (a \bmod b)\cdot y_2 &= \gcd(b, a \bmod b)
> 
> \end{align}
> $$
> 由于辗转相除的原理：
> $$
> \gcd(a, b) = \gcd(b, a\bmod b)
> $$
> 所以得到：
> $$
> ax_1 + by_1 = bx_2 + (a\bmod b)\cdot y_2 
> $$
> 结合 $a \bmod b = a - (\left \lfloor \dfrac{a}{b} \right \rfloor \cdot b)$，带入化简整理：
> $$
> ax_1 + by_1 = ay_2 + b(x_2 - \left \lfloor \dfrac{a}{b} \right \rfloor  \cdot y_2)
> $$
> 对比左右得到：
> $$
> \left \{
> \begin{align}
> 
> 
> &x_1 = y_2\\
> 
> 
> &y_1 = x_2 - \left\lfloor \dfrac{a}{b}\right\rfloor \cdot y_2
> 
> \end{align}
> \right.
> $$
> 因此可以将 $x,y$ 不断递归得到答案。

```c++
int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1;
        y = 0;
        return a;
    }

    int d = exgcd(b, a % b, x, y);
    int t = x;
    x = y;
    y = t - (a / b) * y;
    return d;
}
```



【例题】

给定 $a,b,c$，求 $ax+by=c$ 的 $x$ 最小正整数解 （$a,b,c$ 不限正负)。

```c++
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }

    int ans = exgcd(b, a % b, x, y);
    int tmp = x;
    x = y, y = tmp - a / b * y;
    return ans;
}

signed main() {
    int a, b, x, y, c;
    cin >> a >> b >> c;
    int d = exgcd(a, b, x, y);

    if (c % d != 0) {
        cout << "Impossible";
    } else {
        int ans = x * c / d;
        int t = abs(b / d);
        cout << (ans % t + t) % t;
    }

    return 0;
}
```



### 逆元

==注意，逆元存在的前提一定是模数为质数==。

1. 费马小定理求逆元

原理

> 利用 $x^{P - 1} \equiv 1 \pmod{p}$。
>
> 所以 $x$ 的逆元为 $x^{P - 2}$。

代码如下

```c++
inline int qmi(int a, int b, int p) {
    int res = 1;

    while (b) {
        if (b & 1) {
            res = res * a % p;
        }

        a = a * a % p;
        b >>= 1;
    }

    return res;
}

inline int inv(int x, int mod) {
    return qmi(x, mod - 2, mod);
}
```



2. 扩展欧几里得求逆元

扩展欧几里得的好处是不需要保证模数为质数。

给定 $a,b$,求满足 $ax\equiv 1 \pmod b$ 的最小 $x$。不保证 $a,b$ 一定互质。

```c++
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }

    int ans = exgcd(b, a % b, x, y);
    int tmp = x;
    x = y, y = tmp - a / b * y;
    return ans;
}

void solve() {
    int a, b, x, y;
    cin >> a >> b;

    if (exgcd(a, b, x, y) != 1) {
        cout << -1 << "\n";
        return;
    }

    cout << ((x % b) + b) % b << "\n";
}
```



3. 线性递推求逆元

核心代码 `inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;`

原理如下

>显然 $1^{-1}=1$。
>
>对于 $x>1$，设 $kx+r \equiv 0 \pmod{p}$，那么 $x^{-1} \equiv-kr^{-1}(\bmod p)\equiv-\lfloor \dfrac{p}{x}  \rfloor \times(p \bmod\ x)^{-1} \pmod{p}$。

 [【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)。

预处理 $1 \sim n$ 中所有数的逆元，以及阶乘逆元。

```c++
int inv[N], fac[N], invfac[N];
void solve() {
    inv[1] = 1;
    fac[0] = fac[1] = 1;
    invfac[0] = invfac[1] = 1;

    for (int i = 2; i <= n; i++) {
        inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
        fac[i] = fac[i - 1] * i % MOD;
        invfac[i] = invfac[i - 1] * inv[i] % MOD;
    }
}
```





## 线性同余方程组

### 中国剩余定理（CRT）

设 $m_1,m_2,...,m_k$ 是两两互质的 $k$ 个正整数,则方程组$
\left\{\begin{matrix}
x\equiv a_1(mod\ m_1)
 \\x\equiv a_2(mod\ m_2)
 \\ ...
 \\x\equiv a_k(mod\ m_k)
\end{matrix}\right.$ 的解为: 

$$
x=\sum_{i=1}^{k}  M_i{'}M_ia_i
$$

其中 $M=m_1m_2..m_k$，$ M_i=M\cdot m_i^{-1},\ M_i{'}M_i\equiv 1 \pmod{m_i}$。

```cpp
#include <bits/stdc++.h>
#define int long long

int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}

int CRT(std::vector<int> m, std::vector<int> a) { //下标从 0 开始
    assert(m.size() == a.size());
    int n = m.size(), M = 1, res = 0;
    for (int i = 0; i < n; i++) {
        M *= m[i];
    }
    for (int i = 0; i < n; i++) {
        int Mi = M / m[i];
        int u, v, d = exgcd(Mi, m[i], u, v);
        u = (u % m[i] + m[i]) % m[i];
        res += a[i] * u * Mi;
    }
    return res % M;
}

signed main() {
   int n;
    std::cin >> n;
    std::vector<int> m(n), a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> m[i] >> a[i];
    }
    std::cout << CRT(m, a) << "\n";
    return 0;
}
```



### 扩展中国剩余定理（EXCRT）

$Solution$：

一层一层把两个方程合并成一个。

[EXCRT模板题](https://www.luogu.com.cn/problem/P4777#submit)

```c++
#include <bits/stdc++.h>
#define int long long

int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    int g = exgcd(b, a % b, x, y);
    std::tie(x, y) = std::pair{y, x - a / b * y};
    return g;
}

int exCRT(std::vector<int> m, std::vector<int> a) { // 下标从 0 开始
    assert(m.size() == a.size());
    auto merge = [&](int &m1, int &a1, int m2, int a2) {
        int u, v;
        int g = exgcd(m1, m2, u, v);
        int m = m1 / g * m2;
        if ((a2 - a1) % g != 0) {
            return false;
        }
        int d = (a2 - a1) / g;
        int x = (__int128(u) * m1 * d + a1) % m;
        if (x < 0) {
            x += m;
        }
        m1 = m, a1 = x;
        return true;
    };
    int n = m.size(), mm = m[0], res = a[0];
    for (int i = 1; i < n; i++) {
        if (!merge(mm, res, m[i], a[i])) {
            return -1;
        }
    }
    return res;
}

signed main() {
    int n;
    std::cin >> n;
    std::vector<int> m(n), a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> m[i] >> a[i];
    }
    std::cout << exCRT(m, a) << "\n";
    return 0;
}
```



## 高次同余方程（同余对数）

### BSGS

[P3846 [TJOI2007] 可爱的质数/【模板】BSGS](https://www.luogu.com.cn/problem/P3846)

【题意】

给定 $a,b,p$，**保证 $a,p$ 互质**，求最小的 $x$，满足 $a^x \equiv b \pmod{p}$。或者报告无解。

$2 \le a,b,p\le 2^{31}$。

【思路】

首先根据费马小定理，答案一定在 $[0,p - 1]$ 范围内。

BSGS 的思想是根号分块，设答案 $x=i\cdot k-j$，其中 $k= \lceil \sqrt{p} \rceil$，$i,j\in[1,k]$。我们发现这样 $i,j,k$ 其实就足够表示 $[0,p]$ 的所有整数了。

把 $x$ 代回去有 $(a^k)^i\equiv b\times a^j \pmod{p}$。

因为 $i,j$ 都是 $\sqrt{p}$ 的规模，所以先枚举 $j$，把 $b_j$ 的值存进哈希表，然后再枚举 $i$ 去比配。$j$ 要尽可能地大，$i$ 要尽可能地小。

```cpp
int BSGS(int a, int b, int MOD) {
    a %= MOD;
    b %= MOD;
    if (b == 1) {
        return 0;
    }
    int k = sqrt(MOD) + 1;
    unordered_map<int, int> hash;
    for (int i = 0, j = b; i < k; i++) {
        hash[j] = i;
        j = j * a % MOD;
    }
    int ak = 1;
    for (int i = 0; i < k; i++) {
        ak = ak * a % MOD;
    }
    for (int i = 1, j = ak; i <= k; i++) {
        if (hash.count(j)) {
            return i * k - hash[j];
        }
        j = j * ak % MOD;
    }
    return -1;
}
```



### exBSGS

[P4195 【模板】扩展 BSGS/exBSGS](https://www.luogu.com.cn/problem/P4195)

【题意】

给定 $a,b,p$，**不保证 $a,p$ 互质**，求最小的 $x$，满足 $a^x \equiv b \pmod{p}$。或者报告无解。

$a,b,p \le 10^9$

【思路】

若 $b=0$，则 $p=1$ 时有解，否则无解。

若 $b=1$，则 $x=0$。

否则，设 $d=\gcd(a, p)$。若 $d \not\mid b$ 则无解，否则两边同时除以 $d$，得到
$$
(\frac{a}{d})a^{x-1} \equiv \frac{b}{d} \pmod{\frac{p}{d}}
$$
因为 $\gcd(\dfrac{a}{d},\dfrac{p}{d})=1$，所以
$$
a^{x-1}\equiv (\frac{a}{d})^{-1}(\frac{b}{d}) \pmod{\frac{p}{d}}
$$
多次执行上面的过程，知道 $a,p$ 互质，然后使用 BSGS。

```cpp
#include <bits/stdc++.h>
#define int long long

int qpow(int x, int k, int MOD) {
    int res = 1;
    while (k) {
        if (k % 2) {
            res = res * x % MOD;
        }
        k /= 2;
        x = x * x % MOD;
    }
    return res;
}

void exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return;
    }
    int t;
    exgcd(b, a % b, x, y);
    t = x;
    x = y;
    y = t - a / b * y;
}

int inv(int a, int b) {
    int x, y;
    exgcd(a, b, x, y);
    return (x % b + b) % b;
}

int BSGS(int a, int b, int MOD) {
    a %= MOD;
    b %= MOD;
    if (b == 1) {
        return 0;
    }
    int k = sqrt(MOD) + 1;
    std::unordered_map<int, int> hash;
    for (int i = 0, j = b; i < k; i++) {
        hash[j] = i;
        j = j * a % MOD;
    }
    int ak = 1;
    for (int i = 0; i < k; i++) {
        ak = ak * a % MOD;
    }
    for (int i = 1, j = ak; i <= k; i++) {
        if (hash.count(j)) {
            return i * k - hash[j];
        }
        j = j * ak % MOD;
    }
    return -1;
}

int exBSGS(int a, int b, int MOD) {
    if (MOD == 1) {
        return 0;
    }
    a %= MOD;
    b %= MOD;
    if (b == 1) {
        return 0;
    }
    int x = 0, t, res;
    int y = 1;
    while ((t = std::gcd(a, MOD)) != 1) {
        if (b % t != 0) {
            return -1;
        }
        b /= t;
        MOD /= t;
        x++;
        y = y * (a / t) % MOD;
        if (b == y) {
            return x;
        }
    }
    res = BSGS(a, b * inv(y, MOD) % MOD, MOD);
    if (res == -1) {
        return -1;
    }
    return res + x;
}

int a, b, MOD;

void solve() {
    std::cin >> a >> MOD >> b;
    if (a == 0 && b == 0 && MOD == 0) {
        exit(0);
    }
    int res = exBSGS(a, b, MOD);
    if (res == -1) {
        std::cout << "No Solution\n";
    } else {
        std::cout << res << "\n";
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    while (1) {
        solve();
    }
    return 0;
}
```



## 二次剩余（同余开方）





# 数论分块

## 计算和式

通用求法

$Problem:$

形如 $\sum_{i=1}^{n}f(i)\lfloor g(i)\rfloor $



$Solution:$

拆分成若干块 $[l,r]$ 分别求解，对于块 $[l,r]$，对答案的贡献为 $(r-l+1)g(l)\sum_{i=l}^{r}f(i)$。

所以关键有两点：

- 求出当前块的右端点
- $f(x)$ 能求和



求分块右端点的通用方法：

对于 $g(x)=\dfrac{n}{\lfloor f(x) \rfloor}$ 的分块左端点 $l$

设 $\dfrac{n}{\lfloor f(l) \rfloor}=\dfrac{n}{\lfloor f(r) \rfloor}=t<\dfrac{n}{f(r)}$，

然后解满足不等式 $f(r)<\dfrac{n}{\lfloor \frac{n}{f(l)} \rfloor}$ 的 $r$ 的最大值，向下取整；可直接解也可二分。

即解方程 $f(r)=\left \lfloor \dfrac{n}{\left\lfloor\frac{n}{f(l)}\right\rfloor}\right\rfloor $向下取整



一维数论分块代码

```c++
//cal(x):求当前分块的右端点
//f(x)：需要计算前缀和的函数
for(int l=1,r;l<=n;l=r+1){
    r=cal(l);//计算分块的右端点
    ans+=...;//对将块内贡献累加到总答案
}
```



二维数论分块代码

```c++
for(int l=1,r;l<= min(n,m);l=r+1){
    r=min(cal1(l),cal2(l));
    ans+=...;
}
```



常用结论

【引理】
$ \forall a,b,c\in\mathbb{Z},\left\lfloor\dfrac{a}{bc}\right\rfloor=\left\lfloor\dfrac{\left\lfloor\frac{a}{b}\right\rfloor}{c}\right\rfloor $



## 解不等式







# 欧拉函数 & 欧拉反演

## 欧拉函数

### 定义与计算

欧拉函数 $\phi(n)$ 表示 $[1,n]$ 中与 $n$ 互质的数字个数：
$$
\phi(n) = \sum_{i=1}^{n} [\gcd(i,n)=1] \tag{定义式}
$$

计算方法

1. 计算通式：设 $n$ 的质因数分解式 $n = \displaystyle\sum\limits_{i = 1}^{k} p_i ^{c_i}$，欧拉函数表达式如下：

$$
\varphi(n)=n\prod_{i=1}^{k}\frac{p_i-1}{p_i} \tag{计算式}
$$

推导（容斥原理）

> $$
> \begin{aligned}
> 
> \varphi(n) &=  n -  \sum\limits_{1 \le i \le k} \dfrac{n}{p_i} + \sum\limits_{1 \le i < j \le k} \dfrac{n}{p_ip_j} - \dots \\
> 
> &= n \prod\limits_{i = 1}^{k} \left( 1 - \dfrac{1}{p_i} \right) 
> 
> = n\prod\limits_{i = 1}^{k}\dfrac{p_i - 1}{p_i}
> 
> \end{aligned}
> $$

推导（积性函数）

> $$
> \begin{aligned}
> 
> \varphi(n) &= \varphi(\prod\limits_{i = 1}^{k}p_i^{c_i})\\
> 
> &= \prod\limits_{i = 1}^k \varphi(p_i ^{c_i})\\
> 
> &= \prod\limits_{i = 1}^k (p_i^{c_i} - p_i^{c_i - 1})\\
> 
> &= \prod\limits_{i = 1}^k p_i^{c_i} (1 - \dfrac{1}{p_i}) 
> 
> = n \prod\limits_{i = 1}^{k}\dfrac{p_i - 1}{p_i}
> 
> \end{aligned}
> $$
>

公式法求欧拉函数，时间复杂度为 $\dfrac {\sqrt n} {\log n} $


```c++
int phi(int x) {
    int res = x;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            res = res / i * (i - 1);
            while (x % i == 0) {
                x /= i;
            }
        }
    }
    if (x > 1) {
        res = res / x * (x - 1);
    }
    return res;
}
```



2. 对于素数 $p$ :

$$
\begin{align}
\varphi (p) &= p - 1 \tag{1}\\

\varphi (p^k) &= p^k - p^{k - 1} \tag{2}

\end{align}
$$

> 对于(1)：小于 $p$ 的所有整数都与 $p$ 互质
>
> 对于(2)：不超过 $p$ 的数字中，只有 $p$ 的倍数与 $p^k$ 不互质。



3. 若 $x,y$ 不互质，则 $\varphi(xy)=\dfrac{\varphi(x)\times\varphi(y)\times \gcd(x,y)}{\varphi(\gcd(x,y))}$。

> 证明未知。



### 线性筛

线性筛欧拉函数的原理如下

> 1. 若 $x$ 为质数，则有 $\varphi(x) = x - 1$
> 2. 若 $x$ 为合数，则 $\varphi(x)$ 一定在之前被求出。
> 3. 然后枚举素数 $p$ 进行线性筛。由于线性筛的特点， $p$ 一定是  $p\cdot x$ 最小的质因子。
>
> $$
> \varphi(px) = 
> \begin{cases}
> p \cdot \varphi(x), &p \mid x\\
> \varphi(p) \cdot \varphi(x), & p\nmid x
> \end{cases}
> $$

代码如下

```c++
int primes[N], pcnt = 0, phi[N];
bool vis[N];

void init(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (vis[i] == 0) {
            primes[++pcnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= pcnt && primes[j] * i <= n; j++) {
            int x = i * primes[j];
            vis[x] = 1;

            if (i % primes[j] == 0) {
                phi[x] = phi[i] * primes[j];
                break;
            } else {
                phi[x] = phi[i] * (primes[j] - 1);
            }
        }
    }
}
```



### 性质

1. $n>2$ 时，$ \varphi(n)$ 是偶数。进而可以得出：$[1,n]$ 中与 $n$ 互质的数的和：

$$
\sum\limits_{i=1}^{n}i[\gcd(i,n)=1]= \dfrac{n\varphi(n)+[n=1]}{2}
$$


> Proof：
>
> 由于更相减损术，$gcd(n,m)=gcd(n,n-m)$。所以每一个与 $n$ 互质的数字 $m$ 都对应一个 $n-m$ 与 $n$ 互质。
>

> 若 $n = 1$，则答案显然为 1。
>
> 对于 $n > 1$，与 $n$ 互质的数字总是成对出现，总共有 $\dfrac{\varphi(n)}{2}$ 对，每一对的和都为 $n$。所以答案为 $\dfrac{n\varphi(n)}{2}$。



2. 欧拉函数的卷积性质：

$$
\sum_{d|n}^{}\varphi(d)=n
$$

或者简写为：
$$
\varphi*1=id
$$


> Proof：
>
> 如果我们设 $f(x)$ 表示有多少个整数 $k$ 满足 $\gcd(k, n) = x$，那么 $n = \sum_{i = 1}^n{f(i)}$。（显然包含 $1\sim n$ 中所有的数）
>
> 由于 $\gcd(k,n) = x \iff \gcd(\dfrac{k}{x}, \dfrac{n}{x}) = 1$，所以 $f(x)$ 等价于与 $\dfrac{n}{x}$ 互质的数字个数，即 $f(x) = \varphi(\dfrac{n}{x})$。
>
> 从而 $n = \sum_{d \mid n}\varphi(\dfrac{n}{d})$，因为约数 $d$ 和 $\dfrac{n}{d} $ 具有对称性，所以上式化为 $n = \sum_{d \mid n}\varphi(d)$



3. 小结论：满足 $x+y=k(k>1)$，且 $\gcd(x,y)=1$ 的数对 $(x,y)$ 的数量 $=\varphi(k)$：

$$
\sum\limits_{x = 1}^{k}[\gcd(x, k - x) = 1] =\sum\limits_{x = 1}^{k}[\gcd(x, k) = 1]= \varphi(k)
$$



4. [[SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158)

在 $[1, n]$ 范围内，求互质的数对 $(i, j)$ 的数量：
$$
\sum\limits_{i=1}^n\sum\limits_{j=1}^n[\gcd(i,j)=1]=2\sum_{i=1}^n\varphi(i)-1
$$

> Proof：
>
> 我们假设 $1 \le i \le j$，将结果乘以 $2$ 即可。当$i = j > 1$ 时，$\gcd(i, j) = i \ne 1$，所以仅有 $i = j = 1$ 的情况被重复计算，所以最后答案减 $1$。
>
> 对于给定的 $i$，$\sum\limits_{j = 1}^{i} [\gcd(i, j) = 1]$ 就等于 $\varphi(i)$。
>
> 所以自然的答案为 $2\sum\limits_{i = 1}^{n} \varphi(i) - 1$。



5. [[SDOI2012] Longge 的问题](https://www.luogu.com.cn/problem/P2303)

求 $[1,n]$ 内每个数字与 $n$ 的 $\gcd$ 之和（$1 \le n \le 10^9$）：
$$
\sum_{i=1}^n\gcd(i,n)=\sum_{d|n}d \cdot \varphi(\frac{n}{d})
$$

> Proof：
>
> 我们设 $t(x)$ 为 $1\sim n$ 中与 $n$ 的 $\gcd$ 为 $x$ 的数的个数，即：
> $$
> t(x) = \sum_{i = 1} ^ {n} [\gcd(i, n) = x] = \sum_{i = 1}^{\left \lfloor \frac{n}{x}  \right \rfloor} [\gcd(\dfrac{i}{x}, \dfrac{n}{x}) = 1] = \varphi(\left \lfloor \frac{n}{x}  \right \rfloor)
> $$
> 所以原式可化简为：
> $$
> \sum_{i = 1}^n \gcd(i, n) = \sum_{d|n} d\cdot c(d) = \sum_{d|n}d \cdot \varphi(\dfrac{n}{d})
> $$



## 欧拉反演

### 欧拉反演

利用 
$$
id = \phi * 1
$$
把 $n$ 拆成 $\sum_{d\mid n} \phi(d)$ 的形式。



### 推论

1. 

$$
    \gcd(i, j)= \sum_{x\mid i,x\mid j} \varphi(x)
$$

  

2. 

$$
    \begin{aligned}
    \sum_{i=1}^{n}\sum_{j=1}^{m} \gcd(i,j)
    &= \sum_{i=1}^{n}\sum_{j=1}^{m} \sum_{x\mid i,x\mid j} \varphi(x)\\
    &= \sum_{x=1}^{n}\varphi(x) \sum_{i=1}^{n}\sum_{j=1}^{n} [x\mid i][x \mid j] \\
    &= \sum_{x=1}^{n}\varphi(x) \left\lfloor \dfrac{n}{x}  \right\rfloor
    \left\lfloor \dfrac{m}{x}  \right\rfloor
    \end{aligned}
$$

​    

# 莫比乌斯函数 & 莫比乌斯反演

## 莫比乌斯函数

### 定义和计算

设 $n$ 的质因数分解为 $n = \prod \limits_{i = 1} ^ {k} p_i^{c_i}$，定义莫比乌斯函数如下：
$$
\mu(n)=
\begin{cases}
0  & \exist i \in [1, k], \  c_i>1\\
(-1)^k  & \forall i \in [1, k], \  c_i = 1
\end{cases}
$$

公式法求莫比乌斯函数，复杂度 $O(\dfrac{\sqrt n }{\log n})$

```cpp
int mu(int x) {
	int cnt = 0;
	for (int i = 2; i * i <= x; i++) {
		if (x % i == 0) {
			x /= i;
			if (x % i == 0) {
				return 0;
			}
			cnt++;
		}
	}
	if (x != 1) {
		cnt++;
	}
	return (cnt & 1) ? -1 : 1;
}
```



### 性质

莫比乌斯函数的卷积性质：
$$
\sum_{d\mid n} \mu(d) = \varepsilon(n) = \begin{cases}

1, &n = 1\\
0, &n > 1

\end{cases}
$$
卷积形式为：
$$
\mu * 1 = \varepsilon
$$

> 证明：
>
> 只需考虑 $n > 1$ 的情形，此时显然 $k > 0$。
>
> 设 $n = \prod\limits_{i = 1}^{k} p_i^{c_i}$，$n' = \prod\limits_{i = 1}^{k} p_i$。
>
> 那么由于莫比乌斯函数的定义，结合二项式定理，有：
>
> $$
> \begin{align}
> \sum\limits_{d \mid n} \mu(d) & = \sum\limits_{d \mid n'} \mu(d)\\
> 
> & = \sum\limits_{i = 0}^{k} {k \choose i} \cdot (-1)^{i} \\
> & = (1 + (-1))^k \\
> & = 0
> 
> \end{align}
> $$



### 线性筛

原理如下

>若 $x$ 为质数，则有
>$$
>\mu(x) = -1
>$$
>
>反之若 $x$ 为合数，则 $\mu(x)$ 一定在之前被求出。
>
>然后枚举素数 $p$ 进行线性筛。由于线性筛的特点， $p$ 一定是  $p\cdot x$ 最小的质因子。
>$$
>\mu(px) = \begin{cases}
>
>0, & p\mid x \\
>
>-\mu(x), & p\nmid x\\
>
>\end{cases}
>$$

代码如下

```c++
int pcnt = 0, mu[N], primes[N], pre[N];
bool vis[N];

void getmu(int n) {
    pcnt = 0;
    mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) {
            primes[++pcnt] = i;
            mu[i] = -1;
        }
        for (int j = 1; j <= pcnt && primes[j] * i <= n; j++) {
            int x = primes[j];
            vis[x * i] = 1;
            if (i % x == 0) {
                mu[i * x] = 0;
                break;
            } 
            mu[i * x] = -mu[i];
        }
    }
    for (int i = 1; i <= n; i++) {
        pre[i] = pre[i - 1] + mu[i];
    }
}
```





## 莫比乌斯反演

### 莫比乌斯反演

【形式1】

如果 $F(n)=\sum_{d|n}f(d)$，则有 
$$
f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})
$$

【形式2】

如果 $F(n)=\sum_{n|d}f(d)$，那么有
$$
f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)
$$

简而言之：若 $F=f*1$，则 $f=\mu*F$



### 推论

1. 

$$
[\gcd(i, j)=1] = \sum_{d\mid i, d\mid j}\mu(d)
$$

2. 

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j) = k] = \sum_{d=1}^{\lfloor \frac{n}{k} \rfloor} \mu(d) \lfloor\frac{n}{dk}\rfloor \lfloor\frac{m}{dk}\rfloor
$$

3. 

$$
\sum_{i=1}^{n}\sum_{j=1}^{m} \operatorname{lcm}(i,j) = \sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^2 \mu(x) 
\frac{(1 + \lfloor\frac{n}{dx}\rfloor)\lfloor\frac{n}{dx}\rfloor}{2} \dfrac{(1 + \lfloor\frac{m}{dx}\rfloor) \lfloor\frac{m}{dx}\rfloor}{2}
$$





# 积性函数与卷积总结

## 约数个数函数

### 定义和计算

【定义】

$d(n)$ 表示 $n$ 的约数个数。

$$
d(n)=\sum_{i|n}1
$$



【计算式】

设 $n$ 的唯一分解为 $n=\prod\limits_{i=1}^{k}p_i^{c_i}$，则：

$$
d(n)=\prod\limits_{i=1}^{k}(c_i+1)
$$



### 性质

[[SDOI2015]约数个数和](https://www.luogu.com.cn/problem/P3327) 当中需要的一个结论
$$
d(xy)=\sum_{i|x}\sum_{j|y}[\gcd(i,j)=1]
$$

> 证明：
>
> 思路是把 $x\cdot y$ 的每一个因子 $k$ 一一映射为一个数对 $(i,j)$ 。
>
> 对于 $xy$ 的某一个因子 $k$，假设 $k$ 中的某一个质因子 $p$ 出现了 $c$ 次。
>
> 那么假设 $x,y$ 中分别包含了质因子 $p$ 的 $a, b$ 次方，一定有 $a + b > c$。我们规定：
>
> - 如果 $c < a$，那么就只在 $x$ 中选择 $p^c$；
> - 否则，在 $y$ 中选择 $p^{c - a}$ 。
>
> 通过这种方法选出的数字 $i, j$ 一定互质。



### 线性筛 $d(x)$

线性筛约数个数函数的原理如下。

> 首先构造函数：
>
> - $d(x)$ 为 $x$ 的约数个数；
> - $g(x)$ 为 $x$ 的最小质因子出现的次数。
>
> 
>
> 若 $x$ 为素数，有
> $$
> \begin{align}
> &g(x) = 1\\
> 
> &f(x) = 2
> 
> \end{align}
> $$
> 反之若 $x$ 为合数，$x$ 的函数值一定在之前被求出。
>
> 
>
> 假设已经求出 $x$ 的函数值，枚举素数 $p$ 进行线性筛。由于线性筛的特点， $p$ 一定是  $p\cdot x$ 最小的质因子，同时也是 $x$ 的最小质因子。
>
> $$
> \begin{align}
> &g(p\cdot x) = \begin{cases}
> 
> g(x) + 1, & p \mid x \\
> 
> 1, & p \nmid x
> 
> \end{cases}
> 
> \\
> \\
> 
> &d(p\cdot x) = \begin{cases}
> 
> 
> \dfrac{d(x)\cdot (g(px) + 1)}{g(px)}, & p \mid x \\
> 
> d(p) \cdot d(x), & p \nmid x
> 
> \end{cases}
> \end{align}
> $$
>

```c++
/*
d[i]是i的约数个数
g[i]是i的最小质因子出现次数
*/

void getdg(int n) {
    d[1] = 1;

    for (int i = 2; i <= n; ++i) {
        if (vis[i] == 0) {
            vis[i] = 1;
            primes[ ++ pcnt] = i;
            d[i] = 2;
            g[i] = 1;
        }

        for (int j = 1; j <= pcnt && i * primes[j] <= n; ++ j) {
            vis[primes[j] * i] = 1;

            if (i % primes[j] == 0) {
                //这里的primes[j]一定是i的最小质因子
                g[i * primes[j]] = g[i] + 1;
                d[i * primes[j]] = d[i] / g[i * primes[j]] * (g[i * primes[j]] + 1);
                break;
            } else {
                g[i * primes[j]] = 1;
                d[i * primes[j]] = d[i] * 2;
            }
        }
    }

}
```



## 约数和函数

### 定义和计算

【定义】

$\sigma(n)$ 表示 $n$ 的所有约数的和。

$$
\sigma(n)=\sum_{d|n}d
$$



【计算】

设 $n$ 的质因数分解为 $n=\prod_{i=1}^{k}p_i^{c_i}$，则：
$$
\begin{align}

\sigma(n)

&=(1 + p_1 + \dots + p_1^{c_1}) \times \dots \times(1 + p_k + \dots +  p_k^{c_k}) \\

&= \prod_{1=1}^k(\sum_{j=0}^{c_i}p_i^j) 

\end{align}
$$

> 原理：
>
> 把第一行的式子展开成多项式，$n$ 的每一个因数的质因子选择情况都包含在内。



### 线性筛 $\sigma(x)$

线性筛约数和函数的原理如下。

> 首先构造函数：
>
> - $f(x)$ 为 $x$ 的约数和；
>
>
> - $g(x)$ 为辅助函数，设 $x$ 的最小质因子为 $p$，$x$ 中包含 $p$ 的 $k$ 次幂，则 $g(x) = 1 + p + p ^ 2 + \dots + p^{k}$。
>
>
> 
>
> 若 $x$ 为素数，有：
> $$
>  \begin{align}
>  &g(x) = x + 1 \\
>  
>  &f(x) = x + 1
>  
>  \end{align}
> $$
> 反之若 $x$ 为合数， $x$ 的函数值一定在之前被求出。
>
> 
>
> 然后枚举素数 $p$ 进行线性筛。由于线性筛的特点， $p$ 一定是  $p\cdot x$ 最小的质因子。
> $$
> \begin{align}
> &g(px) = \begin{cases}
> 
> p\cdot g(x) + 1, & p \mid x\\
> 
> p + 1, & p \nmid x
> 
> \end{cases}
> 
> \\
> \\
> 
> 
> &f(px) = \begin{cases}
> 
> \dfrac{f(x)g(px)}{g(x)}, &p \mid x\\
> 
> f(p)f(x), &p \nmid x
> 
> \end{cases}
> \end{align}
> $$
>
> 

```c++
void get_divisor_sum() {
    g[1] = f[1] = 1;

    for (int i = 2; i <= n; ++ i) {
        if (vis[i] == 0) {
            vis[i] = 1;
            primes[++pcnt] = i;
            g[i] = i + 1;
            f[i] = i + 1;
        }

        for (int j = 1; j <= pcnt && i * primes[j] <= n; ++ j) {
            v[i * primes[j]] = 1;

            if (i % primes[j] == 0) {
                g[i * primes[j]] = g[i] * primes[j] + 1;
                f[i * primes[j]] = f[i] / g[i] * g[i * primes[j]];
                break;
            } else {
                f[i * primes[j]] = f[i] * f[primes[j]];
                g[i * primes[j]] = primes[j] + 1;
            }
        }
    }

    // 原题需要求一下前缀和
    for (int i = 1; i <= n; ++ i) {
        f[i] = (f[i - 1] + f[i]) % MOD;
    }
}

```



## 重要卷积关系总结

常用积性函数函数

- 单位元函数：$\varepsilon(n)=[n=1]$

- 
    单位函数：$\mathrm{id}(n)=n$，完全积性函数

- 幂函数： $\mathrm{id}^k(n)=n^k$，完全积性函数

- 恒等函数： $1(n) = 1$

- 欧拉函数： $\varphi(n)=\sum\limits_{i=1}^{n}[\gcd(n,i)=1]$

- 约数和函数：$\sigma(n)=\sum\limits_{d|n}{}d$

- 约数个数函数：$\mathrm{d}(n)=\sum\limits_{d|n}{}1$

- 莫比乌斯函数：$\mu(n)=
    \begin{cases}
    0  & \exist i \in [1, k], \  c_i>1\\
    (-1)^k  & \forall i \in [1, k], \  c_i = 1
    \end{cases}$



1. 卷积的单位元

 $\varepsilon$ 是卷积的单位元。对任意数论函数 $f$：
$$
f*\varepsilon=f
$$

> 证明：
>
> 显然有 $f*\varepsilon(n) = \sum\limits_{d \mid n}f(d) \varepsilon(\dfrac{n}{d}) = \sum\limits_{d \mid n} f(d) [\dfrac{n}{d} = 1] = f(n)$。





2. 与 $1$ 卷积的含义

$f * 1(n)$ 的含义就是：对于 $n$ 的所有正因数 $d$，把 $f(d)$ 的函数值累加得到的结果。





3. 莫比乌斯函数的卷积关系（卷积逆元）

这个性质是莫比乌斯反演的根基：$\mu$ 和 $1$ 互为卷积逆元：
$$
1*\mu= \varepsilon
$$

> 已经在莫比乌斯函数的性质那部分证明过。





4.  欧拉函数的卷积关系

$$
\mathrm{id}*\mu=\varphi \\
\varphi*1=\mathrm{id}
$$

> 只需证明 $\varphi * 1 = id$。这个式子在欧拉函数的性质那部分证明过。





5. 约数和函数的卷积关系

$$
\mathrm{id} * 1 =\sigma
$$

> 证明：
>
> 显然有  $\begin{align}
> \mathrm{id}(n) * 1= & \sum\limits_{d \mid n}  \mathrm{id}(d) \times1(\dfrac{n}{d}) = \sum\limits_{d \mid n}d = \sigma(n)
> \end{align}$。





6. 约数个数函数的卷积关系

$$
1*1= \mathrm{d}
$$

> 证明：
>
> 显然 $\begin{align}
> 1 * 1(n) &= \sum\limits_{d \mid n}1(n) \times 1(n) = \sum\limits_{d \mid n} 1= d(n)
> \end{align} $。





7. 总结

$$
\mu \overset{*1}{\Rightarrow }  \varepsilon \overset{*1}{\Rightarrow } 1 \overset{*1}{\Rightarrow } \mathrm{d} \\
\varphi \overset{*1}{\Rightarrow } \mathrm{id} \overset{*1}{\Rightarrow } \sigma
$$



8. 卷积的预处理：$O(n \log n)$ 预处理卷积

若已知数论函数 $f, g$，可以将枚举约数转换成枚举倍数，以调和级数 $O(n\log n)$ 的复杂度求出 $f * g$ 的前 $n$ 项 ：

```cpp
for (int i = 1; i <= n; ++ i) {
    for (int j = i; j <= n; j += i) {
        h[j] = (h[j] + f[i] * g[j / i]) % MOD;
    }
}
```





## Dilichelet 前缀和





## 一般积性函数的线性筛法





# 高级筛法

## 杜教筛





## 洲阁筛





## min25筛



